---
layout: post
title:  软件工程
description: 计算机软件工程 CASE (computer-aided software engineering)计算机辅助软件工程相关内容
date: 2022-10-01 09:01:01
updatedate: 2023-05-26 10:25:01
---

- [软件开发流程](#软件开发流程)
  - [可行性分析](#可行性分析)
  - [需求分析](#需求分析)
    - [1,需要明确项目的背景](#1需要明确项目的背景)
    - [2,需求规格](#2需求规格)
    - [过程](#过程)
    - [方法](#方法)
    - [需求分析的任务](#需求分析的任务)
  - [架构设计](#架构设计)
    - [定义](#定义)
      - [说明](#说明)
      - [影响因素](#影响因素)
    - [开发质量属性](#开发质量属性)
      - [运行期](#运行期)
        - [性能](#性能)
        - [安全](#安全)
        - [易用](#易用)
        - [可伸缩](#可伸缩)
        - [互操作](#互操作)
        - [可靠](#可靠)
        - [持续可用](#持续可用)
        - [鲁棒](#鲁棒)
      - [开发期](#开发期)
        - [易理解性](#易理解性)
        - [可扩展性](#可扩展性)
        - [可重用性](#可重用性)
        - [可测试性](#可测试性)
        - [可维护性](#可维护性)
        - [可移植性](#可移植性)
    - [模型](#模型)
      - [结构模型](#结构模型)
      - [框架模型](#框架模型)
      - [动态模型](#动态模型)
      - [过程模型](#过程模型)
      - [功能模型](#功能模型)
    - [4+1视图](#41视图)
      - [逻辑视图](#逻辑视图)
      - [子主题6](#子主题6)
      - [进程视图](#进程视图)
      - [物理视图](#物理视图)
      - [场景视图](#场景视图)
  - [概要设计](#概要设计)
    - [把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口。生成《软件概要设计说明书》。](#把软件按照一定的原则分解为模块层次赋予每个模块一定的任务并确定模块间调用关系和接口生成软件概要设计说明书)
  - [详细设计](#详细设计)
    - [依据概要设计阶段的分解，设计每个模块内的算法、流程等。《软件详细设计说明书》](#依据概要设计阶段的分解设计每个模块内的算法流程等软件详细设计说明书)
  - [编码](#编码)
    - [代码](#代码)
  - [测试](#测试)
    - [黑盒](#黑盒)
    - [白盒](#白盒)
  - [验收](#验收)
    - [《验收报告》](#验收报告)
- [软件开发模式](#软件开发模式)
  - [软件开发模式](#软件开发模式-1)
    - [ATDD：验收测试驱动开发](#atdd验收测试驱动开发)
      - [什么是ATDD#](#什么是atdd)
      - [ATDD工具](#atdd工具)
        - [Selenium](#selenium)
        - [Robot Framework](#robot-framework)
      - [ATDD的基本流程#](#atdd的基本流程)
        - [讨论澄清阶段](#讨论澄清阶段)
        - [开发阶段](#开发阶段)
        - [交付阶段](#交付阶段)
      - [ATDD的好处#](#atdd的好处)
      - [ATDD自动化测试框架](#atdd自动化测试框架)
    - [DDD：领域驱动开发](#ddd领域驱动开发)
      - [概念](#概念)
      - [领域建模](#领域建模)
      - [生命周期](#生命周期)
      - [软件系统架构风格](#软件系统架构风格)
        - [经典分层架构（N-Tier Architecture）](#经典分层架构n-tier-architecture)
        - [事件驱动型架构（Event-Driven Architecture）](#事件驱动型架构event-driven-architecture)
        - [微服务架构（Microservices Architecture）](#微服务架构microservices-architecture)
    - [TDD(UTDD)：测试驱动开发](#tddutdd测试驱动开发)
      - [测试驱动开发是敏捷开发中的一项核心实践和技术，](#测试驱动开发是敏捷开发中的一项核心实践和技术)
      - [TDD流程](#tdd流程)
      - [TDD 的三条规则](#tdd-的三条规则)
      - [好的单元测试应该符合几条原则：](#好的单元测试应该符合几条原则)
      - [TDD 编码方式](#tdd-编码方式)
      - [TDD（测试驱动开发）相关测试框架](#tdd测试驱动开发相关测试框架)
      - [测试驱动开发的基本过程](#测试驱动开发的基本过程)
      - [测试驱动开发的原则](#测试驱动开发的原则)
    - [BDD：行为驱动开发](#bdd行为驱动开发)
- [概要设计](#概要设计-1)
  - [概要设计就是设计软件的结构](#概要设计就是设计软件的结构)
  - [与详细设计区别](#与详细设计区别)
  - [概要设计怎么做](#概要设计怎么做)
  - [设计组成部分概述](#设计组成部分概述)
  - [概要设计的任务](#概要设计的任务)
  - [概要设计的目的](#概要设计的目的)
  - [问题的提出](#问题的提出)
  - [概要设计的原则](#概要设计的原则)
  - [概要设计的重要输出](#概要设计的重要输出)
- [详细设计](#详细设计-1)
  - [发现很多共性的内容，需要提炼为整个程序需要遵循的设计规范](#发现很多共性的内容需要提炼为整个程序需要遵循的设计规范)
  - [目的](#目的)
  - [软件需求分析人员组织](#软件需求分析人员组织)
    - [软件需求分析其根本性问题是理解用户功能需求，由此软件需求分析实际上是与客户间交流过程完成的目标。要求我们组织适当的参与人员进行交流活动。](#软件需求分析其根本性问题是理解用户功能需求由此软件需求分析实际上是与客户间交流过程完成的目标要求我们组织适当的参与人员进行交流活动)
  - [定义](#定义-1)
    - [软件需求分析（Software Reguirement Analysis）是研究用户需求得到的东西，完全理解用户对软件需求的完整功能，确认用户软件功能需求，建立可确认的、可验证的一个基本依据。](#软件需求分析software-reguirement-analysis是研究用户需求得到的东西完全理解用户对软件需求的完整功能确认用户软件功能需求建立可确认的可验证的一个基本依据)
  - [软件需求分析理论](#软件需求分析理论)
    - [如果我们用数学方法来描述软件需求分析，可以将一个应用软件定义为S，可能应用软件涉及功能性问题非常广，我们用抽象化理论分析，可以划分为各个功能域，可以用D1、D2、… Dn表示，那么，我们可以用一个表达式描述为](#如果我们用数学方法来描述软件需求分析可以将一个应用软件定义为s可能应用软件涉及功能性问题非常广我们用抽象化理论分析可以划分为各个功能域可以用d1d2-dn表示那么我们可以用一个表达式描述为)
  - [主要实现目标](#主要实现目标)
    - [1）对实现软件的功能做全面的描述，帮助用户判断实现功能的正确性、一致性和完整 性，促使用户在软件设计启动之前周密地、全面地思考软件需求；](#1对实现软件的功能做全面的描述帮助用户判断实现功能的正确性一致性和完整-性促使用户在软件设计启动之前周密地全面地思考软件需求)
    - [2）了解和描述软件实现所需的全部信息，为软件设计、确认和验证提供一个基准；](#2了解和描述软件实现所需的全部信息为软件设计确认和验证提供一个基准)
    - [3）为软件成本计价和软件开发计划提供依据；](#3为软件成本计价和软件开发计划提供依据)
    - [需求分析具体内容可以归纳为六个方面：](#需求分析具体内容可以归纳为六个方面)
      - [软件的功能需求](#软件的功能需求)
      - [软件与硬件或其他外部系统接口](#软件与硬件或其他外部系统接口)
      - [软件的非功能性需求](#软件的非功能性需求)
      - [软件的反向需求](#软件的反向需求)
      - [软件设计和实现上的限制](#软件设计和实现上的限制)
      - [阅读支持信息](#阅读支持信息)
    - [软件需求分析应尽量提供软件实现功能需求的全部信息，使得软件设计人员和软件测试人员不再需要需求方的接触。这就要求软件需求分析内容应正确、完整、一致和可验证。此外，为保证软件设计质量，便于软件功能的休整和验证，软件需求表达无岔意性，具有可追踪性和可修改性。](#软件需求分析应尽量提供软件实现功能需求的全部信息使得软件设计人员和软件测试人员不再需要需求方的接触这就要求软件需求分析内容应正确完整一致和可验证此外为保证软件设计质量便于软件功能的休整和验证软件需求表达无岔意性具有可追踪性和可修改性)
  - [软件功能需求](#软件功能需求)
    - [软件的功能需求是整个需求分析最主要、最关键和最复杂的部分，它描述软件的各种可能的条件下，对所有可能输入的数据信息，应完成那些具体功能，产生什么样的输出。描述软件功能需求是应注意下面几点：](#软件的功能需求是整个需求分析最主要最关键和最复杂的部分它描述软件的各种可能的条件下对所有可能输入的数据信息应完成那些具体功能产生什么样的输出描述软件功能需求是应注意下面几点)
    - [1）功能需求的完整性和一致性](#1功能需求的完整性和一致性)
      - [对功能的描述应包含与功能相关的信息，并应具有内在的一致性（即各种描述之间不矛盾、不冲突）。应注意以下几点：](#对功能的描述应包含与功能相关的信息并应具有内在的一致性即各种描述之间不矛盾不冲突应注意以下几点)
      - [（1）    给出触发功能的各种条件（如：控制流、运行状态、运行模式等）；](#1----给出触发功能的各种条件如控制流运行状态运行模式等)
      - [（2）    定义各种可能性条件下的所有可能的输入（包括合法的输入空间和非法的输入空间）；](#2----定义各种可能性条件下的所有可能的输入包括合法的输入空间和非法的输入空间)
      - [（3）    给出各种功能间可能的相互关系（如各个功能间的控制流、数据流、信息流，功能运行关系：顺序、重复、选择、并发、同步）；](#3----给出各种功能间可能的相互关系如各个功能间的控制流数据流信息流功能运行关系顺序重复选择并发同步)
      - [（4）    给出功能性的主要级别（如：基本功能、可由设计者选择逐步实现的功能、可由设计者改变实现的功能等）；](#4----给出功能性的主要级别如基本功能可由设计者选择逐步实现的功能可由设计者改变实现的功能等)
      - [（5）    尽可能不使用“待定”这样的词。所有含有待定内容的需求都不是完整的文件，如果出现待定的部分，必须进行待定部分内容说明，落实负责人员、落实实施日期。](#5----尽可能不使用待定这样的词所有含有待定内容的需求都不是完整的文件如果出现待定的部分必须进行待定部分内容说明落实负责人员落实实施日期)
    - [2）功能描述的无岔意性和可追踪性](#2功能描述的无岔意性和可追踪性)
      - [需求功能描述的无岔意性、可追踪性和规范化：](#需求功能描述的无岔意性可追踪性和规范化)
      - [（1）    功能描述必须清晰地描述出怎样输入到怎样输出，并且输入、输出描述应对应有数据流描述、控制流描述图，这些描述必须与其它地方描述一致；](#1----功能描述必须清晰地描述出怎样输入到怎样输出并且输入输出描述应对应有数据流描述控制流描述图这些描述必须与其它地方描述一致)
      - [（2）    可以用语言、方程式、决策表、矩阵或图等对功能的描述。如果选用语言描述必须使用结构化的语言，描述前必须说明该步骤（或子功能）的执行是顺序，选择，重复，还是并发，然后说明步骤逻辑。整个描述必须单入单出。](#2----可以用语言方程式决策表矩阵或图等对功能的描述如果选用语言描述必须使用结构化的语言描述前必须说明该步骤或子功能的执行是顺序选择重复还是并发然后说明步骤逻辑整个描述必须单入单出)
      - [（3）    描述时，每一个功能名称和参照编号必须唯一，且不要将多个功能混在一起进行描述，这样便于功能的追踪和修改。](#3----描述时每一个功能名称和参照编号必须唯一且不要将多个功能混在一起进行描述这样便于功能的追踪和修改)
      - [（4）    功能描述应注意需求说明和程序设计的区别。需求设计仅仅是软件的功能设计，它给出软件运行的的外部功能描述，以及为了实现这一外部功能必须做哪些事情（采用和种数据结构，定义多个模块，接口间的接口等）是设计阶段的事情，功能描述不应涉及到那些细节问题，以避免给软件设计带来不必要的约束。](#4----功能描述应注意需求说明和程序设计的区别需求设计仅仅是软件的功能设计它给出软件运行的的外部功能描述以及为了实现这一外部功能必须做哪些事情采用和种数据结构定义多个模块接口间的接口等是设计阶段的事情功能描述不应涉及到那些细节问题以避免给软件设计带来不必要的约束)
    - [2.2、      软件与硬件或其他外部系统接口](#22------软件与硬件或其他外部系统接口)
      - [（4）    通讯接口：指定通讯接口和通讯协议等描述。](#4----通讯接口指定通讯接口和通讯协议等描述)
      - [软件与硬件或其它外部系统接口包括下述内容：](#软件与硬件或其它外部系统接口包括下述内容)
      - [（1）    人机接口：说明输入、输出的内容、屏幕安排、格式等要求；](#1----人机接口说明输入输出的内容屏幕安排格式等要求)
      - [（2）    硬件接口：说明端口号，指令集，输入输出信号的内容与数据类型，初始化信号源，传输通道号和信号处理方式。](#2----硬件接口说明端口号指令集输入输出信号的内容与数据类型初始化信号源传输通道号和信号处理方式)
      - [（3）    软件接口：说明软件的名称、助记符、规格说明、版本号和来源；](#3----软件接口说明软件的名称助记符规格说明版本号和来源)
    - [2.3、      软件的非功能性需求](#23------软件的非功能性需求)
      - [软件非功能性需求是指软件性能指标，容限等功能以外的需求。一般指下述内容：](#软件非功能性需求是指软件性能指标容限等功能以外的需求一般指下述内容)
      - [（1）    时间需求：输入、输出频率，输入、输出响应时间，各种功能恢复时间等；](#1----时间需求输入输出频率输入输出响应时间各种功能恢复时间等)
      - [（2）    处理容限、精度、采样参数的分辨率，误差处理等；](#2----处理容限精度采样参数的分辨率误差处理等)
      - [（3）    可靠性的MTBF要求，可维护性、安全性要求等。（对可能的不正常的输入给以正常响应是可靠性的重要内容，这属于功能性需求。）](#3----可靠性的mtbf要求可维护性安全性要求等对可能的不正常的输入给以正常响应是可靠性的重要内容这属于功能性需求)
    - [2.4、      软件反向需求](#24------软件反向需求)
      - [软件的反向需求描述软件在那些情况下不能做什么。这一条是随软件实际要求而定。有两类情形需要采用反向需求的形式。第一种情况：某些用户需求适宜采用反向形式说明，如数据安全性要求属于这类形式。第二种情况：对一些可靠性和安全性要求较高的软件，有些必须描述软件不能做些什么。如控制点火时序，我们必须交代清楚在那些情况下不能点火，否则会造成故障。](#软件的反向需求描述软件在那些情况下不能做什么这一条是随软件实际要求而定有两类情形需要采用反向需求的形式第一种情况某些用户需求适宜采用反向形式说明如数据安全性要求属于这类形式第二种情况对一些可靠性和安全性要求较高的软件有些必须描述软件不能做些什么如控制点火时序我们必须交代清楚在那些情况下不能点火否则会造成故障)
    - [2.5、      软件设计和实现上的限制](#25------软件设计和实现上的限制)
      - [软件设计和实现上的限制主要指对软件设计者的限制。如软件运行环境的限制（选择计算机类型，使用配置，操作系统的限制等）、设计工具的限制（使用语言、执行的标准）和保密要求等。](#软件设计和实现上的限制主要指对软件设计者的限制如软件运行环境的限制选择计算机类型使用配置操作系统的限制等设计工具的限制使用语言执行的标准和保密要求等)
    - [2.6、      阅读支持信息](#26------阅读支持信息)
      - [这部分内容是为了更好的帮助我们理解用户需求，也是为了使需求便于修改和追踪。其本身并不是对需求的描述，但它影响到需求分析的可读性，也属于需求分析的一个重要部分。一般目录、需求背景信息、内容索引、交叉引用表、注释等均属于这个部分的内容。](#这部分内容是为了更好的帮助我们理解用户需求也是为了使需求便于修改和追踪其本身并不是对需求的描述但它影响到需求分析的可读性也属于需求分析的一个重要部分一般目录需求背景信息内容索引交叉引用表注释等均属于这个部分的内容)
  - [软件需求分析方法](#软件需求分析方法)
    - [为了保证项目的正常实施，并且能够顺利的完成，我们必须加强项目管理和重视项目分析工作。我们只有从实际出发，切切实实地把握用户需求，把握用户需求目标，把握用户将来功能界定，保证我们开发工作正确性方向。](#为了保证项目的正常实施并且能够顺利的完成我们必须加强项目管理和重视项目分析工作我们只有从实际出发切切实实地把握用户需求把握用户需求目标把握用户将来功能界定保证我们开发工作正确性方向)
    - [4.1、重点监控软件需求分析办法](#41重点监控软件需求分析办法)
      - [由于软件项目的特殊性和行业覆盖的广阔性，以及需求分析的高风险性，软件需求分析的重要性是不言而喻的，同时需求分析又的的确确难做。其原因基本是由于以下情况造成的。](#由于软件项目的特殊性和行业覆盖的广阔性以及需求分析的高风险性软件需求分析的重要性是不言而喻的同时需求分析又的的确确难做其原因基本是由于以下情况造成的)
      - [4.1.1、客户说不清楚需求](#411客户说不清楚需求)
        - [有些客户对需求只有朦胧的感觉，当然说不清楚具体的需求。例如全国各地的很多部门、机构、单位在进行应用系统以及网络建设时，客户方的办公人员大多不清楚计算机网络有什么用，更缺乏IT系统建设方面的专家和知识。此时，用户就会要求软件系统分析人员替他们设想需求。工程的需求存在一定的主观性，为项目未来建设埋下了潜在的风险。](#有些客户对需求只有朦胧的感觉当然说不清楚具体的需求例如全国各地的很多部门机构单位在进行应用系统以及网络建设时客户方的办公人员大多不清楚计算机网络有什么用更缺乏it系统建设方面的专家和知识此时用户就会要求软件系统分析人员替他们设想需求工程的需求存在一定的主观性为项目未来建设埋下了潜在的风险)
      - [4.1.2、需求自身经常变动](#412需求自身经常变动)
        - [根据以往的历史经验，随着客户方对信息化建设的认识和自己业务水平的提高，他们会在不同的阶段和时期对项目的需求提出新的要求和需求变更。事实上，历史上没有一个软件的需求改动少于三次的！所以必须接受“需求会变动”这个事实，在进行需求分析时要懂得防患于未然，尽可能地分析清楚哪些是稳定的需求，哪些是易变的需求，以便在进行系统设计时，将软件的核心建筑在稳定的需求上，同时留出变更空间。咨询监理方在需求分析的功能界定上担任一个中间、公平、公正的角色，所以也必须积极参与到需求分析的准备中来，以便协助客户方和承建方来界定“做什么”、“不做什么”的系统功能界限。](#根据以往的历史经验随着客户方对信息化建设的认识和自己业务水平的提高他们会在不同的阶段和时期对项目的需求提出新的要求和需求变更事实上历史上没有一个软件的需求改动少于三次的所以必须接受需求会变动这个事实在进行需求分析时要懂得防患于未然尽可能地分析清楚哪些是稳定的需求哪些是易变的需求以便在进行系统设计时将软件的核心建筑在稳定的需求上同时留出变更空间咨询监理方在需求分析的功能界定上担任一个中间公平公正的角色所以也必须积极参与到需求分析的准备中来以便协助客户方和承建方来界定做什么不做什么的系统功能界限)
      - [4．1．3、分析人员或客户理解有误](#413分析人员或客户理解有误)
        - [软件系统分析人员不可能都是全才，更不可能是行业方面的专家。客户表达的需求，不同的分析人员可能有不同的理解。如果分析人员理解错了，可能会导致以后的开发工作劳而无功。记得一则笑话，有个外星人间谍潜伏到地球刺探情报，它给上司写了一份报告：“主宰地球的是汽车。它们喝汽油，靠四个轮子滚动前进，嗓门极大，双眼在夜里能射出强光……有趣的是，车里住着一种叫作‘人’的寄生虫，这些寄生虫完全控制了车。”所以分析人员知识的专一性也会造成需求分析的误解和失败。这时，咨询监理公司就必须根据实际的项目需求调研计划，提醒承建方加强业务了解程度和注重沟通技巧。](#软件系统分析人员不可能都是全才更不可能是行业方面的专家客户表达的需求不同的分析人员可能有不同的理解如果分析人员理解错了可能会导致以后的开发工作劳而无功记得一则笑话有个外星人间谍潜伏到地球刺探情报它给上司写了一份报告主宰地球的是汽车它们喝汽油靠四个轮子滚动前进嗓门极大双眼在夜里能射出强光有趣的是车里住着一种叫作人的寄生虫这些寄生虫完全控制了车所以分析人员知识的专一性也会造成需求分析的误解和失败这时咨询监理公司就必须根据实际的项目需求调研计划提醒承建方加强业务了解程度和注重沟通技巧)
    - [4.2、有效性软件需求分析三步法](#42有效性软件需求分析三步法)
      - [根据以往的工程经验，需求分析工作方法，应该定位在“三个阶段”（也称“三步法”）。](#根据以往的工程经验需求分析工作方法应该定位在三个阶段也称三步法)
      - [4.2.1、“访谈式Visitation”阶段](#421访谈式visitation阶段)
        - [这一阶段是和具体用户方的领导层、业务层人员的访谈式沟通，主要目的是从宏观上把握用户的具体需求方向和趋势，了解现有的组织架构、业务流程、硬件环境、软件环境、现有的运行系统等等具体情况、客观的信息。建立起良好的沟通渠道和方式。针对具体的职能部门以及各委办局，最好能指定本次项目的接口人。](#这一阶段是和具体用户方的领导层业务层人员的访谈式沟通主要目的是从宏观上把握用户的具体需求方向和趋势了解现有的组织架构业务流程硬件环境软件环境现有的运行系统等等具体情况客观的信息建立起良好的沟通渠道和方式针对具体的职能部门以及各委办局最好能指定本次项目的接口人)
      - [4.2.2、“诱导式Inducement”阶段](#422诱导式inducement阶段)
        - [这一阶段是在承建方已经了解了具体用户方的组织架构、业务流程、硬件环境、软件环境、现有的运行系统等等具体实际、客观的信息基础上，结合现有的硬件、软件实现方案，做出简单的用户流程页面，同时结合以往的项目经验对用户采用诱导式、启发式的调研方法和手段，和用户一起探讨业务流程设计的合理性、准确性、便易性、习惯性。用户可以操作简单演示的DEMO，来感受一下整个业务流程的设计合理性、准确性等等问题，及时地提出改进意见和方法。](#这一阶段是在承建方已经了解了具体用户方的组织架构业务流程硬件环境软件环境现有的运行系统等等具体实际客观的信息基础上结合现有的硬件软件实现方案做出简单的用户流程页面同时结合以往的项目经验对用户采用诱导式启发式的调研方法和手段和用户一起探讨业务流程设计的合理性准确性便易性习惯性用户可以操作简单演示的demo来感受一下整个业务流程的设计合理性准确性等等问题及时地提出改进意见和方法)
      - [4.2.3、“确认式Afirm”阶段](#423确认式afirm阶段)
        - [这一阶段是在上述两个阶段成果的基础上，进行具体的流程细化、数据项的确认阶段，这个阶段承建方必须提供原型系统和明确的业务流程报告、数据项表，并能清晰地向用户描述系统的业务流设计目标。用户方可以通过审查业务流程报告、数据项表以及操作承建方提供的DEMO系统，来提出反馈意见，并对已经可接受的报告、文档签字确认。](#这一阶段是在上述两个阶段成果的基础上进行具体的流程细化数据项的确认阶段这个阶段承建方必须提供原型系统和明确的业务流程报告数据项表并能清晰地向用户描述系统的业务流设计目标用户方可以通过审查业务流程报告数据项表以及操作承建方提供的demo系统来提出反馈意见并对已经可接受的报告文档签字确认)
        - [实现手段：拜访（回顾、确认），提交业务流程报告、数据项表；原型演示系统](#实现手段拜访回顾确认提交业务流程报告数据项表原型演示系统)
        - [输出成果：需求分析报告、数据项、业务流程报告、原型系统反馈意见（后三者可以统一归入需求分析报告中，提交用户方、监理方进行确认和存档）](#输出成果需求分析报告数据项业务流程报告原型系统反馈意见后三者可以统一归入需求分析报告中提交用户方监理方进行确认和存档)
        - [整体来讲，需求分析的三个阶段是需求调研中不可忽视一个重要的部分，三个阶段或者说三步法的实施和采用，对用户和承建方都同样提供了项目成功的保证。当然在系统建设的过程中，特别在采用迭代法的开发模式时，需求分析的工作需一直进行下去，而在后期的需求改进中，工作则基本集中在后两个阶段中。](#整体来讲需求分析的三个阶段是需求调研中不可忽视一个重要的部分三个阶段或者说三步法的实施和采用对用户和承建方都同样提供了项目成功的保证当然在系统建设的过程中特别在采用迭代法的开发模式时需求分析的工作需一直进行下去而在后期的需求改进中工作则基本集中在后两个阶段中)
  - [软件需求分析工具](#软件需求分析工具)
    - [我们根据用户需求，通过反复讨论、分析，最终明确一个唯一性的用户需求，这个结果其实就是我们的软件需求分析报告。一般我们采用Word、PowerPoint、Visio、ProntPage、Excel等Office工具，同时可能采用一些开发工具，如VC或BC等，同样也会使用一些图形工具，如Potoshop、调色板等画图工具。](#我们根据用户需求通过反复讨论分析最终明确一个唯一性的用户需求这个结果其实就是我们的软件需求分析报告一般我们采用wordpowerpointvisioprontpageexcel等office工具同时可能采用一些开发工具如vc或bc等同样也会使用一些图形工具如potoshop调色板等画图工具)
    - [使用各种工具表达软件需求分析，其具体表达手段可以分为：](#使用各种工具表达软件需求分析其具体表达手段可以分为)
    - [l        效果图描述。主要是用户UI界面的描述反映用户需求功能；](#l--------效果图描述主要是用户ui界面的描述反映用户需求功能)
    - [l        逻辑图描述。根据用户需求功能，使用抽象化理论，以及需求分析理论，对用户需求功能进行全面的分析，建立功能性逻辑关系图，流程逻辑关系图等；](#l--------逻辑图描述根据用户需求功能使用抽象化理论以及需求分析理论对用户需求功能进行全面的分析建立功能性逻辑关系图流程逻辑关系图等)
    - [l        关系图表描述。主要是对信息关系、数据库表格、接口函数等描述；](#l--------关系图表描述主要是对信息关系数据库表格接口函数等描述)
    - [l        工程数学描述。分析用户需求，分析用户需求信息，运用工程数学进行算法推导，进行合理化需求分析推导；](#l--------工程数学描述分析用户需求分析用户需求信息运用工程数学进行算法推导进行合理化需求分析推导)
    - [l        甘地图描述。主要是软件项目工作安排，开发周期预估；](#l--------甘地图描述主要是软件项目工作安排开发周期预估)
    - [l        其它方法描述。保证完整性合理性的有效描述。](#l--------其它方法描述保证完整性合理性的有效描述)
  - [软件需求分析评估](#软件需求分析评估)
    - [软件需求分析评估是为了检查我们进行软件需求分析工作，保证软件需求分析工作正确性、完整性、有效性、合理性、可确认性、可实施性，完全保证用户所需求的功能。](#软件需求分析评估是为了检查我们进行软件需求分析工作保证软件需求分析工作正确性完整性有效性合理性可确认性可实施性完全保证用户所需求的功能)
    - [6.1、组织结构与责任管理](#61组织结构与责任管理)
      - [我们对组织结构与责任管理的评估主要有：参与人员任务和责任界面的明确；安排计划按时完成状况；相互间的协调能力状况。](#我们对组织结构与责任管理的评估主要有参与人员任务和责任界面的明确安排计划按时完成状况相互间的协调能力状况)
    - [6.2、满足用户需求的功能](#62满足用户需求的功能)
      - [我们进行需求分析的目的是完整、准确地描述用户的需求，跟踪用户需求的变化，将用户的需求准确地反映到系统的分析和设计中，并使系统的分析、设计和用户的需求保持一致。](#我们进行需求分析的目的是完整准确地描述用户的需求跟踪用户需求的变化将用户的需求准确地反映到系统的分析和设计中并使系统的分析设计和用户的需求保持一致)
      - [需求分析的特点是需求的完整性、一致性和可追溯性。完整性：是准确、全面的描述用户的需求。一致性：是通过分析整理，剔除用户需求矛盾的方面，规范用户需求。可追溯性：有两个方面的含义，整理和规范的需求，其一，需要不断的和用户进一步交流，保持和用户最新的需求一致。其二，和系统分析（设计）保持一致。](#需求分析的特点是需求的完整性一致性和可追溯性完整性是准确全面的描述用户的需求一致性是通过分析整理剔除用户需求矛盾的方面规范用户需求可追溯性有两个方面的含义整理和规范的需求其一需要不断的和用户进一步交流保持和用户最新的需求一致其二和系统分析设计保持一致)
      - [因此在需求分析之前我们必须建立需求分析技术层面的基本框架，从技术上保证需求分析的要求，在此基础上我们进行的需求分析才能满足项目对需求分析的要求。](#因此在需求分析之前我们必须建立需求分析技术层面的基本框架从技术上保证需求分析的要求在此基础上我们进行的需求分析才能满足项目对需求分析的要求)
    - [6.3、保证可实施性](#63保证可实施性)
      - [我们必须以用户软件需求为依据，以求实的态度详细的、准确的、完整的编写软件需求分析，避免空想世界，空中楼阁的想法；避免无逻辑性、无核心的描述；避免无量化思维，无实际空间概念。](#我们必须以用户软件需求为依据以求实的态度详细的准确的完整的编写软件需求分析避免空想世界空中楼阁的想法避免无逻辑性无核心的描述避免无量化思维无实际空间概念)
    - [6.4、需求分析评价指标](#64需求分析评价指标)
      - [功能性](#功能性)
      - [完整性](#完整性)
      - [正确性](#正确性)
      - [逻辑性](#逻辑性)
      - [表现性](#表现性)
      - [合理性](#合理性)
      - [可实施性等](#可实施性等)
    - [6.5、工作周期](#65工作周期)
      - [评价人员投入，以及费用支出的合理性问题。正确制定工作周期，保证软件项目的顺利完成。](#评价人员投入以及费用支出的合理性问题正确制定工作周期保证软件项目的顺利完成)
    - [6.6、需求不确定更改与可确认保证](#66需求不确定更改与可确认保证)
      - [可确认需求功能是实现用户需求的基本保证，如果不可确认的、不确定更改存在，将会阻碍软件实现，或者软件设计存在着不完整性缺陷，或者存在着不可实施性问题，我们必须区分是功能性障碍问题，还是未来性问题。如果不能够明确是未来性问题，则必须调整功能需求，化解不确定更改的问题。因此，判断不确定性更改是一个非常重要的问题](#可确认需求功能是实现用户需求的基本保证如果不可确认的不确定更改存在将会阻碍软件实现或者软件设计存在着不完整性缺陷或者存在着不可实施性问题我们必须区分是功能性障碍问题还是未来性问题如果不能够明确是未来性问题则必须调整功能需求化解不确定更改的问题因此判断不确定性更改是一个非常重要的问题)
- [数据分析](#数据分析)
  - [数据采集](#数据采集)
    - [数据源](#数据源)
      - [开源数据源](#开源数据源)
      - [日志采集](#日志采集)
      - [爬虫抓取](#爬虫抓取)
      - [传感器](#传感器)
    - [工具使用](#工具使用)
      - [八爪鱼](#八爪鱼)
      - [火车采集器](#火车采集器)
      - [搜集客](#搜集客)
    - [Python爬虫利器](#python爬虫利器)
      - [phantomjs](#phantomjs)
      - [scrapy](#scrapy)
      - [lxml](#lxml)
      - [selenium](#selenium-1)
  - [数据挖掘](#数据挖掘)
    - [数学基础](#数学基础)
      - [概率论与数据统计](#概率论与数据统计)
      - [线性代数](#线性代数)
      - [图论](#图论)
      - [最优化方法](#最优化方法)
    - [基本流程](#基本流程)
      - [商业理解](#商业理解)
      - [数据理解](#数据理解)
      - [数据准备](#数据准备)
      - [模型建立](#模型建立)
      - [模型评估](#模型评估)
      - [上线发布](#上线发布)
    - [十大算法](#十大算法)
      - [分类算法](#分类算法)
      - [聚类算法](#聚类算法)
      - [关联分析](#关联分析)
      - [连接分析](#连接分析)
  - [数据可视化](#数据可视化)
    - [Python可视化](#python可视化)
      - [Matplotlib](#matplotlib)
      - [Seaborn](#seaborn)
    - [第三方工具](#第三方工具)
      - [微图](#微图)
      - [DataV](#datav)
- [软件测试](#软件测试)
  - [系统测试：系统测试是对已经集成好的软件系统进行彻底的测试，](#系统测试系统测试是对已经集成好的软件系统进行彻底的测试)
    - [测试种类](#测试种类)
      - [功能测试：](#功能测试)
      - [功能测试是对产品的各功能进行验证，以检查是否满足需求的要求。](#功能测试是对产品的各功能进行验证以检查是否满足需求的要求)
      - [性能测试：](#性能测试)
      - [性能测试是通过自动化测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。](#性能测试是通过自动化测试工具模拟多种正常峰值以及异常负载条件来对系统的各项性能指标进行测试)
      - [安全测试：](#安全测试)
      - [安全测试检查系统对非法入侵的防范能力。](#安全测试检查系统对非法入侵的防范能力)
      - [兼容测试：](#兼容测试)
      - [兼容性测试主要是测试系统在不同的软硬件环境下是否能够正常的运行。](#兼容性测试主要是测试系统在不同的软硬件环境下是否能够正常的运行)
  - [验收测试：](#验收测试)
    - [验收测试内容](#验收测试内容)
      - [功能确认测试](#功能确认测试)
      - [安全可靠性测试](#安全可靠性测试)
      - [易用性测试](#易用性测试)
      - [可扩充性测试](#可扩充性测试)
      - [兼容性测试](#兼容性测试)
      - [资源占用率测试](#资源占用率测试)
      - [用户文档资料验收](#用户文档资料验收)
  - [集成测试：](#集成测试)
    - [关注内容](#关注内容)
      - [1.        把各个模块连接起来时，穿越模块接口的数据据是否会丢失。](#1--------把各个模块连接起来时穿越模块接口的数据据是否会丢失)
      - [2.        各个了模块组合起来，能否达到预期要求的功能。](#2--------各个了模块组合起来能否达到预期要求的功能)
      - [3.        一个模块的功能是否会对另一个模块的功能产生不利影响。](#3--------一个模块的功能是否会对另一个模块的功能产生不利影响)
      - [4.        全局数据据结构是否有问题。](#4--------全局数据据结构是否有问题)
      - [5.        单个模块的误差积累起来是否会被放大，从而达到不可接受的程序。](#5--------单个模块的误差积累起来是否会被放大从而达到不可接受的程序)
  - [单元测试:](#单元测试)
    - [单元测试的好处](#单元测试的好处)
      - [（1）单元测试帮助设计](#1单元测试帮助设计)
        - [单元测试迫使我们从关注实现转向关注接口，编写单元测试的过程就是设计接口的过程，使单元测试通过的过程是我们编写实现的过程。我一直觉得这是单元测试最重要的好处，让我们关注的重点放在接口上而非实现的细节。](#单元测试迫使我们从关注实现转向关注接口编写单元测试的过程就是设计接口的过程使单元测试通过的过程是我们编写实现的过程我一直觉得这是单元测试最重要的好处让我们关注的重点放在接口上而非实现的细节)
      - [（2）单元测试帮助编码](#2单元测试帮助编码)
        - [应用单元测试会使我们主动消除和减少不必要的耦合，虽然出发点可能是为了更方便的完成单元测试，但结果通常是类型的职责更加内聚，类型间的耦合显著降低。这是已知的提升编码质量的有效手段，也是提升开发人员编码水平的有效手段。](#应用单元测试会使我们主动消除和减少不必要的耦合虽然出发点可能是为了更方便的完成单元测试但结果通常是类型的职责更加内聚类型间的耦合显著降低这是已知的提升编码质量的有效手段也是提升开发人员编码水平的有效手段)
      - [（3）单元测试帮助调试](#3单元测试帮助调试)
        - [应用了单元测试的代码在调试时可以快速定位问题的出处。](#应用了单元测试的代码在调试时可以快速定位问题的出处)
      - [（4）单元测试帮助重构](#4单元测试帮助重构)
        - [对于现有项目的重构，从编写单元测试开始是更好的选择。先从局部代码进行重构，提取接口进行单元测试，然后再进行类型和层次级别的重构。](#对于现有项目的重构从编写单元测试开始是更好的选择先从局部代码进行重构提取接口进行单元测试然后再进行类型和层次级别的重构)
        - [单元测试在设计、编码和调试上的作用足以使其成为软件开发相关人员的必备技能。](#单元测试在设计编码和调试上的作用足以使其成为软件开发相关人员的必备技能)
    - [基本](#基本)
      - [单元测试的好处](#单元测试的好处-1)
        - [（1）单元测试帮助设计](#1单元测试帮助设计-1)
        - [（2）单元测试帮助编码](#2单元测试帮助编码-1)
        - [（3）单元测试帮助调试](#3单元测试帮助调试-1)
        - [（4）单元测试帮助重构](#4单元测试帮助重构-1)
      - [应用单元测试：](#应用单元测试)
        - [（1）测试领域层](#1测试领域层)
        - [（2）测试应用层](#2测试应用层)
        - [（3）测试表示层](#3测试表示层)
        - [（4）测试基础设施层](#4测试基础设施层)
        - [（5）使用单元测试进行集成测试](#5使用单元测试进行集成测试)
      - [3.使用Assert判断逻辑行为正确性](#3使用assert判断逻辑行为正确性)
      - [4.使用伪对象](#4使用伪对象)
        - [（1）使用接口依赖取代原始类型依赖。](#1使用接口依赖取代原始类型依赖)
        - [（2）通过对原始类型的适配实现上述接口。](#2通过对原始类型的适配实现上述接口)
        - [（3）手动创建用于单元测试的接口实现类或在单元测试时使用Mock框架生成接口的实例。](#3手动创建用于单元测试的接口实现类或在单元测试时使用mock框架生成接口的实例)
      - [5.单元测试常用框架和组件](#5单元测试常用框架和组件)
        - [（1）单元测试框架。](#1单元测试框架)
        - [（2）Mock框架](#2mock框架)
        - [（3）邮件发送的Mock组件netDumbster](#3邮件发送的mock组件netdumbster)
        - [（4）HttpContext的Mock组件HttpSimulator](#4httpcontext的mock组件httpsimulator)
      - [6.使用单元测试的难处](#6使用单元测试的难处)
        - [（1）不愿意付出学习成本和改变现有开发习惯。](#1不愿意付出学习成本和改变现有开发习惯)
        - [（2）没有思考的习惯，错误的把单元测试当框架学。](#2没有思考的习惯错误的把单元测试当框架学)
        - [（3）在项目后期才应用单元测试，即获取不到单元测试的好处又因为代码的测试不友好对单元测试产生误解。](#3在项目后期才应用单元测试即获取不到单元测试的好处又因为代码的测试不友好对单元测试产生误解)
        - [（4）拒绝考虑效率、扩展性和解耦，只考虑数据和功能的实现。](#4拒绝考虑效率扩展性和解耦只考虑数据和功能的实现)
    - [分类](#分类)
      - [模块接口测试](#模块接口测试)
        - [通过所测模块的数据流进行测试。调用所测模块时的输入参数与模块的形式参数的个数、属性和顺序是否匹配。](#通过所测模块的数据流进行测试调用所测模块时的输入参数与模块的形式参数的个数属性和顺序是否匹配)
      - [局部数据结构测试](#局部数据结构测试)
        - [局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整、正确、模块的局部数据结构往往是错误的根源。](#局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整正确模块的局部数据结构往往是错误的根源)
      - [路径测试](#路径测试)
        - [对模块中重要的执行路径进行测试。](#对模块中重要的执行路径进行测试)
      - [错误处理测试](#错误处理测试)
        - [比较完善的模块设计要求能遇见出错的条件，并设置适当的出错处理，以便在一旦程序出错时，能对出错程序重做安排，保证其逻辑上的正确性。](#比较完善的模块设计要求能遇见出错的条件并设置适当的出错处理以便在一旦程序出错时能对出错程序重做安排保证其逻辑上的正确性)
      - [边界条件测试](#边界条件测试)
        - [软件经常在便捷上失效，边界条件测试是一项基础测试，也是后面系统测试中的功能测试的重点。](#软件经常在便捷上失效边界条件测试是一项基础测试也是后面系统测试中的功能测试的重点)
  - [其他层面分类](#其他层面分类)
    - [测试工作对软件代码的的可见程度的划分](#测试工作对软件代码的的可见程度的划分)
      - [白盒测试](#白盒测试)
        - [白盒测试，指的是把盒子盖子打开，去研究里面的源代码和程序结果。](#白盒测试指的是把盒子盖子打开去研究里面的源代码和程序结果)
      - [黑盒测试](#黑盒测试)
        - [灰盒测试介于黑盒测试与白盒测试之间。](#灰盒测试介于黑盒测试与白盒测试之间)
      - [灰盒测试](#灰盒测试)
        - [黑盒测试，指的是把被测的软件看作是一个黑盒子，我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。](#黑盒测试指的是把被测的软件看作是一个黑盒子我们不去关心盒子里面的结构是什么样子的只关心软件的输入数据和输出结果)
    - [功能测试、性能测试](#功能测试性能测试)
      - [功能测试](#功能测试-1)
        - [功能测试检查实际的功能是否符合用户的需求。测试的大部分工作也是围绕软件的功能进行，设计软件的目的也就是满足客户对其功能的需求。如果偏离的这个目的任何测试工作都是没有意义的。](#功能测试检查实际的功能是否符合用户的需求测试的大部分工作也是围绕软件的功能进行设计软件的目的也就是满足客户对其功能的需求如果偏离的这个目的任何测试工作都是没有意义的)
      - [性能测试](#性能测试-1)
        - [　性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。](#性能测试是通过自动化的测试工具模拟多种正常峰值以及异常负载条件来对系统的各项性能指标进行测试)
    - [手工测试与自动化测试](#手工测试与自动化测试)
      - [手工测试](#手工测试)
        - [手工测试：](#手工测试-1)
      - [自动化测试](#自动化测试)
        - [自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。](#自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程通常在设计了测试用例并通过评审之后由测试人员根据测试用例中描述的规程一步步执行测试得到实际结果与期望结果的比较在此过程中为了节省人力时间或硬件资源提高测试效率便引入了自动化测试的概念)
        - [优点](#优点)
    - [其他测试](#其他测试)
      - [冒烟测试](#冒烟测试)
        - [是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。](#是指在对一个新版本进行系统大规模的测试之前先验证一下软件的基本功能是否实现是否具备可测性)
      - [回归测试](#回归测试)
        - [回归测试是指修改了旧代码后，重新时行测试以确认修改后没有引入新的错误或导致其他代码产生错误。](#回归测试是指修改了旧代码后重新时行测试以确认修改后没有引入新的错误或导致其他代码产生错误)
      - [随机测试](#随机测试)
        - [是指测试中的所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。](#是指测试中的所有输入数据都是随机生成的其目的是模拟用户的真实操作并发现一些边缘性的错误)
      - [探索性测试](#探索性测试)
        - [探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。](#探索性测试可以说是一种测试思维技术它没有很多实际的测试方法技术和工具但是却是所有测试人员都应该掌握的一种测试思维方式探索性强调测试人员的主观能动性抛弃繁杂的测试计划和测试用例设计过程强调在碰到问题时及时改变测试策略)
      - [安全测试](#安全测试-1)
        - [安全测试是在IT软件产品的生命周期中，特别是产品开发基本完成到发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程。](#安全测试是在it软件产品的生命周期中特别是产品开发基本完成到发布阶段对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程)
- [系统架构](#系统架构)
  - [定义](#定义-2)
    - [说明](#说明-1)
      - [（1）	架构是对系统的抽象，它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象。因此，仅与内部具体实现有关的细节是不属于架构的，即定义强调元素的“外部可见”属性。](#1架构是对系统的抽象它通过描述元素元素的外部可见属性及元素之间的关系来反映这种抽象因此仅与内部具体实现有关的细节是不属于架构的即定义强调元素的外部可见属性)
      - [（2）	架构由多个结构组成，结构是从功能角度来描述元素之间的关系的，具体的结构传达了架构某方面的信息，但是个别结构一般不能代表大型软件架构。](#2架构由多个结构组成结构是从功能角度来描述元素之间的关系的具体的结构传达了架构某方面的信息但是个别结构一般不能代表大型软件架构)
      - [（3）	任何软件都存在架构，但不一定有对该架构的具体表述文档。即架构可以独立于架构的描述而存在。如文档已过时，则该文档不能反映架构。](#3任何软件都存在架构但不一定有对该架构的具体表述文档即架构可以独立于架构的描述而存在如文档已过时则该文档不能反映架构)
      - [（4）	元素及其行为的集合构成架构的内容。体现系统由哪些元素组成，这些元素各有哪些功能（外部可见），以及这些元素间如何连接与互动。即在两个方面进行抽象：在静态方面，关注系统的大粒度（宏观）总体结构（如分层）；在动态方面，关注系统内关键行为的共同特征。](#4元素及其行为的集合构成架构的内容体现系统由哪些元素组成这些元素各有哪些功能外部可见以及这些元素间如何连接与互动即在两个方面进行抽象在静态方面关注系统的大粒度宏观总体结构如分层在动态方面关注系统内关键行为的共同特征)
      - [（5）	架构具有“基础”性：它通常涉及解决各类关键的重复问题的通用方案（复用性），以及系统设计中影响深远（架构敏感）的各项重要决策（一旦贯彻，更改的代价昂贵）。](#5架构具有基础性它通常涉及解决各类关键的重复问题的通用方案复用性以及系统设计中影响深远架构敏感的各项重要决策一旦贯彻更改的代价昂贵)
      - [（6）	架构隐含有“决策”，即架构是由架构设计师根据关键的功能和非功能性需求（质量属性及项目相关的约束）进行设计与决策的结果。不同的架构设计师设计出来的架构是不一样的，为避免架构设计师考虑不周，重大决策应经过评审。特别是架构设计师自身的水平是一种约束，不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路。](#6架构隐含有决策即架构是由架构设计师根据关键的功能和非功能性需求质量属性及项目相关的约束进行设计与决策的结果不同的架构设计师设计出来的架构是不一样的为避免架构设计师考虑不周重大决策应经过评审特别是架构设计师自身的水平是一种约束不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路)
    - [影响因素](#影响因素-1)
      - [（1）	影响架构的因素。](#1影响架构的因素)
      - [（2）	架构对上述诸因素具有反作用，](#2架构对上述诸因素具有反作用)
  - [模型](#模型-1)
    - [结构模型](#结构模型-1)
    - [框架模型](#框架模型-1)
    - [动态模型](#动态模型-1)
    - [过程模型](#过程模型-1)
    - [功能模型](#功能模型-1)
  - [4+1视图](#41视图-1)
    - [逻辑视图](#逻辑视图-1)
    - [子主题6](#子主题6-1)
    - [进程视图](#进程视图-1)
    - [物理视图](#物理视图-1)
    - [场景视图](#场景视图-1)
  - [开发质量属性](#开发质量属性-1)
    - [运行期](#运行期-1)
      - [性能](#性能-1)
      - [安全](#安全-1)
      - [易用](#易用-1)
      - [可伸缩](#可伸缩-1)
      - [互操作](#互操作-1)
      - [可靠](#可靠-1)
      - [持续可用](#持续可用-1)
      - [鲁棒](#鲁棒-1)
    - [开发期](#开发期-1)
      - [易理解性](#易理解性-1)
      - [可扩展性](#可扩展性-1)
      - [可重用性](#可重用性-1)
      - [可测试性](#可测试性-1)
      - [可维护性](#可维护性-1)
      - [可移植性](#可移植性-1)
  - [企业架构成熟度模型（EAMM）](#企业架构成熟度模型eamm)
    - [EAMM从以下几个方面来对不同级别进行描述:](#eamm从以下几个方面来对不同级别进行描述)
      - [Administration – 治理角色与职责](#administration--治理角色与职责)
      - [Planning – 企业架构开发路标以及实现计划](#planning--企业架构开发路标以及实现计划)
      - [Framework – 流程和模板](#framework--流程和模板)
      - [Blueprint – 实际的标准和规范集合](#blueprint--实际的标准和规范集合)
      - [Communication – 交流与发布EA和详细蓝图](#communication--交流与发布ea和详细蓝图)
      - [Compliance（一致性） – 遵循发布的标准、流程和其它EA元素，文档化流程并且能够跟踪变化](#compliance一致性--遵循发布的标准流程和其它ea元素文档化流程并且能够跟踪变化)
      - [Integration – touch-points of management processes to the EA](#integration--touch-points-of-management-processes-to-the-ea)
      - [Involvement – 整个组织对EA的支持](#involvement--整个组织对ea的支持)
    - [分级](#分级)
      - [EA LEVEL 0 - NO PROGRAM](#ea-level-0---no-program)
        - [没有文档化的架构框架，虽然解决方案已经开发并实现了，但是并没有公认的标准和最佳实践的指导，组织完全依赖于独立个人贡献者的知识。](#没有文档化的架构框架虽然解决方案已经开发并实现了但是并没有公认的标准和最佳实践的指导组织完全依赖于独立个人贡献者的知识)
        - [Administration](#administration)
        - [Planning](#planning)
        - [Framework](#framework)
        - [Blueprint](#blueprint)
        - [Communication](#communication)
        - [Compliance](#compliance)
        - [Integration](#integration)
        - [Involvement](#involvement)
      - [EA LEVEL 1 - INFORMAL PROGRAM](#ea-level-1---informal-program)
        - [定义了基本的企业架构和标准。大家对这些步骤达成基本一致，但是并不一定会遵守并执行，基本上是在非正式的情况下使用。这个状态下组织仍旧依赖于独立个人贡献者的知识。](#定义了基本的企业架构和标准大家对这些步骤达成基本一致但是并不一定会遵守并执行基本上是在非正式的情况下使用这个状态下组织仍旧依赖于独立个人贡献者的知识)
        - [Administration](#administration-1)
        - [Planning](#planning-1)
        - [Framework](#framework-1)
        - [Blueprint](#blueprint-1)
        - [Communication](#communication-1)
        - [Compliance](#compliance-1)
        - [Integration](#integration-1)
        - [Involvement](#involvement-1)
      - [EA LEVEL 2 - REPEATABLE PROGRAM](#ea-level-2---repeatable-program)
        - [基本架构和标准已经制定并跟踪验证，开发时作为可重用方法，产品和组件遵守标准，需求得到一致认同，对流程绩效也进行了度量。](#基本架构和标准已经制定并跟踪验证开发时作为可重用方法产品和组件遵守标准需求得到一致认同对流程绩效也进行了度量)
        - [Administration](#administration-2)
        - [Planning](#planning-2)
        - [Framework](#framework-2)
        - [Blueprint](#blueprint-2)
        - [Communication](#communication-2)
        - [Compliance](#compliance-2)
        - [Integration](#integration-2)
        - [Involvement](#involvement-2)
  - [软件分层](#软件分层)
    - [分层原则](#分层原则)
      - [1.每一层都应该都是由类或组件组成。](#1每一层都应该都是由类或组件组成)
      - [2.只存在上层对下层的依赖，下层不依赖于上层。](#2只存在上层对下层的依赖下层不依赖于上层)
      - [3.上层调用下层的api，下层实现细节的变动不会影响到上层的代码。](#3上层调用下层的api下层实现细节的变动不会影响到上层的代码)
    - [框架模型](#框架模型-2)
      - [1.可伸缩性：可以把每一层分布在不同机器上，实现分布式应用。](#1可伸缩性可以把每一层分布在不同机器上实现分布式应用)
      - [2.可维护性：如果需求变动，只要相应调整某一层的实现即可。](#2可维护性如果需求变动只要相应调整某一层的实现即可)
      - [3.可管理性：分层有利用分工。](#3可管理性分层有利用分工)
      - [4.可扩展性：增加功能只需要在相应层上调整即可。](#4可扩展性增加功能只需要在相应层上调整即可)
      - [5.可重要性：业务逻辑模块则可供系统的多个模块公共。](#5可重要性业务逻辑模块则可供系统的多个模块公共)
  - [微服务](#微服务)
  - [consul](#consul)
- [敏捷开发](#敏捷开发)
  - [敏捷软件开发宣言](#敏捷软件开发宣言)
    - [个人与交互 高于 流程和工具](#个人与交互-高于-流程和工具)
    - [可用软件 高于 详尽的文档](#可用软件-高于-详尽的文档)
    - [客户合作 高于 合同谈判](#客户合作-高于-合同谈判)
    - [响应变化 高于 遵循计划](#响应变化-高于-遵循计划)
  - [敏捷宣言的十二条原则](#敏捷宣言的十二条原则)
    - [我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。](#我们最重要的目标是通过持续不断地及早交付有价值的软件使客户满意)
    - [欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。](#欣然面对需求变化即使在开发后期也一样为了客户的竞争优势敏捷过程掌控变化)
    - [经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。](#经常地交付可工作的软件相隔几星期或一两个月倾向于采取较短的周期)
    - [业务人员和开发人员必须相互合作，项目中的每一天都不例外。](#业务人员和开发人员必须相互合作项目中的每一天都不例外)
    - [激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。](#激发个体的斗志以他们为核心搭建项目提供所需的环境和支援辅以信任从而达成目标)
    - [不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。](#不论团队内外传递信息效果最好效率也最高的方式是面对面的交谈)
    - [可工作的软件是进度的首要度量标准。](#可工作的软件是进度的首要度量标准)
    - [敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。](#敏捷过程倡导可持续开发责任人开发人员和用户要能够共同维持其步调稳定延续)
    - [坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。](#坚持不懈地追求技术卓越和良好设计敏捷能力由此增强)
    - [以简洁为本，它是极力减少不必要工作量的艺术。](#以简洁为本它是极力减少不必要工作量的艺术)
    - [最好的架构、需求和设计出自自组织团队。](#最好的架构需求和设计出自自组织团队)
    - [团队定期地反思如何能提高成效，并依此调整自身的举止表现。](#团队定期地反思如何能提高成效并依此调整自身的举止表现)
  - [应该着重注意的点](#应该着重注意的点)
    - [需求在开发中的重要性](#需求在开发中的重要性)
      - [大量的开发过程告诉我，需求在软件开发过程中是极其重要的。传统的开发强调初期的需求调研及需要分析，这个过程对于一些正规的团队会产生大量的文档，而后交由开发展开产品生产。](#大量的开发过程告诉我需求在软件开发过程中是极其重要的传统的开发强调初期的需求调研及需要分析这个过程对于一些正规的团队会产生大量的文档而后交由开发展开产品生产)
      - [然而，事实却不是想象这么简单，无数的例子说明了一点，仅仅在需求调研过程中了解到的需求是无法保证的。数不清的例子告诉我们，需求是会变的，变的原因很多。在极端的情况下，有些客户签字的需求在开发完后，有需要变更也很正常。](#然而事实却不是想象这么简单无数的例子说明了一点仅仅在需求调研过程中了解到的需求是无法保证的数不清的例子告诉我们需求是会变的变的原因很多在极端的情况下有些客户签字的需求在开发完后有需要变更也很正常)
      - [所以需求是影响软件开发的第一重要因素，需求来源于业务，我们开发的产品不就是因为这些业务才去做的吗？如何需求都无法把握好，还谈什么开发出好用的产品？](#所以需求是影响软件开发的第一重要因素需求来源于业务我们开发的产品不就是因为这些业务才去做的吗如何需求都无法把握好还谈什么开发出好用的产品)
      - [然而如何做好需求呢？我想首先要确立需求的地位，然后只有通过不断的沟通、尝试、反馈向真实需求迈进。](#然而如何做好需求呢我想首先要确立需求的地位然后只有通过不断的沟通尝试反馈向真实需求迈进)
    - [强调人与人的交流](#强调人与人的交流)
      - [不管怎么样开发过程中主要还是靠人的，而且软件开发是个复杂的团体工程，一个小些的产品也会涉及到各类人：客户、业务分析、管理人员、程序员、测试员等等。这么多人在一起做事情，有一方没有处理好结果肯定就会有问题。](#不管怎么样开发过程中主要还是靠人的而且软件开发是个复杂的团体工程一个小些的产品也会涉及到各类人客户业务分析管理人员程序员测试员等等这么多人在一起做事情有一方没有处理好结果肯定就会有问题)
      - [有这样一个例子：客户提出了一个会员管理功能需求，需求人员了解后组织了解决方案，于是交付了开发实现。而经过二个月无尽的黑夜之后交付，需求一看有个模块做的有偏差，但是已经来不及修改了。交给客户看后，发现这不是他们要的会员管理功能相差较大，另外在功能开发的这一段时间，客户又有了新想法，要对原先需求做调整。](#有这样一个例子客户提出了一个会员管理功能需求需求人员了解后组织了解决方案于是交付了开发实现而经过二个月无尽的黑夜之后交付需求一看有个模块做的有偏差但是已经来不及修改了交给客户看后发现这不是他们要的会员管理功能相差较大另外在功能开发的这一段时间客户又有了新想法要对原先需求做调整)
      - [这种例子可能大家经常经历吧？](#这种例子可能大家经常经历吧)
      - [这种问题在敏捷开发方法中提出了解决方法，就是通过不断的交付可用的制品。看起来很抽象，其实很简单。同样是上面的例子：](#这种问题在敏捷开发方法中提出了解决方法就是通过不断的交付可用的制品看起来很抽象其实很简单同样是上面的例子)
      - [Ø 客户提出会员管理功能需求](#ø-客户提出会员管理功能需求)
      - [Ø 需求人员在了解需求后与开发负责人商量，确定一个快迭代的开发计划，每二周向客户演示一次，并将这个计划与客户确认](#ø-需求人员在了解需求后与开发负责人商量确定一个快迭代的开发计划每二周向客户演示一次并将这个计划与客户确认)
      - [Ø 确认后需求人员向全体成员讲解需求背景故事](#ø-确认后需求人员向全体成员讲解需求背景故事)
      - [Ø 开发负责人组织并确定迭代计划内容，明确每个迭代提交的产品目标、开发任务安排、测试跟踪计划](#ø-开发负责人组织并确定迭代计划内容明确每个迭代提交的产品目标开发任务安排测试跟踪计划)
      - [Ø 每个迭代过程中都由需求及测试进行确认每个任务的实现结果是否跑偏](#ø-每个迭代过程中都由需求及测试进行确认每个任务的实现结果是否跑偏)
      - [Ø 后面就是每二周向客户演示一次产品，并获得客户的反馈](#ø-后面就是每二周向客户演示一次产品并获得客户的反馈)
      - [Ø 根据客户的反馈调整下个迭代计划，并继续下一个迭代](#ø-根据客户的反馈调整下个迭代计划并继续下一个迭代)
      - [Ø 直到产品交付](#ø-直到产品交付)
      - [通过上面的步骤，就不至于在开发完成后才知道用户的真实想法，因为很多用户对软件开发是没有概念的，他只知道自己有某种需求，但最开始是没有一个完整的概念的。所以就要通过不断的让用户看到产品的模型，这个过程用户才会逐步的对产品产生概念。同样的在过程中客户的提出需求变更也是在一定的可控制范围之内，这样一来可以大大的减少软件返工的情况，自然就不会拖延计划了。](#通过上面的步骤就不至于在开发完成后才知道用户的真实想法因为很多用户对软件开发是没有概念的他只知道自己有某种需求但最开始是没有一个完整的概念的所以就要通过不断的让用户看到产品的模型这个过程用户才会逐步的对产品产生概念同样的在过程中客户的提出需求变更也是在一定的可控制范围之内这样一来可以大大的减少软件返工的情况自然就不会拖延计划了)
      - [而这个过程中，需求已经完成了一个真正的过渡，不再是一头重的情况了。他让需求从客户那快速的反馈到开发团队中。同样的，在开发不断的交付制品时，需求也更加及时的了解到产品的进度，把握开发人员开发的功能是否符合需求。](#而这个过程中需求已经完成了一个真正的过渡不再是一头重的情况了他让需求从客户那快速的反馈到开发团队中同样的在开发不断的交付制品时需求也更加及时的了解到产品的进度把握开发人员开发的功能是否符合需求)
      - [当然这并不是一个标准做法，不同的团队可以有不同的处理方式。这里只是想强调需求需要更多的投入到开发过程中去，及时的与客户沟通交流，了解到客户的真实想法。](#当然这并不是一个标准做法不同的团队可以有不同的处理方式这里只是想强调需求需要更多的投入到开发过程中去及时的与客户沟通交流了解到客户的真实想法)
    - [强调文档的作用](#强调文档的作用)
      - [我觉得很多对敏捷开发的一个误解就是不需要文档，敏捷开发并未抛弃文档。只是更强调更有效的方式使用文档。在很多传统开发方法中，特别是很多很正规的开发团队对文档的要求非常苛刻。然而事实是文档不易管理，最痛苦的是不好维护，文档需要随着变化而变化，比如需求调整、技术架构升级、产品维护等等。如果要保证文档的一致性，太难了。特别是对于一些无法进行有效管理的开发团队就更加明显，经常是软件已经几个版本了，文档却是两年前的。](#我觉得很多对敏捷开发的一个误解就是不需要文档敏捷开发并未抛弃文档只是更强调更有效的方式使用文档在很多传统开发方法中特别是很多很正规的开发团队对文档的要求非常苛刻然而事实是文档不易管理最痛苦的是不好维护文档需要随着变化而变化比如需求调整技术架构升级产品维护等等如果要保证文档的一致性太难了特别是对于一些无法进行有效管理的开发团队就更加明显经常是软件已经几个版本了文档却是两年前的)
      - [但敏捷真的不需要文档吗？我想不是的，如何把文档做到好维护我想才是最重要的。文档到底指的指的什么？什么样的算文档？](#但敏捷真的不需要文档吗我想不是的如何把文档做到好维护我想才是最重要的文档到底指的指的什么什么样的算文档)
      - [提出上面两个问题，我们先想想经常说的文档的作用是什么？不就是一个传播工具吗？可以用作记录、给他人看、用于以后查看。有很多方法可就解决了这个问题，比如wiki系统。维护一个wiki系统，可以随时写，随时维护，可以方便的查找。嗯，多方便。](#提出上面两个问题我们先想想经常说的文档的作用是什么不就是一个传播工具吗可以用作记录给他人看用于以后查看有很多方法可就解决了这个问题比如wiki系统维护一个wiki系统可以随时写随时维护可以方便的查找嗯多方便)
      - [另外一个问题就是什么样的工作需要形成文档呢？](#另外一个问题就是什么样的工作需要形成文档呢)
      - [记得在前一家公司，维护一个10多年的老系统修改一个公式计算的BUG，但是怎么也不知道这个复杂的公式是什么意思，问过了公司大部分的人也无人可解。这时想，如果当初有那么一份文档，谢天谢地。](#记得在前一家公司维护一个10多年的老系统修改一个公式计算的bug但是怎么也不知道这个复杂的公式是什么意思问过了公司大部分的人也无人可解这时想如果当初有那么一份文档谢天谢地)
      - [像这种关键的内容有份文档还是很重要的，否则随着时间推移，谁也不能保证能记得住当时为什么会这么干。](#像这种关键的内容有份文档还是很重要的否则随着时间推移谁也不能保证能记得住当时为什么会这么干)
      - [记得多年前一次记笔记的经历，我看了一篇文章了解了DELPHI实现单实例模式的方法，这种方法很酷。于是整理成了笔记写在了wiki上，第二天就得到了回复，帮助到了别外产品开发组的同事。](#记得多年前一次记笔记的经历我看了一篇文章了解了delphi实现单实例模式的方法这种方法很酷于是整理成了笔记写在了wiki上第二天就得到了回复帮助到了别外产品开发组的同事)
      - [嗯，文档就是这样他具有传播性，你不可能跑去跟所有人说出你的想法，但是文档却更容易达成。他也有传承性，有些文档也许10多年后又起了重要作用。](#嗯文档就是这样他具有传播性你不可能跑去跟所有人说出你的想法但是文档却更容易达成他也有传承性有些文档也许10多年后又起了重要作用)
    - [团队协作](#团队协作)
      - [1、减少对开发人员的干扰](#1减少对开发人员的干扰)
      - [曾经接手一个产品的开发，最初遇到一个很头痛的问题，原先写好的迭代计划，而且工作量也较大，大家都在忙着。即便在这样的状态下，客服人员却经常跑来找某个程序员A维护各种系统问题，程序员A在一次维护中竟然导致了系统数据出现大面积错误。程序员A心理上承受着巨大的压力，而每天的这些问题又不得不解决，加之新版本又有很重的开发任务无法完成，最终导致整个开发计划变更。](#曾经接手一个产品的开发最初遇到一个很头痛的问题原先写好的迭代计划而且工作量也较大大家都在忙着即便在这样的状态下客服人员却经常跑来找某个程序员a维护各种系统问题程序员a在一次维护中竟然导致了系统数据出现大面积错误程序员a心理上承受着巨大的压力而每天的这些问题又不得不解决加之新版本又有很重的开发任务无法完成最终导致整个开发计划变更)
      - [我无法再忍受，找到了需求及客服的负责人，沟通后发现这些问题很多都是重复性的，主要是因为原先系统的不足。于是回去组织人员做了几个后台临时功能，并交付给了客服人员，之后就没有再来找过这位程序员A。后续我又找到了客服负责人，要求不能直接找开发人员解决这类问题，并与负责人约定了处理过程。](#我无法再忍受找到了需求及客服的负责人沟通后发现这些问题很多都是重复性的主要是因为原先系统的不足于是回去组织人员做了几个后台临时功能并交付给了客服人员之后就没有再来找过这位程序员a后续我又找到了客服负责人要求不能直接找开发人员解决这类问题并与负责人约定了处理过程)
      - [这是个例子，在实际情况中还有很多这种事情，甚至有很多开发人员要直接面对客户。我想对于职能型团队来说，开发团队最好是减少这些方面的干忧。当然对于一个人包干的情况就不讨论了。](#这是个例子在实际情况中还有很多这种事情甚至有很多开发人员要直接面对客户我想对于职能型团队来说开发团队最好是减少这些方面的干忧当然对于一个人包干的情况就不讨论了)
      - [大部分的人都不是超人，在一个时间段内处理超出自己负荷的工作是很难做好保质保量的。所以对于开发管理人员一定要考虑到这点，尽量让开发人员有比较好的工作进度环境，通过外界的方式来解决一些开发团队的干扰。](#大部分的人都不是超人在一个时间段内处理超出自己负荷的工作是很难做好保质保量的所以对于开发管理人员一定要考虑到这点尽量让开发人员有比较好的工作进度环境通过外界的方式来解决一些开发团队的干扰)
      - [我接触过的很多程序员都很反感这种干扰，虽然有些人在这种全面的工作强度下成长很快，但是并非所有人都适应，长期下来会有怨恨和不快，工作效率会下降。心情舒畅还是很重要的，记得有一次迭代总结时，有个程序员总结说：发现心情舒畅自己的工作效率很高。呵呵。我想你也有同感吧。](#我接触过的很多程序员都很反感这种干扰虽然有些人在这种全面的工作强度下成长很快但是并非所有人都适应长期下来会有怨恨和不快工作效率会下降心情舒畅还是很重要的记得有一次迭代总结时有个程序员总结说发现心情舒畅自己的工作效率很高呵呵我想你也有同感吧)
      - [2、不要忽略测试人员在开发阶段的作用](#2不要忽略测试人员在开发阶段的作用)
      - [曾经多少次在项目发布前加班到深夜2点的情景还历历在目，那种感觉即快乐又痛苦。由于和客户签定的合同的交付日期就要到了，产品却迟迟未集成完成，测试只能干等着上网聊QQ。就在下班前的一刻发布了，测试开始了紧张的测试，在屏幕闪动中，一个个的BUG提交，直到流程都无法都走不下去，测试无奈了。第二天就要发布，实施人员就等着制品第二天出差。只有不断的改，再发布，无尽的循环。直到大家都憔悴的看着老大，终于老大说：还剩下的这几个问题无关紧要，大家回去吧。](#曾经多少次在项目发布前加班到深夜2点的情景还历历在目那种感觉即快乐又痛苦由于和客户签定的合同的交付日期就要到了产品却迟迟未集成完成测试只能干等着上网聊qq就在下班前的一刻发布了测试开始了紧张的测试在屏幕闪动中一个个的bug提交直到流程都无法都走不下去测试无奈了第二天就要发布实施人员就等着制品第二天出差只有不断的改再发布无尽的循环直到大家都憔悴的看着老大终于老大说还剩下的这几个问题无关紧要大家回去吧)
      - [几个月的开发过去后在总结会上，只能抱怨测试资源不足，时间太短，需求更改太多，需求更改后测试不知道。无数的问题一次一次的出现在同样的总结会议上。](#几个月的开发过去后在总结会上只能抱怨测试资源不足时间太短需求更改太多需求更改后测试不知道无数的问题一次一次的出现在同样的总结会议上)
      - [上面的这个例子很多人应该经历过，真的测试只有最后一刻才能体现价值吗？我想不是的。](#上面的这个例子很多人应该经历过真的测试只有最后一刻才能体现价值吗我想不是的)
      - [在后面的项目中我总结了这个问题的，针对每个开发任务要求进行测试验证。而测试如何验证呢？他需要知道这个开发任务的需求是如何，提前做好测试计划及测试用例，在接到开发制品后测试并提交BUG，这个工作是可以开发过程中就能不断的进行的。保证每一个任务的质量，可以大大减少后期集成的错误量。](#在后面的项目中我总结了这个问题的针对每个开发任务要求进行测试验证而测试如何验证呢他需要知道这个开发任务的需求是如何提前做好测试计划及测试用例在接到开发制品后测试并提交bug这个工作是可以开发过程中就能不断的进行的保证每一个任务的质量可以大大减少后期集成的错误量)
      - [另外根据敏捷开发的思想，测试团队在开发过程中也需要加强与开发团队的交流，甚至有必要组成虚拟团队，位置调整到一起，这样可以及时快速的交流，参加开发团队的站立会议同样可以及时了解到开发的实际情况及进度，反过来把握测试计划及测试内容。](#另外根据敏捷开发的思想测试团队在开发过程中也需要加强与开发团队的交流甚至有必要组成虚拟团队位置调整到一起这样可以及时快速的交流参加开发团队的站立会议同样可以及时了解到开发的实际情况及进度反过来把握测试计划及测试内容)
      - [特别是测试从另一个角度来审视需求，这样也可以一定程度上发现或者改善需求上的不足。](#特别是测试从另一个角度来审视需求这样也可以一定程度上发现或者改善需求上的不足)
      - [3、发挥团队人员的潜力](#3发挥团队人员的潜力)
      - [敏捷开发比较提倡开发任务由开发自己评估并认领工作任务，这样可以激发开发的潜在动力。](#敏捷开发比较提倡开发任务由开发自己评估并认领工作任务这样可以激发开发的潜在动力)
      - [之前在做一个新产品时，需要使用java，而我们团队是使用C#的，面临转型问题。而有一位同事很感兴趣，于是我就让他负责前期的框架探索与搭建。结果就是这位小伙工作效率很高，我最初给他的目标全部都完成了。最有意思的是后面产品开始研发时，这位小伙已经成为了团队的大牛，大家有问题都找他解决。也正是因为这个过程，这位小伙被全面激活，也在大家面前展示了能力。甚至在小伙离职时也被领导给予大幅涨薪来挽留。只不过谁又能想象到这位小伙进入我团队之前是因为被定为裁员的目标而调剂过来的呢!](#之前在做一个新产品时需要使用java而我们团队是使用c的面临转型问题而有一位同事很感兴趣于是我就让他负责前期的框架探索与搭建结果就是这位小伙工作效率很高我最初给他的目标全部都完成了最有意思的是后面产品开始研发时这位小伙已经成为了团队的大牛大家有问题都找他解决也正是因为这个过程这位小伙被全面激活也在大家面前展示了能力甚至在小伙离职时也被领导给予大幅涨薪来挽留只不过谁又能想象到这位小伙进入我团队之前是因为被定为裁员的目标而调剂过来的呢)
      - [所以充分发挥好每个人员的特点，让人能够在自己感兴趣的工作中，效果会很多。减少指派方式的任务的分配，充分发挥个人的主动性，这个团队精神面貌也会好很多。](#所以充分发挥好每个人员的特点让人能够在自己感兴趣的工作中效果会很多减少指派方式的任务的分配充分发挥个人的主动性这个团队精神面貌也会好很多)
      - [4、管理者不要离团队太远](#4管理者不要离团队太远)
      - [作为团队的Leader要参与到团队的工作中去，比如一个开发主管一定要写写代码，参与架构等对项目有关的事情，而不是在那里分分任务。这样团队成员才会觉得这个Leader很亲近感。](#作为团队的leader要参与到团队的工作中去比如一个开发主管一定要写写代码参与架构等对项目有关的事情而不是在那里分分任务这样团队成员才会觉得这个leader很亲近感)
      - [特别是有些开发主管在带队后离团队越来越远，有时对于开发进度不如意时就说：“这么个简单功能怎么会搞了这么久？”，其实每天都在加班的同事心里想着：“有本事你来？”，即使这个小组长有这个能力，但对于团队来说也不是一件好事，因为大家都抱有怨恨之心，还谈什么好好工作呢？这个小组长就是失职的。所以这种情况下应该主动去了解进度滞后的原因，并且自己要加入到解决问题的工作中去，而不是在边上抱怨别人。](#特别是有些开发主管在带队后离团队越来越远有时对于开发进度不如意时就说这么个简单功能怎么会搞了这么久其实每天都在加班的同事心里想着有本事你来即使这个小组长有这个能力但对于团队来说也不是一件好事因为大家都抱有怨恨之心还谈什么好好工作呢这个小组长就是失职的所以这种情况下应该主动去了解进度滞后的原因并且自己要加入到解决问题的工作中去而不是在边上抱怨别人)
      - [5、小组织不要搞太多的官](#5小组织不要搞太多的官)
      - [中国几千年的文化，官本位一直影响着我们，大家都想坐在那指挥，自己啥事也不用干，想想都惬意。在我们这个行业是不是发现也很类似？大家都想着干几年当个小组长，然后升个部门经理，当上CTO迎娶白富美。](#中国几千年的文化官本位一直影响着我们大家都想坐在那指挥自己啥事也不用干想想都惬意在我们这个行业是不是发现也很类似大家都想着干几年当个小组长然后升个部门经理当上cto迎娶白富美)
      - [团队的管理基本是事与人的管理，非常的伤脑和心。如果一个组织内，特别是小组织内“官”太多，协调就会非常的难，大家就会经常性的扯皮。](#团队的管理基本是事与人的管理非常的伤脑和心如果一个组织内特别是小组织内官太多协调就会非常的难大家就会经常性的扯皮)
      - [结束](#结束)
  - [敏捷开发的推理](#敏捷开发的推理)
    - [符合现实的软件](#符合现实的软件)
    - [软件是为着解决现实的问题而产生的。从而软件存在的意义就是与现实相适应。敏捷开发的核心即：符合现实的软件。一个符合现实的软件，才能够可持续地与现实共同发展。一旦软件与现实背离，软件的生命周期也就到了结束的时候了。](#软件是为着解决现实的问题而产生的从而软件存在的意义就是与现实相适应敏捷开发的核心即符合现实的软件一个符合现实的软件才能够可持续地与现实共同发展一旦软件与现实背离软件的生命周期也就到了结束的时候了)
    - [现实的世界是动态变化的，人类造出来的东西，往往是落后于世界的变化的。如，地图造出来之后，可能又多修了几条路，几个建筑；刚买了一款高配置的计算机，几个月后，自己的机器配置又处于被甩的地位了……这些变化，人是被迫要去接受。因为这些东西属于硬件，人在目前还无法轻易地改变硬件。](#现实的世界是动态变化的人类造出来的东西往往是落后于世界的变化的如地图造出来之后可能又多修了几条路几个建筑刚买了一款高配置的计算机几个月后自己的机器配置又处于被甩的地位了这些变化人是被迫要去接受因为这些东西属于硬件人在目前还无法轻易地改变硬件)
    - [而与此不同的软件，则是另外一种现象了。改变软件的代价是相当低廉的。改变软件，实际上只是改变硬盘上的磁性。改变软件的容易性，带来的结果是： 一、软件开发者容易以自己的想象来决定软件怎么做。 开发出一个无用的软件，比起因为出错而要毁掉待出售的10万张地图，比起因为工艺漏洞而要招回已经出售的计算机来讲，代价太低廉了。 二、软件更加具备符合现实的条件。 开发者让软件与现实相适应，所要付出的代价非常低廉。](#而与此不同的软件则是另外一种现象了改变软件的代价是相当低廉的改变软件实际上只是改变硬盘上的磁性改变软件的容易性带来的结果是-一软件开发者容易以自己的想象来决定软件怎么做-开发出一个无用的软件比起因为出错而要毁掉待出售的10万张地图比起因为工艺漏洞而要招回已经出售的计算机来讲代价太低廉了-二软件更加具备符合现实的条件-开发者让软件与现实相适应所要付出的代价非常低廉)
    - [所以，敏捷开发的核心就是符合现实的软件。为了造出符合现实的软件，才有了进一步的价值观及方法论。](#所以敏捷开发的核心就是符合现实的软件为了造出符合现实的软件才有了进一步的价值观及方法论)
    - [简单](#简单)
    - [简单，是在人认识到事物的本质的时候才能够获得的。在开发软件的时候，我们往往疲于应付各种各样的需求。很少有人能够将复杂的需求化为简单的概念。比如，做一个音乐软件，有“我喜欢的”、“最近播放”、“最新添加”等不同的性质的歌。有些开发者会做出三个列表来存放三种性质的歌。而实际上他们的本质是一样的，即播放列表。区别在于触发加入播放列表的条件不同而已。因而只需要做一个列表，在列表中标记每首歌的触发条件。](#简单是在人认识到事物的本质的时候才能够获得的在开发软件的时候我们往往疲于应付各种各样的需求很少有人能够将复杂的需求化为简单的概念比如做一个音乐软件有我喜欢的最近播放最新添加等不同的性质的歌有些开发者会做出三个列表来存放三种性质的歌而实际上他们的本质是一样的即播放列表区别在于触发加入播放列表的条件不同而已因而只需要做一个列表在列表中标记每首歌的触发条件)
    - [把软件做得很复杂，通常说明软件所抓住的本质还很少。需要再好好考虑一下如何进一步进行简化。软件的概念简单，一方面可以让用户很容易理解和操作；另一方面能够适应世界的变化。再拿以上的音乐软件来说。如何做成三个列表，再要加一个“听了又听”的歌，又得创建一个列表。而使用一个列表的方法，则只需要处理“听了又听”这个触发条件。](#把软件做得很复杂通常说明软件所抓住的本质还很少需要再好好考虑一下如何进一步进行简化软件的概念简单一方面可以让用户很容易理解和操作另一方面能够适应世界的变化再拿以上的音乐软件来说如何做成三个列表再要加一个听了又听的歌又得创建一个列表而使用一个列表的方法则只需要处理听了又听这个触发条件)
    - [符合现实的软件必然是简单的。所以，敏捷开发的第一条价值观是：简单。我们在实施敏捷开发的时候，都是围绕“简单”这一价值观而进行实施的。即，时刻保证软件的简单性。简单性包括两个方面：一是对于用户而言，概念很简单；二是对于开发者而言，开发的技术及代码很简单。](#符合现实的软件必然是简单的所以敏捷开发的第一条价值观是简单我们在实施敏捷开发的时候都是围绕简单这一价值观而进行实施的即时刻保证软件的简单性简单性包括两个方面一是对于用户而言概念很简单二是对于开发者而言开发的技术及代码很简单)
    - [软件的可持续性也取决于软件是否简单。可持续性是指，快速响应现实的变化。一个复杂的软件，要么让用户无所适从，要么让代码无法维护。这都将导致软件无法持续。这会迫使我们以制造硬件的方式来开发软件。硬件是在迫不得已的情况下才丢掉重新升级（计算机在实在没有办法用的时候，才买新的），要让软件也这样做，软件开发低廉代价的优势就白白浪费掉了。](#软件的可持续性也取决于软件是否简单可持续性是指快速响应现实的变化一个复杂的软件要么让用户无所适从要么让代码无法维护这都将导致软件无法持续这会迫使我们以制造硬件的方式来开发软件硬件是在迫不得已的情况下才丢掉重新升级计算机在实在没有办法用的时候才买新的要让软件也这样做软件开发低廉代价的优势就白白浪费掉了)
    - [反馈](#反馈)
    - [一个软件要符合现实，就需要通过现实的反馈来发展。软件前进的动力是现实的反馈。敏捷开发是欢迎现实，拥抱变化的开发。强调该条价值观，是为了消除开发者容易犯的错误——以自己的想象去决定软件怎么做。](#一个软件要符合现实就需要通过现实的反馈来发展软件前进的动力是现实的反馈敏捷开发是欢迎现实拥抱变化的开发强调该条价值观是为了消除开发者容易犯的错误以自己的想象去决定软件怎么做)
    - [因而，在做一个软件之前，首先要找到能够给出反馈的人。如果连能够给出反馈的人都没有，那么这个软件就没有做的必要了。](#因而在做一个软件之前首先要找到能够给出反馈的人如果连能够给出反馈的人都没有那么这个软件就没有做的必要了)
    - [反馈的重要性，更可以这样说：矛盾推动事物的发展。反馈是指出不足的矛，软件是弥补不足的盾。在矛的不断攻击之下，盾才能不断完善。矛之不存，盾何以壮。](#反馈的重要性更可以这样说矛盾推动事物的发展反馈是指出不足的矛软件是弥补不足的盾在矛的不断攻击之下盾才能不断完善矛之不存盾何以壮)
    - [在方法论上面，敏捷开发强调快速发布版本，取得现实的反馈而不是开发者大脑中自己想像的反馈。如果开发者正好也是使用者，那么软件做成的几率就要大很多。开源软件大多数都是开发者自己要解决问题而产生的。](#在方法论上面敏捷开发强调快速发布版本取得现实的反馈而不是开发者大脑中自己想像的反馈如果开发者正好也是使用者那么软件做成的几率就要大很多开源软件大多数都是开发者自己要解决问题而产生的)
    - [沟通](#沟通)
    - [沟通是开发者取得反馈的手段。一个优秀的开发者，是善于沟通的。沟通包含口语、写文档等各种方式。优秀的开发者应该能够清晰而有条理地表达自己的想法。](#沟通是开发者取得反馈的手段一个优秀的开发者是善于沟通的沟通包含口语写文档等各种方式优秀的开发者应该能够清晰而有条理地表达自己的想法)
    - [现实世界中，人们普遍认为：软件开发者因为跟机器打交道，从而是内向的，不善于沟通的。实际上，这样的开发者不能算是优秀的。他们所做的事情，更多地是把需求转化为计算机语言的工作，即翻译员。而现在都出来谷歌翻译了，人类语言翻译成计算机语言只是时间问题了。](#现实世界中人们普遍认为软件开发者因为跟机器打交道从而是内向的不善于沟通的实际上这样的开发者不能算是优秀的他们所做的事情更多地是把需求转化为计算机语言的工作即翻译员而现在都出来谷歌翻译了人类语言翻译成计算机语言只是时间问题了)
    - [沟通的目的是进行思想碰撞。在沟通当中了解别人的思维方式，表达自己的思维方式，进一步扬弃为更加优秀的思维方式。在优秀的思维方式之下才能保持让自己与现实相符合。优秀的开发者是不会放弃获取优秀的思维方式的机会的。](#沟通的目的是进行思想碰撞在沟通当中了解别人的思维方式表达自己的思维方式进一步扬弃为更加优秀的思维方式在优秀的思维方式之下才能保持让自己与现实相符合优秀的开发者是不会放弃获取优秀的思维方式的机会的)
    - [在敏捷开发当中，提出这一价值观，正是要开发者变得优秀。放弃优秀的开发者无法适应敏捷开发。](#在敏捷开发当中提出这一价值观正是要开发者变得优秀放弃优秀的开发者无法适应敏捷开发)
    - [勇气](#勇气)
    - [在现实生活中，缺乏勇气比较常见。比如，不敢大大方方地表白，不敢尝试新的事物……在软件开发领域，缺乏勇气更是常见：技术更新好几代了，公司还不敢使用新技术；公司不敢尝试新的开发模式（敏捷开发）……](#在现实生活中缺乏勇气比较常见比如不敢大大方方地表白不敢尝试新的事物在软件开发领域缺乏勇气更是常见技术更新好几代了公司还不敢使用新技术公司不敢尝试新的开发模式敏捷开发)
    - [勇气，本质上来讲，是对现状的否定。人们往往一厢情愿地相信永恒；一旦确定，就不愿意改变。这正是勇气的用武之地。勇气使人去否定永恒，拥抱改变。勇气是创造的源泉。人没有勇气，人就永远是他现在的这样了，正是勇气才迫使他去改变。](#勇气本质上来讲是对现状的否定人们往往一厢情愿地相信永恒一旦确定就不愿意改变这正是勇气的用武之地勇气使人去否定永恒拥抱改变勇气是创造的源泉人没有勇气人就永远是他现在的这样了正是勇气才迫使他去改变)
    - [在开发的时候，我们可能花了很多时间写了很多代码，但要决定放弃已经写过的所有代码，这是非常需要勇气的。而如果能够做到这一点，在软件开发上就占据了非常有利的位置。比如，我们可能会花大量时间去写页面原型，以希望能够得到用户反馈。在确定得到用户反馈之后，我们可以完全放弃原型代码，进而可以得到更加符合现实（也更加简单）的代码。](#在开发的时候我们可能花了很多时间写了很多代码但要决定放弃已经写过的所有代码这是非常需要勇气的而如果能够做到这一点在软件开发上就占据了非常有利的位置比如我们可能会花大量时间去写页面原型以希望能够得到用户反馈在确定得到用户反馈之后我们可以完全放弃原型代码进而可以得到更加符合现实也更加简单的代码)
    - [敏捷开发强调勇气这一价值观，正是要开发者去拥抱现实的变化，让开发者及软件朝着符合现实的路线走。](#敏捷开发强调勇气这一价值观正是要开发者去拥抱现实的变化让开发者及软件朝着符合现实的路线走)
    - [迭代开发](#迭代开发)
    - [讲完四个价值观之后，接下来我把四个价值观联系起来，得到一个方法论——迭代开发。](#讲完四个价值观之后接下来我把四个价值观联系起来得到一个方法论迭代开发)
    - [如图所示，简单是软件开发的起点，也是软件开发的终点。](#如图所示简单是软件开发的起点也是软件开发的终点)
    - [说它是起点，是因为，如果开发的东西还是复杂的，那就有必要把概念弄得简单一些。这包含两个方面的行动：一、把复杂的系统砍掉一半的功能（广度上）；二、尽可能对各个功能进行抽象（深度上，参考前面音乐软件的例子）。](#说它是起点是因为如果开发的东西还是复杂的那就有必要把概念弄得简单一些这包含两个方面的行动一把复杂的系统砍掉一半的功能广度上二尽可能对各个功能进行抽象深度上参考前面音乐软件的例子)
    - [接下来，我们拿着简单的软件（或者软件原型）进入沟通环节。我们可以在两个方面进行沟通：一、与用户沟通软件的逻辑是否满足要求；二、与开发者沟通软件是否在技术上代价很高，如何权衡。](#接下来我们拿着简单的软件或者软件原型进入沟通环节我们可以在两个方面进行沟通一与用户沟通软件的逻辑是否满足要求二与开发者沟通软件是否在技术上代价很高如何权衡)
    - [沟通之后，我们可以得到现实的反馈，在现实的反馈之下，我们才有勇气进行改变，使用我们的软件继续维持其简单性。这就完成了软件的一个迭代。](#沟通之后我们可以得到现实的反馈在现实的反馈之下我们才有勇气进行改变使用我们的软件继续维持其简单性这就完成了软件的一个迭代)
  - [敏捷方法](#敏捷方法)
    - [Scrum](#scrum)
      - [Scrum是和种迭代式及递增式的敏捷软件开发框架，它用于管理软件项目，产品，或程序的开发。它的着重点是一个灵活的，全面的产品开发策略，它把一个开发团队通常作为一个单位进而实现一个常规目的。相反，它不着重于传递的序列化式的方法。Scrum会问传统瀑布式开发“为什么我们要花费这么长时间，这么多努力去做一件事？为什么我们不能衡量出做一件事所需时间和人力？” Scrum拥抱变化和创造力，因为这是人们的工作方式。Scrum有一个流程学习结构，能够让团队评估他们做了什么以及他们怎样做的。](#scrum是和种迭代式及递增式的敏捷软件开发框架它用于管理软件项目产品或程序的开发它的着重点是一个灵活的全面的产品开发策略它把一个开发团队通常作为一个单位进而实现一个常规目的相反它不着重于传递的序列化式的方法scrum会问传统瀑布式开发为什么我们要花费这么长时间这么多努力去做一件事为什么我们不能衡量出做一件事所需时间和人力-scrum拥抱变化和创造力因为这是人们的工作方式scrum有一个流程学习结构能够让团队评估他们做了什么以及他们怎样做的)
      - [Scrum角色](#scrum角色)
        - [产品持有人 Product Owner](#产品持有人-product-owner)
        - [开发团队 Development Team](#开发团队-development-team)
        - [Scrum领导人 ScrumMaster](#scrum领导人-scrummaster)
      - [会议](#会议)
        - [1、Sprint计划会议](#1sprint计划会议)
        - [2、每日例会](#2每日例会)
        - [3、Sprint评审会议](#3sprint评审会议)
        - [4、Sprint回顾会议](#4sprint回顾会议)
      - [三个构件](#三个构件)
        - [1、产品Backlog  产品Backlog指根据初始需求分解出的任务列表，包括功能性和非功能性的所有功能。](#1产品backlog--产品backlog指根据初始需求分解出的任务列表包括功能性和非功能性的所有功能)
        - [2、Sprint Backlog Sprint Backlog就是任务列表，如果映射到传统的项目管理理论中就是WBS（work breakdown structure)，而且是典型的采用面向交付物的任务分解方法得到的WBS。](#2sprint-backlog-sprint-backlog就是任务列表如果映射到传统的项目管理理论中就是wbswork-breakdown-structure而且是典型的采用面向交付物的任务分解方法得到的wbs)
        - [3、燃尽图。](#3燃尽图)
      - [完成Scrum敏捷开发的流程为：](#完成scrum敏捷开发的流程为)
        - [第一步：Product Backing   找出完成产品需要做的事情。](#第一步product-backing---找出完成产品需要做的事情)
        - [第二步:Sprint Backlog   决定当前冲刺需要解决的事情。](#第二步sprint-backlog---决定当前冲刺需要解决的事情)
        - [第三步：Sprint   冲刺。](#第三步sprint---冲刺)
        - [第四步：得到软件的一个增量版本，发布给用户。然后在此基础上进一步计划增量的新功能和改进。](#第四步得到软件的一个增量版本发布给用户然后在此基础上进一步计划增量的新功能和改进)
      - [Scrum开发的一些注意事项：](#scrum开发的一些注意事项)
        - [1、我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；](#1我们首先需要确定一个product-backlog按优先顺序排列的一个产品需求列表这个是由product-owner-负责的)
        - [2、Scrum Team根据Product Backlog列表，做工作量的预估和安排；](#2scrum-team根据product-backlog列表做工作量的预估和安排)
        - [3、有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；](#3有了product-backlog列表我们需要通过-sprint-planning-meetingsprint计划会议-来从中挑选出一个story作为本次迭代完成的目标这个目标的时间周期是14个星期然后把这个story进行细化形成一个sprint-backlog)
        - [4、Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；](#4sprint-backlog是由scrum-team去完成的每个成员根据sprint-backlog再细化成更小的任务细到每个任务的工作量在2天内能完成)
        - [5、在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天 要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；](#5在scrum-team完成计划会议上选出的sprint-backlog过程中需要进行-daily-scrum-meeting每日站立会议每次会议控制在15分钟左右每个人都必须发言并且要向所有成员当面汇报你昨天完成了什么并且向所有成员承诺你今天-要完成什么同时遇到不能解决的问题也可以提出每个人回答完成后要走到黑板前更新自己的-sprint-burn-downsprint燃尽图)
        - [6、做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可 以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本 发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；](#6做到每日集成也就是每天都要有一个可以成功编译并且可以演示的版本很多人可能还没有用过自动化的每日集成其实tfs就有这个功能它可-以支持每次有成员进行签入操作的时候在服务器上自动获取最新版本然后在服务器中编译如果通过则马上再执行单元测试代码如果也全部通过则将该版本-发布这时一次正式的签入操作才保存到tfs中中间有任何失败都会用邮件通知项目管理人员)
        - [7、当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；](#7当一个story完成也就是sprint-backlog被完成也就表示一次sprint完成这时我们要进行-srpint-review-meeting演示会议也称为评审会议产品负责人和客户都要参加最好本公司老板也参加每一个scrum-team的成员都要向他们演示自己完成的软件产品这个会议非常重要一定不能取消)
        - [8、最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；](#8最后就是-sprint-retrospective-meeting回顾会议也称为总结会议以轮流发言方式进行每个人都要发言总结并讨论改进的地方放入下一轮sprint的产品需求中)
      - [需求收集](#需求收集)
        - [1.1  需求的分类](#11--需求的分类)
        - [1.2  需求提交模板](#12--需求提交模板)
        - [② 优先级 可从以下五种情况中选择](#-优先级-可从以下五种情况中选择)
        - [③ 需求类型 可以是两种类型](#-需求类型-可以是两种类型)
        - [④ 需求标题 有自己进行书写，但是需要遵守的规范是采用动宾短语格式。](#-需求标题-有自己进行书写但是需要遵守的规范是采用动宾短语格式)
        - [⑤ 详细描述 需要按照用户故事的格式进行书写。具体用户故事格式的要求如下：](#-详细描述-需要按照用户故事的格式进行书写具体用户故事格式的要求如下)
        - [用户故事是从用户的角度来描述用户渴望得到的功能。需要注意的是用户故事不能够使用技术语言来描述，要使用用户可以理解的业务语言来描述。一个好的用户故事包括三个要素：](#用户故事是从用户的角度来描述用户渴望得到的功能需要注意的是用户故事不能够使用技术语言来描述要使用用户可以理解的业务语言来描述一个好的用户故事包括三个要素)
        - [用户故事通常按照如下的格式来表达：作为一个\<角色\>, 我想要\<活动\>, 以便于\<商业价值\>](#用户故事通常按照如下的格式来表达作为一个角色-我想要活动-以便于商业价值)
        - [比如：作为一名酒店前端开发人员，我期望查看所有酒店页面的页面打开时间，以便了解哪些页面需要进行技能优化。](#比如作为一名酒店前端开发人员我期望查看所有酒店页面的页面打开时间以便了解哪些页面需要进行技能优化)
        - [一个好的用户故事同时要符合INVEST原则，INVEST原则分别是：](#一个好的用户故事同时要符合invest原则invest原则分别是)
        - [注意：](#注意)
        - [角色的范围不能过大，比如是作为一名“用户”，这样是的不被接受的。](#角色的范围不能过大比如是作为一名用户这样是的不被接受的)
        - [商业价值也不能大而宽泛，比如，能为公司创造业绩。如果要写也一定要对业绩做初步估算，比如，预期会给公司带来每月1万张订单。](#商业价值也不能大而宽泛比如能为公司创造业绩如果要写也一定要对业绩做初步估算比如预期会给公司带来每月1万张订单)
        - [⑥ 验收条件 是开发完成后检验的标准，所以一定要认真填写，否则可能开发出来的东西与预期不达标。](#-验收条件-是开发完成后检验的标准所以一定要认真填写否则可能开发出来的东西与预期不达标)
        - [⑦   价值验证 说明如何跟踪上线后的效果](#---价值验证-说明如何跟踪上线后的效果)
      - [Sprint 计划会议 1](#sprint-计划会议-1)
        - [目标：定出 Sprint 目标和既定产品 Backlog。](#目标定出-sprint-目标和既定产品-backlog)
        - [2.1 会议准备](#21-会议准备)
        - [2.2 会议议程](#22-会议议程)
        - [2.3 会议结果](#23-会议结果)
        - [2.4 补充内容](#24-补充内容)
      - [Sprint 计划会议 2](#sprint-计划会议-2)
        - [目标：确定所有任务，生成 Sprint Backlog，确认 Sprint 目标](#目标确定所有任务生成-sprint-backlog确认-sprint-目标)
        - [3.1 会议准备](#31-会议准备)
        - [3.2 会议进程](#32-会议进程)
        - [3.3 会议结果](#33-会议结果)
        - [3.4 补充内容](#34-补充内容)
      - [Scrum 每日例会](#scrum-每日例会)
        - [目标：团队成员间工作进度的沟通和协调](#目标团队成员间工作进度的沟通和协调)
        - [4.1 会议准备](#41-会议准备)
        - [4.2 会议进程](#42-会议进程)
        - [4.3 会议结果](#43-会议结果)
      - [Sprint 验收会议](#sprint-验收会议)
        - [目标：根据团队这次 Sprint 所发布的版本，评审相关的 Backlog 中的问题，检查是否已达到 Sprint 的目标。](#目标根据团队这次-sprint-所发布的版本评审相关的-backlog-中的问题检查是否已达到-sprint-的目标)
        - [5.1 会议准备](#51-会议准备)
        - [5.2 会议进程](#52-会议进程)
        - [5.3 会议结果](#53-会议结果)
      - [Sprint 回顾会议](#sprint-回顾会议)
        - [目标：通过总结以往的实践经验来提高团队生产力。](#目标通过总结以往的实践经验来提高团队生产力)
        - [注意：主要指导原则：不管我们现在发现了什么问题，我们必须懂得并坚信每个人通过他们当时所知的，他所拥有的技能和可得到的资源，在限定的环境下，都尽其所能做出了最好的成绩。](#注意主要指导原则不管我们现在发现了什么问题我们必须懂得并坚信每个人通过他们当时所知的他所拥有的技能和可得到的资源在限定的环境下都尽其所能做出了最好的成绩)
        - [6.1 会议准备](#61-会议准备)
        - [6.2 会议进程](#62-会议进程)
        - [6.3 会议结果](#63-会议结果)
    - [极限编程XP](#极限编程xp)
      - [极限编程是一个轻量级的、灵巧的软件开发方法；](#极限编程是一个轻量级的灵巧的软件开发方法)
        - [开发人员知道要做什么，以及要优先做什么；](#开发人员知道要做什么以及要优先做什么)
        - [工作有效率；](#工作有效率)
        - [有问题或困难时，能得到客户、同事、上级的回答或帮助；](#有问题或困难时能得到客户同事上级的回答或帮助)
        - [对工作做评估，并根据周围情况的变化及时重新评估；](#对工作做评估并根据周围情况的变化及时重新评估)
        - [积极承担工作，而不是消极接受分配；](#积极承担工作而不是消极接受分配)
        - [一周40小时工作制，不加班。](#一周40小时工作制不加班)
      - [与其他方法论相比，其最大的不同在于](#与其他方法论相比其最大的不同在于)
        - [在更短的周期内，更早地提供具体、持续的反馈信息。](#在更短的周期内更早地提供具体持续的反馈信息)
        - [在迭代的进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断的发展它。](#在迭代的进行计划编制首先在最开始迅速生成一个总体计划然后在整个项目开发过程中不断的发展它)
        - [依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。](#依赖于自动测试程序来监控开发进度并及早地捕获缺陷)
        - [依赖于口头交流、测试和源程序进行沟通。](#依赖于口头交流测试和源程序进行沟通)
        - [倡导持续的演化式设计。](#倡导持续的演化式设计)
        - [依赖于开发团队内部的紧密协作。](#依赖于开发团队内部的紧密协作)
        - [尽可能达到程序员短期利益和项目长期利益的平衡。](#尽可能达到程序员短期利益和项目长期利益的平衡)
      - [四大价值观](#四大价值观)
        - [XP的核心是其总结的沟通、简单、反馈、勇气四大价值观，它们是XP的基础，也是XP的灵魂。](#xp的核心是其总结的沟通简单反馈勇气四大价值观它们是xp的基础也是xp的灵魂)
        - [1. 沟通](#1-沟通)
        - [2. 简单](#2-简单)
        - [3. 反馈](#3-反馈)
        - [4. 勇气](#4-勇气)
        - [5. 四大价值观之外](#5-四大价值观之外)
        - [在这四大价值观之下，隐藏着一个更深刻的东西，那就是尊重。因为这一切都建立在团队成员之间的相互关心、相互理解的基础之上。](#在这四大价值观之下隐藏着一个更深刻的东西那就是尊重因为这一切都建立在团队成员之间的相互关心相互理解的基础之上)
      - [5个原则](#5个原则)
        - [1. 快速反馈](#1-快速反馈)
        - [2. 简单性假设](#2-简单性假设)
        - [3. 逐步修改](#3-逐步修改)
        - [4. 提倡更改](#4-提倡更改)
        - [5. 优质工作](#5-优质工作)
      - [13个最佳实践](#13个最佳实践)
        - [在XP中，集成了13个最佳实践，有趣的是，它们没有一个是创新的概念，大多数概念和编程一样老。其主要创新点在于提供一种良好的思路，将这些最佳实践结合在一起，并且确保尽可能彻底地执行它们，使得它们能够在最大程度上相互支持，紧接下来，我们就对每一种最佳实践进行一番了解。](#在xp中集成了13个最佳实践有趣的是它们没有一个是创新的概念大多数概念和编程一样老其主要创新点在于提供一种良好的思路将这些最佳实践结合在一起并且确保尽可能彻底地执行它们使得它们能够在最大程度上相互支持紧接下来我们就对每一种最佳实践进行一番了解)
        - [1. 计划游戏](#1-计划游戏)
        - [2. 小型发布](#2-小型发布)
        - [3. 隐喻](#3-隐喻)
        - [4. 简单设计](#4-简单设计)
        - [5. 测试先行](#5-测试先行)
        - [6. 重构](#6-重构)
        - [7. 结对编程](#7-结对编程)
        - [8. 集体代码所有制](#8-集体代码所有制)
        - [9. 持续集成](#9-持续集成)
        - [10. 每周工作40小时](#10-每周工作40小时)
        - [11. 现场客户](#11-现场客户)
        - [12. 编码标准](#12-编码标准)
        - [13. 配合是关键](#13-配合是关键)
        - [有句经典名言“1+1\>2”最适合表达XP的观点，Kent Beck认为XP方法论的最大价值在于在项目中融会贯通地运用12个最佳实践，而非单独地使用。你当然可以使用其中的一些实践，但这并不意味着你就运用了XP方法论。XP方法论真正能够发挥其效能，就必须完整地运用12个实践。](#有句经典名言112最适合表达xp的观点kent-beck认为xp方法论的最大价值在于在项目中融会贯通地运用12个最佳实践而非单独地使用你当然可以使用其中的一些实践但这并不意味着你就运用了xp方法论xp方法论真正能够发挥其效能就必须完整地运用12个实践)
    - [水晶方法](#水晶方法)
      - [水晶方法，Crystal ，](#水晶方法crystal-)
      - [七大特征](#七大特征)
        - [体系特征一：经常交付](#体系特征一经常交付)
        - [体系特征二：反思改进](#体系特征二反思改进)
        - [体系特征三：渗透式交流](#体系特征三渗透式交流)
        - [体系特征四：个人安全](#体系特征四个人安全)
        - [体系特征五：焦点](#体系特征五焦点)
        - [体系特征六：与专家用户建立方便的联系](#体系特征六与专家用户建立方便的联系)
        - [体系特征七：配有自动测试、配置管理和经常集成功能的技术环境](#体系特征七配有自动测试配置管理和经常集成功能的技术环境)
    - [DSDM-动态系统开发方法](#dsdm-动态系统开发方法)
      - [Dynamic System Development Management，](#dynamic-system-development-management)
      - [基本原则](#基本原则)
        - [原则1：用户必须持续参与 active user involvement is imperative](#原则1用户必须持续参与-active-user-involvement-is-imperative)
        - [原则2：必须授予DSDM团队制定决策的权利 DSDM teams are empowered to make decisions including refining or changing requirements without the direct involvement of higher management](#原则2必须授予dsdm团队制定决策的权利-dsdm-teams-are-empowered-to-make-decisions-including-refining-or-changing-requirements-without-the-direct-involvement-of-higher-management)
        - [原则3：注重产品的经常交付 The focus is on frequent product delivery](#原则3注重产品的经常交付-the-focus-is-on-frequent-product-delivery)
        - [原则4：满足业务用户用途是接受交付品的主要依据 Fitness for purpose is the key criterion](#原则4满足业务用户用途是接受交付品的主要依据-fitness-for-purpose-is-the-key-criterion)
        - [原则5：迭代和增量式开发对得到正确的业务解决方案是必不可少的 Iterative and incremental development is necessary to converge on an accurate business solution](#原则5迭代和增量式开发对得到正确的业务解决方案是必不可少的-iterative-and-incremental-development-is-necessary-to-converge-on-an-accurate-business-solution)
        - [原则6：开发过程的所有变化可逆 All changes during development are reversible](#原则6开发过程的所有变化可逆-all-changes-during-development-are-reversible)
        - [原则7：在高层次上制定需求的基线 Requirements are initially agreed at a high level](#原则7在高层次上制定需求的基线-requirements-are-initially-agreed-at-a-high-level)
        - [原则8：测试自始至终贯穿于开发周期之中 Testing is integrated throughout the life cycle — this is essential with an incremental approach](#原则8测试自始至终贯穿于开发周期之中-testing-is-integrated-throughout-the-life-cycle--this-is-essential-with-an-incremental-approach)
        - [原则9：所有项目涉众间的通力合作是不可获缺的 A collaborative and co-operative approach between all stakeholders is essential](#原则9所有项目涉众间的通力合作是不可获缺的-a-collaborative-and-co-operative-approach-between-all-stakeholders-is-essential)
    - [测试驱动开发](#测试驱动开发)
      - [测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码，然后只编写使测试通过的功能代码，从而以测试来驱动整个开发过程的进行。这有助于编写简洁可用和高质量的代码，有很高的灵活性和健壮性，能快速响应变化，并加速开发过程。](#测试驱动开发的基本思想就是在开发功能代码之前先编写测试代码然后只编写使测试通过的功能代码从而以测试来驱动整个开发过程的进行这有助于编写简洁可用和高质量的代码有很高的灵活性和健壮性能快速响应变化并加速开发过程)
      - [测试驱动开发的基本过程如下：](#测试驱动开发的基本过程如下)
        - [①　快速新增一个测试](#快速新增一个测试)
        - [②　运行所有的测试（有时候只需要运行一个或一部分），发现新增的测试不能通过](#运行所有的测试有时候只需要运行一个或一部分发现新增的测试不能通过)
        - [③　做一些小小的改动，尽快地让测试程序可运行，为此可以在程序中使用一些不合情理的方法](#做一些小小的改动尽快地让测试程序可运行为此可以在程序中使用一些不合情理的方法)
        - [④　运行所有的测试，并且全部通过](#运行所有的测试并且全部通过)
        - [⑤　重构代码，以消除重复设计，优化设计结构](#重构代码以消除重复设计优化设计结构)
      - [简单来说，就是不可运行/可运行/重构——这正是测试驱动开发的口号。](#简单来说就是不可运行可运行重构这正是测试驱动开发的口号)
        - [1) TDD根据客户需求编写测试用例，对功能的过程和接口都进行了设计，而且这种从使用者角度对代码进行的设计通常更符合后期开发的需求。因为关注用户反馈，可以及时响应需求变更，同时因为从使用者角度出发的简单设计，也可以更快地适应变化。](#1-tdd根据客户需求编写测试用例对功能的过程和接口都进行了设计而且这种从使用者角度对代码进行的设计通常更符合后期开发的需求因为关注用户反馈可以及时响应需求变更同时因为从使用者角度出发的简单设计也可以更快地适应变化)
        - [2) 出于易测试和测试独立性的要求，将促使我们实现松耦合的设计，并更多地依赖于接口而非具体的类，提高系统的可扩展性和抗变性。而且TDD明显地缩短了设计决策的反馈循环，使我们几秒或几分钟之内就能获得反馈。](#2-出于易测试和测试独立性的要求将促使我们实现松耦合的设计并更多地依赖于接口而非具体的类提高系统的可扩展性和抗变性而且tdd明显地缩短了设计决策的反馈循环使我们几秒或几分钟之内就能获得反馈)
        - [3) 将测试工作提到编码之前，并频繁地运行所有测试，可以尽量地避免和尽早地发现错误，极大地降低了后续测试及修复的成本，提高了代码的质量。在测试的保护下，不断重构代码，以消除重复设计，优化设计结构，提高了代码的重用性，从而提高了软件产品的质量。](#3-将测试工作提到编码之前并频繁地运行所有测试可以尽量地避免和尽早地发现错误极大地降低了后续测试及修复的成本提高了代码的质量在测试的保护下不断重构代码以消除重复设计优化设计结构提高了代码的重用性从而提高了软件产品的质量)
        - [4) TDD提供了持续的回归测试，使我们拥有重构的勇气，因为代码的改动导致系统其他部分产生任何异常，测试都会立刻通知我们。完整的测试会帮助我们持续地跟踪整个系统的状态，因此我们就不需要担心会产生什么不可预知的副作用了。](#4-tdd提供了持续的回归测试使我们拥有重构的勇气因为代码的改动导致系统其他部分产生任何异常测试都会立刻通知我们完整的测试会帮助我们持续地跟踪整个系统的状态因此我们就不需要担心会产生什么不可预知的副作用了)
        - [5) TDD所产生的单元测试代码就是最完美的开发者文档，它们展示了所有的API该如何使用以及是如何运作的，而且它们与工作代码保持同步，永远是最新的。](#5-tdd所产生的单元测试代码就是最完美的开发者文档它们展示了所有的api该如何使用以及是如何运作的而且它们与工作代码保持同步永远是最新的)
        - [6) TDD可以减轻压力、降低忧虑、提高我们对代码的信心、使我们拥有重构的勇气，这些都是快乐工作的重要前提。](#6-tdd可以减轻压力降低忧虑提高我们对代码的信心使我们拥有重构的勇气这些都是快乐工作的重要前提)
        - [7)快速的提高了开发效率。](#7快速的提高了开发效率)
      - [，](#)
    - [Lean软件开发（精益软件开发）](#lean软件开发精益软件开发)
      - [面对开发团队以及最终的产品大小的额外挑战，可以说软件开发是个持续学习的过程。最佳的改善软件开发环境的做法就是增强学习。在代码完成后马上进行测试可以避免缺陷的累积。不是去做成更多的文档或详细设计，而是对各种各样的想法进行实际的编码尝试。用户需求的收集过程可以简单地通过给最终客户演示，并听取他们的反馈来完成。](#面对开发团队以及最终的产品大小的额外挑战可以说软件开发是个持续学习的过程最佳的改善软件开发环境的做法就是增强学习在代码完成后马上进行测试可以避免缺陷的累积不是去做成更多的文档或详细设计而是对各种各样的想法进行实际的编码尝试用户需求的收集过程可以简单地通过给最终客户演示并听取他们的反馈来完成)
      - [使用短周期的迭代（每个迭代都应包括重构和集成测试）可以加速学习过程。在决定当前阶段的开发内容并对未来改善的努力方向进行调整时，在客户端帮助下通过简短的反馈会议来增强反馈。通过这些简短的反馈会议，客户代表和开发团队会更多地发现在进一步开发时会遇到的主要问题及可能的解决方案。从而，基于已开发出的原型，客户可以更好地理解自己的需求，开发者也能了解到如何才能更好地满足客户的需求。另一个关于和客户沟通、学习的想法是“基于组的开发”，这种方法聚焦于未来解决方案的约束限定而不是各种可能的解决方案，因此通过和客户的对话加速了解决方案的产生。](#使用短周期的迭代每个迭代都应包括重构和集成测试可以加速学习过程在决定当前阶段的开发内容并对未来改善的努力方向进行调整时在客户端帮助下通过简短的反馈会议来增强反馈通过这些简短的反馈会议客户代表和开发团队会更多地发现在进一步开发时会遇到的主要问题及可能的解决方案从而基于已开发出的原型客户可以更好地理解自己的需求开发者也能了解到如何才能更好地满足客户的需求另一个关于和客户沟通学习的想法是基于组的开发这种方法聚焦于未来解决方案的约束限定而不是各种可能的解决方案因此通过和客户的对话加速了解决方案的产生)
      - [原则](#原则)
        - [消除浪费](#消除浪费)
        - [增强学习](#增强学习)
        - [尽量延迟决定](#尽量延迟决定)
        - [尽快发布](#尽快发布)
        - [下放权力](#下放权力)
        - [嵌入质量](#嵌入质量)
        - [全局优化](#全局优化)
    - [轻量型RUP](#轻量型rup)
      - [RUP其实是个过程的框架，它可以包容许多不同类型的过程， Craig Larman 极力主张以敏捷型方式来使用RUP。](#rup其实是个过程的框架它可以包容许多不同类型的过程-craig-larman-极力主张以敏捷型方式来使用rup)
      - [RUP 是一种以架构为中心的开发过程，而这正是大、中型项目成功的关键。](#rup-是一种以架构为中心的开发过程而这正是大中型项目成功的关键)
      - [RUP（Rational Unified Process）是一个风险驱动的基于UML 和构件式架构的迭代递增型开发过程（框架）。RUP 定义了4 个阶段（起始、细化、构造、移交）和9 个科目（业务建模、需求、分析和设计、实现、测试、部署、配置和变更管理、项目管理、环境）。这些阶段对应着关键里程碑的划分，而不同科目的工作流和活动 在生命周期的迭代中可以并发进行，具体执行的程度则可以调节。RUP 对于角色、流程、工件和活动的要求是灵活的、可配置的，所以它广泛地适用于各种类型和规模的项目。RUP 集中体现了6 个软件开发的最佳实践方法：迭代式开发、需求管理、构件式架构、基于UML 的可视化建模、持续校验质量、变更管理。](#ruprational-unified-process是一个风险驱动的基于uml-和构件式架构的迭代递增型开发过程框架rup-定义了4-个阶段起始细化构造移交和9-个科目业务建模需求分析和设计实现测试部署配置和变更管理项目管理环境这些阶段对应着关键里程碑的划分而不同科目的工作流和活动-在生命周期的迭代中可以并发进行具体执行的程度则可以调节rup-对于角色流程工件和活动的要求是灵活的可配置的所以它广泛地适用于各种类型和规模的项目rup-集中体现了6-个软件开发的最佳实践方法迭代式开发需求管理构件式架构基于uml-的可视化建模持续校验质量变更管理)
      - [RUP认为下面这些最佳实践可以改善软件的开发状况：](#rup认为下面这些最佳实践可以改善软件的开发状况)
        - [在早期迭代中解决高风险和高价值的问题](#在早期迭代中解决高风险和高价值的问题)
        - [不断的让用户参与评估、反馈和需求](#不断的让用户参与评估反馈和需求)
        - [在早期迭代中建立内聚的核心架构](#在早期迭代中建立内聚的核心架构)
        - [不断地验证质量：提早、经常和实际的测试](#不断地验证质量提早经常和实际的测试)
        - [可视化软件建模（使用UML）](#可视化软件建模使用uml)
        - [仔细的管理需求](#仔细的管理需求)
        - [实行变更请求和配置管理](#实行变更请求和配置管理)
      - [四个阶段](#四个阶段)
        - [初始阶段（Inception)：](#初始阶段inception)
        - [细化阶段（Elaboration）：](#细化阶段elaboration)
        - [构造阶段（Construction）：](#构造阶段construction)
        - [移交阶段（Transition）：](#移交阶段transition)
      - [多个流程](#多个流程)
        - [业务建模：在开发单独的应用时，业务建模包括领域对象建模。在从事大规模业务分析或业务过程再工程时，业务建模包括跨越整个企业的业务过程的动态建模。](#业务建模在开发单独的应用时业务建模包括领域对象建模在从事大规模业务分析或业务过程再工程时业务建模包括跨越整个企业的业务过程的动态建模)
        - [需求：对应用的需求分析，如写出用例和识别非功能性需求](#需求对应用的需求分析如写出用例和识别非功能性需求)
        - [分析和设计：设计的所有方面，包括总体架构、对象、数据库、网络连接等。分析强调的是对问题和需求的调查研究，而不是解决方案。设计强调的是满足需求的概念上的解决方案，而不是其实现。分析和设计可以被概括为：作正确的事（分析）和正确的做事（设计）。](#分析和设计设计的所有方面包括总体架构对象数据库网络连接等分析强调的是对问题和需求的调查研究而不是解决方案设计强调的是满足需求的概念上的解决方案而不是其实现分析和设计可以被概括为作正确的事分析和正确的做事设计)
        - [实现：编程和构建系统，而不是部署系统](#实现编程和构建系统而不是部署系统)
        - [测试](#测试-1)
        - [配置和变更管理](#配置和变更管理)
        - [项目管理](#项目管理)
        - [环境：指建立工具并为项目定制过程，也就是说，设置工具和过程环境。](#环境指建立工具并为项目定制过程也就是说设置工具和过程环境)
        - [1－5为核心工作流程，6－8为支持工作流程](#15为核心工作流程68为支持工作流程)
        - [The way of controlling](#the-way-of-controlling)
        - [The way of supporting](#the-way-of-supporting)
        - [The way of communicating](#the-way-of-communicating)
      - [模型和流程对应](#模型和流程对应)
        - [角色: the who](#角色-the-who)
        - [活动: the how](#活动-the-how)
        - [工件：the what](#工件the-what)
        - [工作流: the when](#工作流-the-when)
        - [规程（Disciplines）: 组合前面四种元素](#规程disciplines-组合前面四种元素)
      - [六大经验](#六大经验)
        - [迭代式开发。在软件开发的早期阶段就想完全、准确的捕获用户的需求几乎是不可能的。实际上，我们经常遇到的问题是需求在整个软件开发工程中经常会改变。迭代式开发允许在每次迭代过程中需求可能有变化，通过不断细化来加深对问题的理解。迭代式开发不仅可以降低项目的风险，而且每个迭代过程以可以执行版本结束，可以鼓舞开发人员。](#迭代式开发在软件开发的早期阶段就想完全准确的捕获用户的需求几乎是不可能的实际上我们经常遇到的问题是需求在整个软件开发工程中经常会改变迭代式开发允许在每次迭代过程中需求可能有变化通过不断细化来加深对问题的理解迭代式开发不仅可以降低项目的风险而且每个迭代过程以可以执行版本结束可以鼓舞开发人员)
        - [管理需求。确定系统的需求是一个连续的过程，开发人员在开发系统之前不可能完全详细的说明一个系统的真正需求。RUP描述了如何提取、组织系统的功能和约束条件并将其文档化，用例和脚本的使用以被证明是捕获功能性需求的有效方法。](#管理需求确定系统的需求是一个连续的过程开发人员在开发系统之前不可能完全详细的说明一个系统的真正需求rup描述了如何提取组织系统的功能和约束条件并将其文档化用例和脚本的使用以被证明是捕获功能性需求的有效方法)
        - [基于组件的体系结构。组件使重用成为可能，系统可以由组件组成。基于独立的、可替换的、模块化组件的体系结构有助于管理复杂性，提高重用率。RUP描述了如何设计一个有弹性的、能适应变化的、易于理解的、有助于重用的软件体系结构。](#基于组件的体系结构组件使重用成为可能系统可以由组件组成基于独立的可替换的模块化组件的体系结构有助于管理复杂性提高重用率rup描述了如何设计一个有弹性的能适应变化的易于理解的有助于重用的软件体系结构)
        - [可视化建模。RUP往往和UML联系在一起，对软件系统建立可视化模型帮助人们提供管理软件复杂性的能力。RUP告诉我们如何可视化的对软件系统建模，获取有关体系结构于组件的结构和行为信息。](#可视化建模rup往往和uml联系在一起对软件系统建立可视化模型帮助人们提供管理软件复杂性的能力rup告诉我们如何可视化的对软件系统建模获取有关体系结构于组件的结构和行为信息)
        - [验证软件质量。在RUP中软件质量评估不再是事后进行或单独小组进行的分离活动，而是内建于过程中的所有活动，这样可以及早发现软件中的缺陷。](#验证软件质量在rup中软件质量评估不再是事后进行或单独小组进行的分离活动而是内建于过程中的所有活动这样可以及早发现软件中的缺陷)
        - [控制软件变更。迭代式开发中如果没有严格的控制和协调，整个软件开发过程很快就陷入混乱之中，RUP描述了如何控制、跟踪、监控、修改以确保成功的迭代开发。RUP通过软件开发过程中的制品，隔离来自其他工作空间的变更，以此为每个开发人员建立安全的工作空间。](#控制软件变更迭代式开发中如果没有严格的控制和协调整个软件开发过程很快就陷入混乱之中rup描述了如何控制跟踪监控修改以确保成功的迭代开发rup通过软件开发过程中的制品隔离来自其他工作空间的变更以此为每个开发人员建立安全的工作空间)
      - [核心概念](#核心概念)
        - [角色：描述某个人或者一个小组的行为与职责。RUP预先定义了很多角色。](#角色描述某个人或者一个小组的行为与职责rup预先定义了很多角色)
        - [活动：是一个有明确目的的独立工作单元。](#活动是一个有明确目的的独立工作单元)
        - [工件：是活动生成、创建或修改的一段信息。](#工件是活动生成创建或修改的一段信息)
      - [RUP裁剪](#rup裁剪)
        - [RUP是一个通用的过程模板，包含了很多开发指南、制品、开发过程所涉及到的角色说明，由于它非常庞大所以对具体的开发机构和项目，用RUP时还要做裁剪，也就是要对RUP进行配置。RUP就像一个元过程，通过对RUP进行裁剪可以得到很多不同的开发过程，这些软件开发过程可以看作RUP的具体实例。RUP裁剪可以分为以下几步：](#rup是一个通用的过程模板包含了很多开发指南制品开发过程所涉及到的角色说明由于它非常庞大所以对具体的开发机构和项目用rup时还要做裁剪也就是要对rup进行配置rup就像一个元过程通过对rup进行裁剪可以得到很多不同的开发过程这些软件开发过程可以看作rup的具体实例rup裁剪可以分为以下几步)
        - [1)        确定本项目需要哪些工作流。RUP的9个核心工作流并不总是需要的，可以取舍。](#1--------确定本项目需要哪些工作流rup的9个核心工作流并不总是需要的可以取舍)
        - [2)        确定每个工作流需要哪些制品。](#2--------确定每个工作流需要哪些制品)
        - [3)        确定4个阶段之间如何演进。确定阶段间演进要以风险控制为原则，决定每个阶段要那些工作流，每个工作流执行到什么程度，制品有那些，每个制品完成到什么程度。](#3--------确定4个阶段之间如何演进确定阶段间演进要以风险控制为原则决定每个阶段要那些工作流每个工作流执行到什么程度制品有那些每个制品完成到什么程度)
        - [4)        确定每个阶段内的迭代计划。规划RUP的4个阶段中每次迭代开发的内容。](#4--------确定每个阶段内的迭代计划规划rup的4个阶段中每次迭代开发的内容)
        - [5)        规划工作流内部结构。工作流涉及角色、活动及制品，他的复杂程度与项目规模即角色多少有关。最后规划工作流的内部结构，通常用活动图的形式给出。](#5--------规划工作流内部结构工作流涉及角色活动及制品他的复杂程度与项目规模即角色多少有关最后规划工作流的内部结构通常用活动图的形式给出)
- [面向对象](#面向对象)
  - [结构化与面向对象方法特点比较](#结构化与面向对象方法特点比较)
  - [OOD(Object Oriented Design)](#oodobject-oriented-design)
    - [OOD步骤](#ood步骤)
      - [细化重组类](#细化重组类)
    - [OOD设计过程中要展开的主要几项工作](#ood设计过程中要展开的主要几项工作)
      - [（一）对象定义规格的求精过程](#一对象定义规格的求精过程)
      - [（二）数据模型和数据库设计](#二数据模型和数据库设计)
      - [（三）优化](#三优化)
      - [六、OO方法的特点和面临的问题](#六oo方法的特点和面临的问题)
      - [七、OOD能给我带来什么？](#七ood能给我带来什么)
    - [实现UML建模](#实现uml建模)
      - [(1)  业务对象的提取](#1--业务对象的提取)
      - [(2)  根据SRS、CRC等实现用况建模](#2--根据srscrc等实现用况建模)
      - [(3)  实现业务顺序图](#3--实现业务顺序图)
      - [(4)  建立类图，根据用况图建立对象之间的关联](#4--建立类图根据用况图建立对象之间的关联)
      - [(5)  绘制活动图、实现协作图、状态图](#5--绘制活动图实现协作图状态图)
  - [OOP(Object Oriented Programming)](#oopobject-oriented-programming)
    - [主要目标](#主要目标)
      - [重用性、](#重用性)
      - [灵活性](#灵活性)
      - [扩展性。](#扩展性)
    - [概念和组件：](#概念和组件)
      - [组件](#组件)
        - [数据和功能一起在运行着的计算机程序中形成的单元，组件在 OOP 计算机程序中是模块和结构化的基础。](#数据和功能一起在运行着的计算机程序中形成的单元组件在-oop-计算机程序中是模块和结构化的基础)
      - [抽象性](#抽象性)
        - [程序有能力忽略正在处理中信息的某些方面，即对信息主要方面关注的能力。](#程序有能力忽略正在处理中信息的某些方面即对信息主要方面关注的能力)
      - [封装](#封装)
        - [也叫做信息封装：确保组件不会以不可预期的方式改变其它组件的内部状态；只有在那些提供了内部状态改变方法的组件中，才可以访问其内部状态。每类组件都提供了一个与其它组件联系的接口，并规定了其它组件进行调用的方法。](#也叫做信息封装确保组件不会以不可预期的方式改变其它组件的内部状态只有在那些提供了内部状态改变方法的组件中才可以访问其内部状态每类组件都提供了一个与其它组件联系的接口并规定了其它组件进行调用的方法)
      - [多态性](#多态性)
        - [组件的引用和类集会涉及到其它许多不同类型的组件，而且引用组件所产生的结果得依据实际调用的类型。](#组件的引用和类集会涉及到其它许多不同类型的组件而且引用组件所产生的结果得依据实际调用的类型)
      - [继承性](#继承性)
        - [允许在现存的组件基础上创建子类组件，这统一并增强了多态性和封装性。典型地来说就是用类来对组件进行分组，而且还可以定义新类为现存的类的扩展，这样就可以将类组织成树形或网状结构，这体现了动作的通用性。](#允许在现存的组件基础上创建子类组件这统一并增强了多态性和封装性典型地来说就是用类来对组件进行分组而且还可以定义新类为现存的类的扩展这样就可以将类组织成树形或网状结构这体现了动作的通用性)
    - [基本特征](#基本特征)
      - [封装](#封装-1)
        - [封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。](#封装也就是把客观事物封装成抽象的类并且类可以把自己的数据和方法只让可信的类或者对象操作对不可信的进行信息隐藏)
      - [继承](#继承)
        - [实现继承是指使用基类的属性和方法而无需额外编码的能力；](#实现继承是指使用基类的属性和方法而无需额外编码的能力)
        - [Ø         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；](#ø---------接口继承是指仅使用属性和方法的名称但是子类必须提供实现的能力)
        - [Ø         可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。](#ø---------可视继承是指子窗体类使用基窗体类的外观和实现代码的能力)
      - [多态](#多态)
        - [覆盖，是指子类重新定义父类的虚函数的做法。](#覆盖是指子类重新定义父类的虚函数的做法)
        - [重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。](#重载是指允许存在多个同名函数而这些函数的参数表不同或许参数个数不同或许参数类型不同或许两者都不同)
    - [模式（GoF）与原则](#模式gof与原则)
  - [OOA(Object Oriented Analyzing)](#ooaobject-oriented-analyzing)
    - [需要做什么](#需要做什么)
      - [1)为完成用户要求系统应提供哪些功能?](#1为完成用户要求系统应提供哪些功能)
      - [2)系统应有哪些对象构成?](#2系统应有哪些对象构成)
      - [3)每个对象应有哪些属性和服务?](#3每个对象应有哪些属性和服务)
      - [4)对象间应有怎样的联系?要](#4对象间应有怎样的联系要)
    - [怎么做](#怎么做)
      - [1)个体特征分析:标识对象及其属性和服务。](#1个体特征分析标识对象及其属性和服务)
      - [2)静态分析:分析和描述系统的静态结构。](#2静态分析分析和描述系统的静态结构)
      - [3)动态分析:分析对象及之间的行为及其控制关系,建立系统的动态模型。](#3动态分析分析对象及之间的行为及其控制关系建立系统的动态模型)
    - [主要原则](#主要原则)
      - [（1）抽象](#1抽象)
        - [从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性的特征，就叫作抽象。](#从许多事物中舍弃个别的非本质的特征抽取共同的本质性的特征就叫作抽象)
      - [（2）封装](#2封装)
        - [就是把对象的属性和服务结合为一个不可分的系统单位，并尽可能隐蔽对象的内部细节。](#就是把对象的属性和服务结合为一个不可分的系统单位并尽可能隐蔽对象的内部细节)
      - [（3）继承](#3继承)
        - [特殊类的对象拥有的其一般类的全部属性与服务，称作特殊类对一般类的继承。](#特殊类的对象拥有的其一般类的全部属性与服务称作特殊类对一般类的继承)
      - [（4）分类](#4分类)
        - [就是把具有相同属性和服务的对象划分为一类，用类作为这些对象的抽象描述。分类原则实际上是抽象原则运用于对象描述时的一种表现形式。](#就是把具有相同属性和服务的对象划分为一类用类作为这些对象的抽象描述分类原则实际上是抽象原则运用于对象描述时的一种表现形式)
      - [（5）聚合](#5聚合)
        - [又称组装，其原则是：把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对复杂事物的描述。](#又称组装其原则是把一个复杂的事物看成若干比较简单的事物的组装体从而简化对复杂事物的描述)
      - [（6）关联](#6关联)
        - [是人类思考问题时经常运用的思想方法：通过一个事物联想到另外的事物。能使人发生联想的原因是事物之间确实存在着某些联系。](#是人类思考问题时经常运用的思想方法通过一个事物联想到另外的事物能使人发生联想的原因是事物之间确实存在着某些联系)
      - [（7）消息通信](#7消息通信)
        - [这一原则要求对象之间只能通过消息进行通信，而不允许在对象之外直接地存取对象内部的属性。通过消息进行通信是由于封装原则而引起的。在OOA中要求用消息连接表示出对象之间的动态联系。](#这一原则要求对象之间只能通过消息进行通信而不允许在对象之外直接地存取对象内部的属性通过消息进行通信是由于封装原则而引起的在ooa中要求用消息连接表示出对象之间的动态联系)
      - [（8）粒度控制](#8粒度控制)
        - [一般来讲，人在面对一个复杂的问题域时，不可能在同一时刻既能纵观全局，又能洞察秋毫。因此需要控制自己的视野：考虑全局时，注意其大的组成部分，暂时不详察每一部分的具体的细节；考虑某部分的细节时则暂时撇开其余的部分。这就是粒度控制原则。](#一般来讲人在面对一个复杂的问题域时不可能在同一时刻既能纵观全局又能洞察秋毫因此需要控制自己的视野考虑全局时注意其大的组成部分暂时不详察每一部分的具体的细节考虑某部分的细节时则暂时撇开其余的部分这就是粒度控制原则)
      - [（9）行为分析](#9行为分析)
        - [现实世界中事物的行为是复杂的。由大量的事物所构成的问题域中各种行为往往相互依赖、相互交织。](#现实世界中事物的行为是复杂的由大量的事物所构成的问题域中各种行为往往相互依赖相互交织)
    - [三种分析模型](#三种分析模型)
      - [1、对象模型](#1对象模型)
      - [2、动态模型](#2动态模型)
      - [3、功能模型(即用例模型作为输入)。](#3功能模型即用例模型作为输入)
    - [OOA主要优点](#ooa主要优点)
    - [基本步骤](#基本步骤)
      - [第一步，确定对象和类。](#第一步确定对象和类)
      - [第二步，确定结构（structure）。](#第二步确定结构structure)
      - [第三步，确定主题（subject）。](#第三步确定主题subject)
      - [第四步，确定属性（attribute）。](#第四步确定属性attribute)
      - [第五步，确定方法（method）。](#第五步确定方法method)
    - [面向对象](#面向对象-1)
      - [第一步是抽取建立领域的概念模型](#第一步是抽取建立领域的概念模型)
      - [第二步是构建完善系统结构：](#第二步是构建完善系统结构)
      - [第三步是利用“4＋1”视图描述系统架构](#第三步是利用41视图描述系统架构)
      - [第四步是性能优化](#第四步是性能优化)
  - [基本](#基本-1)
    - [类](#类)
      - [抽象类](#抽象类)
        - [抽象类是提供多个派生类共享基类的公共定义，](#抽象类是提供多个派生类共享基类的公共定义)
        - [抽象类的特点：](#抽象类的特点)
        - [对比父类中的虚方法(virtual)和抽象方法(abstract)的区别：](#对比父类中的虚方法virtual和抽象方法abstract的区别)
      - [属性](#属性)
      - [方法](#方法-1)
    - [对象](#对象)
    - [接口](#接口)
      - [接口是包含一组虚方法的抽象类型，](#接口是包含一组虚方法的抽象类型)
        - [(1). 接口不是类，里面可以包含属性、方法、事件，但不能包括字段和静态成员。](#1-接口不是类里面可以包含属性方法事件但不能包括字段和静态成员)
        - [(2). 接口只能包含没有实现的方法。](#2-接口只能包含没有实现的方法)
        - [(3). 子类实现接口，必须要实现该接口定义的所有方法，还要实现该接口从其他接口中继承的所有方法。](#3-子类实现接口必须要实现该接口定义的所有方法还要实现该接口从其他接口中继承的所有方法)
        - [(4). 接口不能被直接实例化，声明的对象只能使用接口中的方法，不能使用子类新增的方法。](#4-接口不能被直接实例化声明的对象只能使用接口中的方法不能使用子类新增的方法)
        - [(5). 同一个类可以实现多个接口。](#5-同一个类可以实现多个接口)
    - [关系](#关系)
      - [依赖（Dependency）：](#依赖dependency)
        - [两个事物间的语义关系，其中一个事物发生了变化会影响到另一个事物。](#两个事物间的语义关系其中一个事物发生了变化会影响到另一个事物)
      - [关联（Association）：](#关联association)
        - [是一种结构关系，它描述了一组链，链是对象之间的连接。比如一个人为一家公司工作（WorksFor），这里WorksFor就是一个关联。](#是一种结构关系它描述了一组链链是对象之间的连接比如一个人为一家公司工作worksfor这里worksfor就是一个关联)
      - [链接（link）：](#链接link)
        - [是对象之间物理上或概念上的连接。例如：张三为微软公司工作（WorksFor），这里WorksFor就是一个链接。](#是对象之间物理上或概念上的连接例如张三为微软公司工作worksfor这里worksfor就是一个链接)
      - [聚合（Aggregation）：](#聚合aggregation)
        - [其是一种特殊形式的关联。表示整体与部分的关系。比如项目组与其各成员之间的关系就是一种聚合关系。](#其是一种特殊形式的关联表示整体与部分的关系比如项目组与其各成员之间的关系就是一种聚合关系)
      - [组合关系（Composition）：](#组合关系composition)
        - [其也是一种特殊形式的关联。表示整体拥有各个部分，部分与整体共存。比如一个窗口是由文本框、列表框、菜单等组成的。关闭窗口，各个组成部分也相继消失，窗口与其各组成部分之间的关系便是组合关系。Ao对象中FeatureClass与Feature之间就是一种组合关系。](#其也是一种特殊形式的关联表示整体拥有各个部分部分与整体共存比如一个窗口是由文本框列表框菜单等组成的关闭窗口各个组成部分也相继消失窗口与其各组成部分之间的关系便是组合关系ao对象中featureclass与feature之间就是一种组合关系)
      - [泛化（Generalization）：](#泛化generalization)
        - [其是一种特殊/一般关系，特殊元素（子元素）/的对象可替代一般元素（父元素）的对象。也称为“Is a关系”。](#其是一种特殊一般关系特殊元素子元素的对象可替代一般元素父元素的对象也称为is-a关系)
      - [实现（Realization）：](#实现realization)
        - [是类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。](#是类元之间的语义关系其中一个类元指定了由另一个类元保证执行的契约)
      - [符号](#符号)
        - [Class1 \<|-- ClassA:泛化（子类继承父类）](#class1----classa泛化子类继承父类)
        - [Class2 \<-- ClassB:关联（成员变量）](#class2----classb关联成员变量)
        - [Class3 \*-- ClassC:组合（是整体与部分的关系，但部分不能离开整体而单独存在）](#class3----classc组合是整体与部分的关系但部分不能离开整体而单独存在)
        - [Class4 o-- ClassD:聚合（Aggregation 整体与部分）](#class4-o---classd聚合aggregation-整体与部分)
        - [Class5 \<|.. ClassE:实现（类实现接口）](#class5--classe实现类实现接口)
        - [Class6 \<.. ClassF:依赖（局部变量、方法的参数或者对静态方法的调用）](#class6--classf依赖局部变量方法的参数或者对静态方法的调用)
    - [面向对象的三大特征](#面向对象的三大特征)
      - [(1). 封装：将一些行为以类为单位进行包裹起来，](#1-封装将一些行为以类为单位进行包裹起来)
        - [　②：屏蔽细节，只要方法名不变，可以随意扩展。](#屏蔽细节只要方法名不变可以随意扩展)
        - [　①：保证数据安全（灵活使用private、public、protected进行控制）](#保证数据安全灵活使用privatepublicprotected进行控制)
        - [　③：代码重用](#代码重用)
      - [(2). 继承：通过继承，子类可以拥有父类的一切动作（如Student类继承People类）](#2-继承通过继承子类可以拥有父类的一切动作如student类继承people类)
      - [(3). 多态：多态有很多种。](#3-多态多态有很多种)
        - [①：通过不同子类继承同一个父类，实现多态](#通过不同子类继承同一个父类实现多态)
        - [　②：方法的重载本身就是一种多态](#方法的重载本身就是一种多态)
        - [　③：利用默认参数实现方法多态](#利用默认参数实现方法多态)
        - [　④：运行时的多态（里氏替换原则，声明父类对象，](#运行时的多态里氏替换原则声明父类对象)
    - [抽象类和接口的比较](#抽象类和接口的比较)
      - [相同点](#相同点)
        - [1. 都不能被直接实例化，都可以通过继承实现其抽象方法。](#1-都不能被直接实例化都可以通过继承实现其抽象方法)
        - [2. 都是面向抽象编程的技术基础，实现了诸多的设计模式。](#2-都是面向抽象编程的技术基础实现了诸多的设计模式)
      - [不同点](#不同点)
        - [1. 接口支持多继承；抽象类不能实现多继承。](#1-接口支持多继承抽象类不能实现多继承)
        - [2. 接口只能定义抽象规则；抽象类既可以定义规则，还可能提供已实现的成员。](#2-接口只能定义抽象规则抽象类既可以定义规则还可能提供已实现的成员)
        - [3. 接口是一组行为规范；抽象类是一个不完全的类，着重族的概念。](#3-接口是一组行为规范抽象类是一个不完全的类着重族的概念)
        - [4. 接口可以用于支持回调；抽象类不能实现回调，因为继承不支持。](#4-接口可以用于支持回调抽象类不能实现回调因为继承不支持)
        - [5. 接口只包含方法、属性、索引器、事件的签名，但不能定义字段和包含实现的方法；抽象类可以定义字段、属性、包含有实现的方法。](#5-接口只包含方法属性索引器事件的签名但不能定义字段和包含实现的方法抽象类可以定义字段属性包含有实现的方法)
        - [6. 接口可以作用于值类型和引用类型；抽象类只能作用于引用类型。例如，Struct就可以继承接口，而不能继承类。](#6-接口可以作用于值类型和引用类型抽象类只能作用于引用类型例如struct就可以继承接口而不能继承类)
      - [规则与场合](#规则与场合)
        - [1. 请记住，面向对象思想的一个最重要的原则就是：面向接口编程。](#1-请记住面向对象思想的一个最重要的原则就是面向接口编程)
        - [2. 借助接口和抽象类，23个设计模式中的很多思想被巧妙的实现了，我认为其精髓简单说来就是：面向抽象编程。](#2-借助接口和抽象类23个设计模式中的很多思想被巧妙的实现了我认为其精髓简单说来就是面向抽象编程)
        - [3. 抽象类应主要用于关系密切的对象，而接口最适合为不相关的类提供通用功能。](#3-抽象类应主要用于关系密切的对象而接口最适合为不相关的类提供通用功能)
        - [4. 接口着重于CAN-DO关系类型，而抽象类则偏重于IS-A式的关系；](#4-接口着重于can-do关系类型而抽象类则偏重于is-a式的关系)
        - [5. 接口多定义对象的行为；抽象类多定义对象的属性；](#5-接口多定义对象的行为抽象类多定义对象的属性)
        - [6. 接口定义可以使用public、protected、internal 和private修饰符，但是几乎所有的接口都定义为public，原因就不必多说了。](#6-接口定义可以使用publicprotectedinternal-和private修饰符但是几乎所有的接口都定义为public原因就不必多说了)
        - [7. 在接口中，所有的方法都默认为public。](#7-在接口中所有的方法都默认为public)
        - [8. “接口不变”，是应该考虑的重要因素。所以，在由接口增加扩展时，应该增加新的接口，而不能更改现有接口。](#8-接口不变是应该考虑的重要因素所以在由接口增加扩展时应该增加新的接口而不能更改现有接口)
        - [9. 尽量将接口设计成功能单一的功能块，以.NET Framework为例，IDisposable、IDisposable、IComparable、IEquatable、IEnumerable等都只包含一个公共方法。](#9-尽量将接口设计成功能单一的功能块以net-framework为例idisposableidisposableicomparableiequatableienumerable等都只包含一个公共方法)
        - [10. 接口名称前面的大写字母“I”是一个约定，正如字段名以下划线开头一样，请坚持这些原则。](#10-接口名称前面的大写字母i是一个约定正如字段名以下划线开头一样请坚持这些原则)
        - [11. 如果预计会出现版本问题，可以创建“抽象类”。例如，创建了狗（Dog）、鸡（Chicken）和鸭（Duck），那么应该考虑抽象出动物（Animal）来应对以后可能出现风马牛的事情。而向接口中添加新成员则会强制要求修改所有派生类，并重新编译，所以版本式的问题最好以抽象类来实现。](#11-如果预计会出现版本问题可以创建抽象类例如创建了狗dog鸡chicken和鸭duck那么应该考虑抽象出动物animal来应对以后可能出现风马牛的事情而向接口中添加新成员则会强制要求修改所有派生类并重新编译所以版本式的问题最好以抽象类来实现)
        - [12. 从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实实现。](#12-从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实实现)
        - [13. 对抽象类不能使用new关键字，也不能被密封，原因是抽象类不能被实例化。](#13-对抽象类不能使用new关键字也不能被密封原因是抽象类不能被实例化)
        - [14. 在抽象方法声明中不能使用 static 或 virtual 修饰符。（abstract 不能与static 或virtual一起用）](#14-在抽象方法声明中不能使用-static-或-virtual-修饰符abstract-不能与static-或virtual一起用)
      - [MSDN建议](#msdn建议)
        - [1. 如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单易行的方法来控制组件版本。通过更新基类，所有继承类都随更改自动更新。另一方面，接口一旦创建就不能更改。如果需要接口的新版本，必须创建一个全新的接口。](#1-如果预计要创建组件的多个版本则创建抽象类抽象类提供简单易行的方法来控制组件版本通过更新基类所有继承类都随更改自动更新另一方面接口一旦创建就不能更改如果需要接口的新版本必须创建一个全新的接口)
        - [2. 如果创建的功能将在大范围的全异对象间使用，则使用接口。抽象类应主要用于关系密切的对象，而接口最适合为不相关的类提供通用功能。](#2-如果创建的功能将在大范围的全异对象间使用则使用接口抽象类应主要用于关系密切的对象而接口最适合为不相关的类提供通用功能)
        - [3. 如果要设计小而简练的功能块，则使用接口。如果要设计大的功能单元，则使用抽象类。](#3-如果要设计小而简练的功能块则使用接口如果要设计大的功能单元则使用抽象类)
        - [4. 如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类。抽象类允许部分实现类，而接口不包含任何成员的实现。](#4-如果要在组件的所有实现间提供通用的已实现功能则使用抽象类抽象类允许部分实现类而接口不包含任何成员的实现)
        - [.NET Framework中关于接口和抽象类的使用：](#net-framework中关于接口和抽象类的使用)
  - [其他问题](#其他问题)
    - [OOA与OOD的区别](#ooa与ood的区别)
    - [面向对象与面向过程区别](#面向对象与面向过程区别)
      - [5.1、面向对象是将事物高度抽象化。](#51面向对象是将事物高度抽象化)
      - [5.2、面向过程是一种自顶向下的编程](#52面向过程是一种自顶向下的编程)
      - [5.3、面向对象必须先建立抽象模型，之后直接使用模型就行了。](#53面向对象必须先建立抽象模型之后直接使用模型就行了)
      - [5.4、面向过程(OP)和面向对象(OO)本质的区别在于分析方式的不同，最终导致了编码方式的不同。](#54面向过程op和面向对象oo本质的区别在于分析方式的不同最终导致了编码方式的不同)
  - [面向对象设计原则](#面向对象设计原则)
    - [1、单一职责原则 SRP](#1单一职责原则-srp)
    - [2、开闭原则 OCP](#2开闭原则-ocp)
    - [3、里氏代换原则 LSP](#3里氏代换原则-lsp)
    - [4、依赖倒转原则 DIP](#4依赖倒转原则-dip)
    - [5、接口隔离原则 ISP](#5接口隔离原则-isp)
    - [6、合成复用原则 CRP](#6合成复用原则-crp)
    - [7、迪米特法则（最少知道原则）DP](#7迪米特法则最少知道原则dp)
  - [Gof设计模式](#gof设计模式)
    - [行为型](#行为型)
      - [Iterator（迭代器模式）](#iterator迭代器模式)
      - [Interpreter（解析器模式）](#interpreter解析器模式)
      - [Observer（观察者模式）](#observer观察者模式)
      - [Mediator（中介者模式）](#mediator中介者模式)
      - [Visitor（访问者模式）](#visitor访问者模式)
      - [Memento（备忘录模式）](#memento备忘录模式)
      - [State（状态模式）](#state状态模式)
      - [Strategy（策略模式）](#strategy策略模式)
      - [Template Method（模板方法模式）](#template-method模板方法模式)
      - [Command（命令模式）](#command命令模式)
      - [Chain of Responsibility（职责链模式）](#chain-of-responsibility职责链模式)
    - [创建型](#创建型)
      - [Singleton（单例模式）](#singleton单例模式)
      - [Prototype（原型模式）](#prototype原型模式)
      - [Builder（建造者模式）](#builder建造者模式)
      - [Factory Method(工厂模式)](#factory-method工厂模式)
      - [ Abstract Factory（抽象工厂模式）](#abstract-factory抽象工厂模式)
    - [结构型](#结构型)
      - [Bridge（桥接模式）](#bridge桥接模式)
      - [Facade（外观模式）](#facade外观模式)
      - [Composite(组合模式)](#composite组合模式)
      - [Decorator(装饰模式)：](#decorator装饰模式)
      - [Adapter（适配器模式）](#adapter适配器模式)
      - [Proxy（代理模式）](#proxy代理模式)
      - [Flyweight（享元模式）](#flyweight享元模式)
    - [模式之间关系](#模式之间关系)
    - [其他](#其他)
    - [参考资料](#参考资料)
      - [23种设计模式UML图](#23种设计模式uml图)
- [UML](#uml)
  - [组成](#组成)
  - [架构视图分类](#架构视图分类)
  - [UML视图](#uml视图)
    - [UML视图](#uml视图-1)
      - [(1) 用例图(Use Case Diagram)，描述系统功能；](#1-用例图use-case-diagram描述系统功能)
      - [(2) 类图(Class Diagram)，描述系统的静态结构；](#2-类图class-diagram描述系统的静态结构)
        - [基本元素符号：](#基本元素符号)
        - [关　系：](#关系-1)
      - [(3) 对象图(Object Diagram)，描述系统在某个时刻的静态结构；](#3-对象图object-diagram描述系统在某个时刻的静态结构)
      - [(4) 组件图(Component Diagram)，描述了实现系统的元素的组织；](#4-组件图component-diagram描述了实现系统的元素的组织)
      - [(5) 配置图(Deployment Diagram)，描述了环境元素的配置，并把实现系统的元素映射到配置上；](#5-配置图deployment-diagram描述了环境元素的配置并把实现系统的元素映射到配置上)
      - [(6) 状态图(State Diagram)，描述了系统元素的状态条件和响应；](#6-状态图state-diagram描述了系统元素的状态条件和响应)
      - [(7) 时序图(Sequence Diagram)，按时间顺序描述系统元素间的交互；](#7-时序图sequence-diagram按时间顺序描述系统元素间的交互)
      - [(8) 协作图(Collaboration Diagram)，按照时间和空间顺序描述系统元素间的交互和它们之间的关系；](#8-协作图collaboration-diagram按照时间和空间顺序描述系统元素间的交互和它们之间的关系)
      - [(9) 活动图(Activity Diagram)，描述了系统元素的活动；](#9-活动图activity-diagram描述了系统元素的活动)
      - [Other](#other)
        - [包图](#包图)
        - [组合结构图](#组合结构图)
        - [轮廓图](#轮廓图)
        - [序列图](#序列图)
        - [通訊圖](#通訊圖)
        - [交互概览图](#交互概览图)
        - [时序图](#时序图)
        - [内部结构图](#内部结构图)
        - [协作使用图](#协作使用图)
        - [表现图](#表现图)
        - [网络体系结构图](#网络体系结构图)
        - [配置文件图](#配置文件图)
        - [信息流程图](#信息流程图)
        - [行为状态机图](#行为状态机图)
        - [协议状态机图](#协议状态机图)
        - [交互图](#交互图)
    - [分类](#分类-1)
      - [不同架构视图的应用](#不同架构视图的应用)
        - [(1) 用户模型视图](#1-用户模型视图)
        - [(2) 结构模型视图](#2-结构模型视图)
        - [(3) 行为模型视图](#3-行为模型视图)
        - [(4) 实现模型视图](#4-实现模型视图)
        - [(5) 环境模型视图](#5-环境模型视图)
      - [静态结构还是动态行为](#静态结构还是动态行为)
        - [静态结构](#静态结构)
        - [动态行为](#动态行为)
    - [4+1视图与UML视图对应](#41视图与uml视图对应)
      - [场景视图 use case](#场景视图-use-case)
      - [逻辑视图 类图](#逻辑视图-类图)
      - [开发视图 类图，组件图](#开发视图-类图组件图)
      - [进程视图 无完全对应](#进程视图-无完全对应)
      - [部署视图 部署图](#部署视图-部署图)
  - [词汇表和术语](#词汇表和术语)
    - [抽象类：一个永远不会被实例化的类。这个类的一个实例永远不会存在。](#抽象类一个永远不会被实例化的类这个类的一个实例永远不会存在)
    - [Actor（演员）：发起系统参与的事件的对象或人物。](#actor演员发起系统参与的事件的对象或人物)
    - [活动：活动图中的步骤或行动。表示系统或演员采取的行动。](#活动活动图中的步骤或行动表示系统或演员采取的行动)
    - [活动图：一个美化的流程图，显示了流程中的步骤和决定以及并行操作，如算法或业务流程。](#活动图一个美化的流程图显示了流程中的步骤和决定以及并行操作如算法或业务流程)
    - [聚合：是另一类的一部分。图中的包含类旁边有一个空心钻石。](#聚合是另一类的一部分图中的包含类旁边有一个空心钻石)
    - [工件：描述设计过程中某个步骤输出的文档。描述是图形，文字或其他组合。](#工件描述设计过程中某个步骤输出的文档描述是图形文字或其他组合)
    - [关联：一个模型的两个元素之间的联系。这可能代表代码中的成员变量，或者人员记录与其所代表的人之间的关联，或者两类工作人员之间的关系，或者任何类似的关系。默认情况下，一个关联中的两个元素是相等的，并且通过该关联知道对方。一个协会也可以是一个可导航的协会，这意味着协会的来源端知道目标端，但反之亦然。](#关联一个模型的两个元素之间的联系这可能代表代码中的成员变量或者人员记录与其所代表的人之间的关联或者两类工作人员之间的关系或者任何类似的关系默认情况下一个关联中的两个元素是相等的并且通过该关联知道对方一个协会也可以是一个可导航的协会这意味着协会的来源端知道目标端但反之亦然)
    - [关联类：表示两个其他类之间的关联信息的类。](#关联类表示两个其他类之间的关联信息的类)
    - [属性：可用于引用其他对象或保存对象状态信息的对象的特征。](#属性可用于引用其他对象或保存对象状态信息的对象的特征)
    - [基类：定义由子类通过泛化关系继承的属性和操作的类。](#基类定义由子类通过泛化关系继承的属性和操作的类)
    - [分支：活动图中的决策点。分支出现多个转变，每个都有一个保护条件。当控制到达分支时，恰好一个保护条件必须为真; 并且控制遵循相应的转换。](#分支活动图中的决策点分支出现多个转变每个都有一个保护条件当控制到达分支时恰好一个保护条件必须为真-并且控制遵循相应的转换)
    - [类：类似对象的类别，全部由相同的属性和操作描述，并且所有的赋值兼容。](#类类似对象的类别全部由相同的属性和操作描述并且所有的赋值兼容)
    - [类图：显示系统类和它们之间的关系。](#类图显示系统类和它们之间的关系)
    - [分类器 ：具有属性和操作的UML元素。具体来说，Actor，Classes和Interfaces。](#分类器-具有属性和操作的uml元素具体来说actorclasses和interfaces)
    - [协作：通信图中两个对象之间的关系，指示消息可以在对象之间来回传递。](#协作通信图中两个对象之间的关系指示消息可以在对象之间来回传递)
    - [通信图：显示如何在强调对象角色的同时完成操作的图表。](#通信图显示如何在强调对象角色的同时完成操作的图表)
    - [组件：系统中可部署的代码单元。](#组件系统中可部署的代码单元)
    - [组件图：显示各种组件和接口之间关系的图表。](#组件图显示各种组件和接口之间关系的图表)
    - [概念：要包含在域模型中的名词或抽象概念。](#概念要包含在域模型中的名词或抽象概念)
    - [构建阶段：Rational统一过程的第三阶段，在这个阶段中，正在构建的系统中内置了多个功能迭代。这是主要工作完成的地方。](#构建阶段rational统一过程的第三阶段在这个阶段中正在构建的系统中内置了多个功能迭代这是主要工作完成的地方)
    - [依赖关系：指示一个分类器的关系知道另一个分类器的属性和操作，但不直接连接到第二个分类器的任何实例。](#依赖关系指示一个分类器的关系知道另一个分类器的属性和操作但不直接连接到第二个分类器的任何实例)
    - [部署图：显示各种处理器之间关系的图表。](#部署图显示各种处理器之间关系的图表)
    - [域：系统所涉及的宇宙的一部分。](#域系统所涉及的宇宙的一部分)
    - [精化阶段：Rational统一过程的第二阶段，允许额外的项目计划，包括构建阶段的迭代。](#精化阶段rational统一过程的第二阶段允许额外的项目计划包括构建阶段的迭代)
    - [元素：出现在模型中的任何项目。](#元素出现在模型中的任何项目)
    - [封装：对象中的数据是私有的。](#封装对象中的数据是私有的)
    - [泛化：指示一个类是另一个类（超类）的子类。一个空心箭头指向超类。](#泛化指示一个类是另一个类超类的子类一个空心箭头指向超类)
    - [事件：在状态图中，这表示导致系统采取行动或切换状态的信号或事件或输入。](#事件在状态图中这表示导致系统采取行动或切换状态的信号或事件或输入)
    - [最终状态 ：在状态图或活动图中，这表示图完成的点。](#最终状态-在状态图或活动图中这表示图完成的点)
    - [叉：活动图中的一个点，多个并行控制线程开始。](#叉活动图中的一个点多个并行控制线程开始)
    - [泛化：继承关系，其中一个子类继承并添加到基类的属性和操作。](#泛化继承关系其中一个子类继承并添加到基类的属性和操作)
    - [高凝聚力：GRASP评估模式，确保课程不是太复杂，做不相关的功能。](#高凝聚力grasp评估模式确保课程不是太复杂做不相关的功能)
    - [低耦合：GRASP评估模式，衡量一个类别依赖于另一个类别或与另一个类别相关联。](#低耦合grasp评估模式衡量一个类别依赖于另一个类别或与另一个类别相关联)
    - [启动阶段：Rational统一过程的第一阶段，处理原始概念化和项目开始阶段。](#启动阶段rational统一过程的第一阶段处理原始概念化和项目开始阶段)
    - [继承：子类继承父类（超类）类的属性或特性。这些属性可以在子类中重写。](#继承子类继承父类超类类的属性或特性这些属性可以在子类中重写)
    - [初始状态：在状态图或活动图中，这表示图开始的点。](#初始状态在状态图或活动图中这表示图开始的点)
    - [实例：一个类像模板一样用来创建一个对象。这个对象被称为类的一个实例。可以创建任何数量的该类的实例。](#实例一个类像模板一样用来创建一个对象这个对象被称为类的一个实例可以创建任何数量的该类的实例)
    - [接口：定义形成行为契约的属性和操作的分类器。提供者类或组件可以选择实现接口（即实现其属性和操作）。客户端类或组件可以依赖于接口，并因此使用提供者而不提供提供者的真实类别的任何细节。](#接口定义形成行为契约的属性和操作的分类器提供者类或组件可以选择实现接口即实现其属性和操作客户端类或组件可以依赖于接口并因此使用提供者而不提供提供者的真实类别的任何细节)
    - [迭代：一个小项目部分，在这个小项目中，一小部分功能被添加到项目中。包括分析，设计和编码的开发循环。](#迭代一个小项目部分在这个小项目中一小部分功能被添加到项目中包括分析设计和编码的开发循环)
    - [加入：活动图中的一个点，多个并行控制线程同步并重新加入。](#加入活动图中的一个点多个并行控制线程同步并重新加入)
    - [成员：分类器中的属性或操作。](#成员分类器中的属性或操作)
    - [合并：活动图中的一个点，不同的控制路径汇集在一起​​。](#合并活动图中的一个点不同的控制路径汇集在一起)
    - [消息：从一个对象到另一个对象的请求，要求接收消息的对象执行某些操作。这基本上是对接收对象中的方法的调用。](#消息从一个对象到另一个对象的请求要求接收消息的对象执行某些操作这基本上是对接收对象中的方法的调用)
    - [方法：对象中的函数或过程。](#方法对象中的函数或过程)
    - [模型：中央UML神器。由各个元素组成的层次结构，以及元素之间的关系。](#模型中央uml神器由各个元素组成的层次结构以及元素之间的关系)
    - [多重性：显示在领域模型中，表示外部概念框，表示与其他对象的分位数的对象数量关系。](#多重性显示在领域模型中表示外部概念框表示与其他对象的分位数的对象数量关系)
    - [可导航性：指示关系的哪一端知道另一端。关系可以具有双向可导航性（每一端意识到另一端）或单向导航（一端意识到另一端，但反之亦然）。](#可导航性指示关系的哪一端知道另一端关系可以具有双向可导航性每一端意识到另一端或单向导航一端意识到另一端但反之亦然)
    - [符号：创建分析和设计方法的图形化文档。](#符号创建分析和设计方法的图形化文档)
    - [注意：文字注释已添加到图表中以更详细地解释图表。](#注意文字注释已添加到图表中以更详细地解释图表)
    - [对象：对象：在活动图中，从活动接收信息或向活动提供信息的对象。在“协作图”或“序列图”中，参与图中所示场景的对象。通常：给定分类器（Actor，Class或Interface）的一个实例或示例。](#对象对象在活动图中从活动接收信息或向活动提供信息的对象在协作图或序列图中参与图中所示场景的对象通常给定分类器actorclass或interface的一个实例或示例)
    - [包：逻辑上应该组合在一起的一组UML元素。](#包逻辑上应该组合在一起的一组uml元素)
    - [包图：所有元素都是包和依赖关系的类图。](#包图所有元素都是包和依赖关系的类图)
    - [模式：用于确定交互对象责任分配的解决方案。这是一个成功解决众所周知的常见问题的名称。](#模式用于确定交互对象责任分配的解决方案这是一个成功解决众所周知的常见问题的名称)
    - [参数：一个操作的参数。](#参数一个操作的参数)
    - [多态性：相同的消息，不同的方法。也用作模式。](#多态性相同的消息不同的方法也用作模式)
    - [私有：应用于属性或操作的可见性级别，指示只有包含该成员的分类器的代码才可以访问该成员。](#私有应用于属性或操作的可见性级别指示只有包含该成员的分类器的代码才可以访问该成员)
    - [处理器：在部署图中，代表可以部署代码的计算机或其他可编程设备。](#处理器在部署图中代表可以部署代码的计算机或其他可编程设备)
    - [受保护：应用于属性或操作的可见性级别，指示只有包含该成员或其子类的分类器的代码才能访问该成员。](#受保护应用于属性或操作的可见性级别指示只有包含该成员或其子类的分类器的代码才能访问该成员)
    - [公开：应用于属性或操作的可见性级别，指示任何代码都可以访问该成员。](#公开应用于属性或操作的可见性级别指示任何代码都可以访问该成员)
    - [读取方向箭头：指示领域模型中关系的方向。](#读取方向箭头指示领域模型中关系的方向)
    - [实现：表示组件或类提供给定的接口。](#实现表示组件或类提供给定的接口)
    - [角色：用于域模型，是关于角色角色的可选描述。](#角色用于域模型是关于角色角色的可选描述)
    - [顺序图：一个图表，显示随着时间的推移对象的存在，以及随着时间的推移在这些对象之间传递的消息来执行一些行为。状态图图 - 显示所有可能的对象状态的图。](#顺序图一个图表显示随着时间的推移对象的存在以及随着时间的推移在这些对象之间传递的消息来执行一些行为状态图图---显示所有可能的对象状态的图)
    - [状态：在状态图中，这表示系统或子系统的一种状态：它在某个时间点所做的事情，以及其数据的值。](#状态在状态图中这表示系统或子系统的一种状态它在某个时间点所做的事情以及其数据的值)
    - [状态图：显示系统或子系统的状态，状态之间的转换以及导致转换的事件的图表。](#状态图显示系统或子系统的状态状态之间的转换以及导致转换的事件的图表)
    - [静态：一个属性的修饰符，用于指示分类器的所有实例之间共享的属性只有一个副本。“操作”的修饰符，用于指示“操作”独立运行并且不在分类器的一个特定实例上操作。](#静态一个属性的修饰符用于指示分类器的所有实例之间共享的属性只有一个副本操作的修饰符用于指示操作独立运行并且不在分类器的一个特定实例上操作)
    - [刻板印象（Stereotype）：一个应用于Model元素的修饰符，用于指示它通常不能用UML表示的东西。从本质上讲，定型允许你定义你自己的UML“方言”。](#刻板印象stereotype一个应用于model元素的修饰符用于指示它通常不能用uml表示的东西从本质上讲定型允许你定义你自己的uml方言)
    - [子类：继承由子类通过泛化关系定义的属性和操作的类。](#子类继承由子类通过泛化关系定义的属性和操作的类)
    - [互動區：活动图的一个元素，指示系统或域的哪些部分执行特定的活动。泳道内的所有活动都由泳道所代表的对象，组件或者演员负责。](#互動區活动图的一个元素指示系统或域的哪些部分执行特定的活动泳道内的所有活动都由泳道所代表的对象组件或者演员负责)
    - [时间拳击：每次迭代都会有特定目标的时间限制。](#时间拳击每次迭代都会有特定目标的时间限制)
    - [过渡：在活动图中，表示从一个活动或分支或合并或分叉或连接到另一个的控制流程。在国家图中，代表着一个国家向另一个国家的转变。](#过渡在活动图中表示从一个活动或分支或合并或分叉或连接到另一个的控制流程在国家图中代表着一个国家向另一个国家的转变)
    - [过渡阶段 - Rational 统一过程的最后一个阶段，在这个阶段，用户接受使用新系统和系统的培训，用户可以使用这个阶段。](#过渡阶段---rational-统一过程的最后一个阶段在这个阶段用户接受使用新系统和系统的培训用户可以使用这个阶段)
    - [统一建模语言（ UML）：统一建模语言（ UML）利用文本和图形文档，通过在对象之间建立更紧密的关系，来增强软件项目的分析和设计](#统一建模语言-uml统一建模语言-uml利用文本和图形文档通过在对象之间建立更紧密的关系来增强软件项目的分析和设计)
    - [用例：在用例图中，表示系统响应来自Actor的某个请求所采取的操作。](#用例在用例图中表示系统响应来自actor的某个请求所采取的操作)
    - [用例图：显示参与者和用例之间关系的图表。](#用例图显示参与者和用例之间关系的图表)
    - [可见性：对属性或操作的修饰符，指示哪些代码可以访问成员。可见性级别包括公共，受保护和私有。](#可见性对属性或操作的修饰符指示哪些代码可以访问成员可见性级别包括公共受保护和私有)
    - [工作流程：一组产生特定结果的活动。](#工作流程一组产生特定结果的活动)
- [低代码平台](#低代码平台)
  - [Microsoft Platform](#microsoft-platform)
- [工业自动化](#工业自动化)
  - [工业自动化厂商](#工业自动化厂商)
    - [国产](#国产)
        - [汇川novance](#汇川novance)
    - [日系](#日系)
        - [欧姆龙Omron](#欧姆龙omron)
        - [三菱](#三菱)
        - [日立](#日立)
    - [欧系](#欧系)
        - [西门子](#西门子)
        - [施耐德](#施耐德)
        - [贝福BackOff](#贝福backoff)
    - [美系](#美系)
        - [通用电气GE](#通用电气ge)
        - [AB](#ab)
        - [罗克韦尔Rockwell](#罗克韦尔rockwell)
  - [工业阶段](#工业阶段)
  - [自动化软件](#自动化软件)
    - [TIA Portal](#tia-portal)
    - [控制器软件](#控制器软件)
    - [人机界面软件](#人机界面软件)
    - [SCADA软件](#scada软件)
    - [用于能源管理的软件](#用于能源管理的软件)
  - [常用工业软件分类](#常用工业软件分类)
  - [工业自动化设备](#工业自动化设备)
    - [变频器](#变频器)
    - [伺服](#伺服)
    - [可编程逻辑控制器](#可编程逻辑控制器)
    - [人机交互 HMI](#人机交互-hmi)
    - [传感器](#传感器-1)
    - [电机](#电机)
    - [PAC智能控制器](#pac智能控制器)
    - [CNC控制器](#cnc控制器)
    - [仪表](#仪表)
    - [基于PC的控制器](#基于pc的控制器)
    - [识别](#识别)
    - [工业机器人机械臂系统](#工业机器人机械臂系统)
    - [PLC(可编程逻辑控制器)](#plc可编程逻辑控制器)
        - [CPU](#cpu)
        - [扩展模块](#扩展模块)
        - [分类](#分类-2)
        - [其他](#其他-1)
        - [程序员语言](#程序员语言)
    - [其他](#其他-2)
        - [机器人](#机器人)
        - [HMI](#hmi)
        - [工业总线](#工业总线)
        - [IPC](#ipc)
    - [驱动类](#驱动类)
        - [伺服系统：](#伺服系统)
        - [子主题4](#子主题4)
        - [子主题3](#子主题3)
        - [变频器](#变频器-1)
    - [DCS（Distributed Control System）](#dcsdistributed-control-system)
        - [硬件](#硬件)
        - [软件](#软件)
        - [先进控制技术](#先进控制技术)
    - [CNC](#cnc)
        - [组成](#组成-1)
    - [SCADA](#scada)
        - [硬件](#硬件-1)
        - [软件](#软件-1)
        - [通信](#通信)
        - [系统构成](#系统构成)
    - [FCS（Fieldbus Control System）现场总线](#fcsfieldbus-control-system现场总线)
  - [工业现场总线](#工业现场总线)
    - [国产](#国产-1)
        - [EPA](#epa)
        - [G-link,](#g-link)
        - [Symotion](#symotion)
        - [NCUC-BUS](#ncuc-bus)
    - [IEC61158 Ed.3](#iec61158-ed3)
        - [Type 1 TS61158现场总线](#type-1-ts61158现场总线)
        - [Type 2 ControlNet和Ethernet/IP现场总线](#type-2-controlnet和ethernetip现场总线)
        - [Type 3 Profibus现场总线](#type-3-profibus现场总线)
        - [Type 4 P-NET现场总线](#type-4-p-net现场总线)
        - [Type 5 FF HSE现场总线](#type-5-ff-hse现场总线)
        - [Type 6 SwiftNet现场总线](#type-6-swiftnet现场总线)
        - [Type 7 World FIP现场总线](#type-7-world-fip现场总线)
        - [Type 8 Interbus现场总线](#type-8-interbus现场总线)
        - [Type 9 FF H1现场总线](#type-9-ff-h1现场总线)
        - [Type 10 PROFInet现场总线](#type-10-profinet现场总线)
    - [其他](#其他-3)
        - [1、PROFIBUS](#1profibus)
        - [2、EtherCAT](#2ethercat)
        - [3、Lightbus](#3lightbus)
        - [4、Interbus](#4interbus)
        - [5、CANopen](#5canopen)
        - [6、ControlNet ](#6controlnet)
        - [7、SERCOS interface](#7sercosinterface)
        - [8、Ethernet](#8ethernet)
        - [9、PROFINET](#9profinet)
        - [10、USB](#10usb)
        - [11、Modbus](#11modbus)
        - [12、RS232/RS485](#12rs232rs485)
        - [13、CC-Link](#13cc-link)
        - [14、AS-Interface](#14as-interface)
        - [15、LON](#15lon)
        - [16、EIB](#16eib)
        - [17、SNMP](#17snmp)
        - [18、QOS](#18qos)
        - [19、CAN](#19can)
        - [20、MECHATROLINK](#20mechatrolink)
    - [总线本质](#总线本质)
        - [通信网络](#通信网络)
        - [设备互联](#设备互联)
        - [互操作性](#互操作性)
        - [分散功能块](#分散功能块)
        - [通信线供电](#通信线供电)
        - [开放式互联网](#开放式互联网)
    - [发展趋势](#发展趋势)
        - [概要](#概要)
    - [主流](#主流)
        - [1、基金会现场总线（FoundationFieldbus 简称FF）](#1基金会现场总线foundationfieldbus-简称ff)
        - [2、CAN（ControllerAreaNetwork控制器局域网）](#2cancontrollerareanetwork控制器局域网)
        - [3、Lonworks](#3lonworks)
        - [4、DeviceNet](#4devicenet)
        - [5、PROFIBUS](#5profibus)
        - [6、HART ](#6hart)
        - [7、CC-Link](#7cc-link)
        - [8、WorldFIP](#8worldfip)
        - [9、INTERBUS](#9interbus)
        - [其他](#其他-4)
    - [控制组成](#控制组成)
        - [1、现场总线控制系统：](#1现场总线控制系统)
        - [2、现场总线的测量系统：](#2现场总线的测量系统)
        - [3、设备管理系统：](#3设备管理系统)
        - [4、总线系统计算机服务模式：](#4总线系统计算机服务模式)
        - [5、数据库：](#5数据库)
        - [6、网络系统的硬件与软件：](#6网络系统的硬件与软件)
    - [I/O接口](#io接口)
        - [基本功能](#基本功能)
        - [控制方式](#控制方式)
        - [现场接口分类](#现场接口分类)
  - [DCS](#dcs)
    - [硬件](#硬件-2)
    - [先进控制技术](#先进控制技术-1)
  - [SCADA](#scada-1)
  - [OPC软总线](#opc软总线)
      - [](#-1)
    - [常用的OPC客户端](#常用的opc客户端)
    - [OPC UA开源库](#opc-ua开源库)
      - [Openscada](#openscada)
        - [ConnectionInformation](#connectioninformation)
    - [OPC对象](#opc对象)
  - [PLC编程语言标准IEC61131-3](#plc编程语言标准iec61131-3)
- [西门子博图](#西门子博图)
  - [PLC编程](#plc编程)
    - [设备组态](#设备组态)
    - [在线和诊断](#在线和诊断)
    - [程序块](#程序块)
      - [组织块](#组织块)
      - [函数块](#函数块)
      - [函数](#函数)
      - [数据库](#数据库)
    - [程序语言](#程序语言)
      - [LAD](#lad)
      - [FBD](#fbd)
      - [SCL](#scl)
    - [工艺对象](#工艺对象)
      - [运动控制](#运动控制)
        - [轴（运动控制相关与PLCG关联）](#轴运动控制相关与plcg关联)
        - [轴控制](#轴控制)
      - [PID](#pid)
        - [PID\_Compact](#pid_compact)
        - [PID\_3Step](#pid_3step)
      - [SIMATIC Ident](#simatic-ident)
        - [TO\_Ident](#to_ident)
        - [TP\_TagLayout](#tp_taglayout)
      - [SINAMICS](#sinamics)
        - [TO\_BasicPos](#to_basicpos)
    - [PLC变量](#plc变量)
    - [数据类型](#数据类型)
    - [监控与强制表](#监控与强制表)
      - [监控表](#监控表)
        - [可以定义多个表](#可以定义多个表)
      - [强制表](#强制表)
        - [只有一份](#只有一份)
    - [设备代理数据](#设备代理数据)
      - [程序块](#程序块-1)
      - [工艺对象](#工艺对象-1)
      - [PLC变量](#plc变量-1)
      - [PLC监控和报警](#plc监控和报警)
    - [西门子S7Comm协议](#西门子s7comm协议)
  - [HMI编程](#hmi编程)
    - [设备组态](#设备组态-1)
    - [在线和诊断](#在线和诊断-1)
    - [运行系统配置](#运行系统配置)
    - [画面](#画面)
    - [画面管理](#画面管理)
      - [画面模板](#画面模板)
      - [全局画面](#全局画面)
    - [HMI变量](#hmi变量)
    - [连接](#连接)
    - [HMI报警](#hmi报警)
    - [配方](#配方)
    - [记录](#记录)
    - [计划任务](#计划任务)
    - [文本和图形列表](#文本和图形列表)
    - [用户管理](#用户管理)
  - [伺服](#伺服-1)
    - [设备组态](#设备组态-2)
    - [在线和诊断](#在线和诊断-2)
    - [参数](#参数)
    - [调试](#调试)
    - [验收测试](#验收测试-1)
    - [Traces](#traces)
  - [博途(V16)](#博途v16)
- [MBSE](#mbse)
  - [“系统”（System）](#系统system)
    - [SysML](#sysml)
    - [SysML与UML的关系](#sysml与uml的关系)
      - [用例图](#用例图)
      - [模块定义图](#模块定义图)
      - [内部模块图](#内部模块图)
      - [包图](#包图-1)
      - [参数图](#参数图)
      - [活动图](#活动图)
      - [序列图](#序列图-1)
      - [状态机图](#状态机图)
      - [需求图](#需求图)
    - [SysML的通用图形化表述](#sysml的通用图形化表述)
    - [SysML建模工具](#sysml建模工具)
    - [总结](#总结)
  - [“系统工程”（SE，Systems Engineering）](#系统工程sesystems-engineering)
  - [MBSE有什么用？](#mbse有什么用)
  - [建模](#建模)
    - [建模使用四种工具：](#建模使用四种工具)
    - [建模领域](#建模领域)
    - [系统建模语言](#系统建模语言)
    - [MBSE模型的四个象限](#mbse模型的四个象限)
  - [方法](#方法-2)
- [MES](#mes)
  - [智能制造四大阶段](#智能制造四大阶段)
  - [系统目标](#系统目标)
    - [管理目标](#管理目标)
    - [技术目标](#技术目标)
    - [应用目标](#应用目标)
  - [MES定义](#mes定义)
  - [业务模型](#业务模型)
    - [MES部分模块介绍](#mes部分模块介绍)
  - [MES的边界定义](#mes的边界定义)
  - [企业信息化层次模型](#企业信息化层次模型)

## 软件开发流程

### 可行性分析

### 需求分析

> > 《软件需求规格说明书》SRS

#### 1,需要明确项目的背景

> 1) 本项目解决了客户的什么问题？

> 2) 本项目涉及到什么人、什么单位？

> 3) 本项目的目标是什么？

> 4) 本项目的范围是怎样的？

> 5) 本项目的成功标准是什么？

#### 2,需求规格

> 功能性需求

> > 功能需求主要说明了系统实际应做到什么。这是用户最直观也是最主要的需求，如系统的输入输出、系统能完成的功能以及其它相关处理等；

> 非功能性需求

> > 非功能需求又称“约束”，它主要从各个角度对系统起约束和限制作用。如响应时间、存储效率、报表的规格和界面的样式等

> 领域需求

> > 域需求的来源不是用户，而是系统应用的领域，其主要反映了该领域的基本问题。例如勤工俭学管理系统，其领域需求就涉及到诸如应聘合同书、酬金发放及劳工考核等相关内容，如果这些需求得不到满足，系统就无法正常运行。值得一提的是，领域需求可能是功能需求，也可能是非功能需求。

#### 过程

> 可行性研究

> > 它指明现有的软件、硬件技术能否实现用户对系统的要求，从业务角度来决定系统开发是否可行以及在预算范围内能否开发出来。可行性研究的结果是清楚的回答：该系统是否值得开发

> 需求导出和分析

> > 这是一个通过对现有系统分析、与潜在客户讨论、进行任务分析等导出系统需求的过程，也可能需要开发一个或多个不同的系统原型，以帮助分析员了解所要描述的系统。

> 需求描述

> > 需求描述就是把在分析活动中收集的信息通过分析整理之后以文档的形式确定下来。该文档中有两类需求：用户需求是从客户和最终用户角度对系统需求的抽象描述；系统需求是对系统要提供的功能的详尽描述。

> 需求有效性验证

> > 主要是通过评审、验证等一系列活动来找出需求文档中的错漏并加以改正。

> 需求管理

> > 需求管理需求管理是一种系统化方法，可用于获取、组织和记录系统需求并使用户和开发方在系统变更需求上始终保持一致

#### 方法

> 功能分析方法

> > 功能分析法功能分解法以系统提供的功能为中心来组织系统。首先定义各种功能, 然后把功能分解为子功能, 同时定义功能之间的接口。数据结构是根据功能/子功能的需要设计的。 其基本策略是以分析员的经验为依据, 确定新系统所期望的处理步骤或子步骤, 然后, 将问题空间映射到功能和子功能上。

> 数据流方法

> > 数据流法也叫结构化分析, 其基本策略是研究问题域中数据如何流动以及在各个环节上进行何种处理, 从而发现数据流和加工。 问题域被映射为由数据流、加工以及文件、端点等成份构成的数据流图(DFD) , 并用数据字典对数据流和加工进行详细说明。这种方法的关键是动态跟踪数据流动。

> 信息建模方法

> > 信息建模法的核心概念是实体和关系, 主要工具是语义数据模型(实体关系图) , 其基本策略是找出现实世界的对象, 然后用属性来描述对象, 增添对象与对象之间的关系, 定义父类与子类, 用父类型/子类型提炼属性的共性, 用关联对象关系作细化的描述, 最后进行规范化处理。 其实质是将问题空间直接映射成模型中的对象。

> 面向对象方法

> > 面向对象分析 OOA(Object- Oriented Analysis) 的基本策略是通过信息隐藏将比较容易变化的元素隐藏起来, 分析员基于比较稳定的元素建立其思想和规格说明的总体结构。

> > 面向对象分析的主要特性是加强了对问题域( Problem Domain) 和系统责任( System Responsibili-ties)的理解; 改进与分析有关的各类人员之间的交流; 对需求的变化具有较强的适应性; 支持软件复用

> 面向本体方法

需求管理需求管理是一种系统化方法，可用于获取、组织和记录系统需求并使用户和开发方在系统变更需求上始终保持一致

> 形式化方法

形式化方法, 广义上讲, 是应用数学的手段来设计、 模拟和分析, 得到像数学公式那样精确的表示。从狭义上讲, 就是使用一种形式语言进行语言公式的形式推理, 用于检查语法的良构

性并证明某些属性。在需求分析阶段, 利用形式化方法得到需求规格说明书, 可以规范软件开发过程, 为获得更好的系统性能提供重要保证。

#### 需求分析的任务

> > 需求分析的主要任务是借助于当前系统的逻辑模型导出目标系统的逻辑模型，其流程如下：

> (1)  确定对系统的综合需求（功能、性能、运行、扩充需求）

> (2)  制作产品需求文档 (PRD)

> (3)  分析系统的数据需求（概念模型、数据字典、规范化）

> (4)  导出目标系统的详细的逻辑模型（数据流图、数据字典、主要功能描述）

> (5)  开发原形系统

> (6)  从PRD提取编制软件需求规格说明书（SRS）

### 架构设计

> 《软件架构设计说明书》

#### 定义

  定义 1：软件或计算机系统的软件架构是该系统的一个（或多个）结构，而结构由软件元素、元素的外部可见属性及它们之间的关系组成。 
    定义 2：软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式及这些模式的约束组成。 
    定义 3：软件架构是指一个系统的基础组织，它具体体现在：系统的构件，构件之间、构件与环境之间的关系，以及指导其设计和演化的原则上。（IEEE1471- 2000）    前两个定义都是按“元素—结构—架构”这一抽象层次来描述的，它们的基本意义相同，其中定义 1 较通俗，因此，本章采用这一定义。该定义中的“软件元素”是指比“构件” 更一般的抽象，元素的“外部可见属性”是指其他元素对该元素所做的假设，如它所提供的服务、性能特征等。 

##### 说明

  为了更好地理解软件架构的定义，特作如下说明： 
（1）	架构是对系统的抽象，它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象。因此，仅与内部具体实现有关的细节是不属于架构的，即定义强调元素的
“外部可见”属性。 
（2）	架构由多个结构组成，结构是从功能角度来描述元素之间的关系的，具体的结构传达了架构某方面的信息，但是个别结构一般不能代表大型软件架构。 
（3）	任何软件都存在架构，但不一定有对该架构的具体表述文档。即架构可以独立于架构的描述而存在。如文档已过时，则该文档不能反映架构。 
（4）	元素及其行为的集合构成架构的内容。体现系统由哪些元素组成，这些元素各有哪些功能（外部可见），以及这些元素间如何连接与互动。即在两个方面进行抽象：在静态方面，关注系统的大粒度（宏观）总体结构（如分层）；在动态方面，关注系统内关键行为的共同特征。 
（5）	架构具有“基础”性：它通常涉及解决各类关键的重复问题的通用方案（复用性），以及系统设计中影响深远（架构敏感）的各项重要决策（一旦贯彻，更改的代价昂贵）。 
（6）	架构隐含有“决策”，即架构是由架构设计师根据关键的功能和非功能性需求（质量属性及项目相关的约束）进行设计与决策的结果。不同的架构设计师设计出来的架构是不一样的，为避免架构设计师考虑不周，重大决策应经过评审。特别是架构设计师自身的水平是一种约束，不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路。 

##### 影响因素

（1）	影响架构的因素。软件系统的项目干系人（客户、用户、项目经理、程序员、测试人员、市场人员等）对软件系统有不同的要求开发组织（项目组）有不同的人员知识结构、架构设计师的素质与经验、当前的技术环境等方面都是影响架构的因素。 
这些因素通过功能性需求、非功能性需求、约束条件及相互冲突的要求，影响架构设计师的决策，从而影响架构。 
（2）	架构对上述诸因素具有反作用，例如，影响开发组织的结构。架构描述了系统的大粒度（宏观）总体结构，因此可以按架构进行分工，将项目组为几个工作组，从而使开发有序；影响开发组织的目标，即成功的架构为开发组织提供了新的商机，这归功于：系统的示范性、架构的可复用性及团队开发经验的提升，同时，成功的系统将影响客户对下一个系统的要求等。这种反馈机制构成了架构的商业周期。 

#### 开发质量属性

##### 运行期

###### 性能

###### 安全

###### 易用

###### 可伸缩

###### 互操作

###### 可靠

###### 持续可用

###### 鲁棒

在有些非正常情况下仍然能用

##### 开发期

###### 易理解性

###### 可扩展性

###### 可重用性

###### 可测试性

###### 可维护性

###### 可移植性

#### 模型

##### 结构模型

##### 框架模型

##### 动态模型

##### 过程模型

##### 功能模型

#### 4+1视图

#####  逻辑视图

##### 子主题6

##### 进程视图

##### 物理视图

##### 场景视图

### 概要设计

#### 把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口。生成《软件概要设计说明书》。

### 详细设计

#### 依据概要设计阶段的分解，设计每个模块内的算法、流程等。《软件详细设计说明书》

### 编码

#### 代码

### 测试

#### 黑盒

#### 白盒

### 验收

#### 《验收报告》

## 软件开发模式

### 软件开发模式

#### ATDD：验收测试驱动开发

> > （Acceptance Test Driven Development）

> 通过单元测试用例来驱动功能代码的实现，团队需要定义出期望的质量标准和验收细则，以明确而且达成共识的验收测试计划（包含一系列测试场景）来驱动开发人员的TDD实践和测试人员的测试脚本开发。面向开发人员，强调如何实现系统以及如何检验。

##### 什么是ATDD#

> 首先，ATDD不是一种测试方法论，而是一种开发方法论。

> UTDD涉及的人员仅仅是开发人员，那么ATDD仅仅涉及测试人员吗？不是，产品、开发、测试都需要参与到ATDD中来。

> 在ATDD活动中团队需要就需求定义出期望的质量标准和验收细则，以明确而且达成共识的验收测试计划（包含一系列测试场景）来驱动产品的代码开发和测试脚本开发。

> ATDD一定是基于测试自动化和持续集成的。

##### ATDD工具

> 1. Fit

> 2. Fitnesse

> 3. Exactor

> 4. TextTest

> 5. jWebUnit中提供的夹具

###### Selenium

###### Robot Framework

> Robot Framework（RF）是用于验收测试和验收测试驱动开发（ATDD）的自动化测试框架。 基于 Python 编写，但也可以在 Jython（Java）和 IronPython（.NET） 上运行，提供跨平台支持（Windows、Linux 或 MacOS ）。

##### ATDD的基本流程#

>和TDD的“红-绿-重构”类似，ATDD的流程也是类似的思路。

###### 讨论澄清阶段

> 全组参与的针对需求和方案的讨论

> 大家产出对需求和方案共同的理解

> 通过明确验收测试方式澄清我们的实现方案

> 验收测试方式将被自动化

###### 开发阶段

> 用明确具体的验收测试方式来指导开发工作

> 验收测试的自动化和特性的开发可以并行开展

> 全组成员对验收测试的自动化负责，而不仅仅是测试人员

> 最终，我们的产品实现能让所有的自动化测试通过

###### 交付阶段

> 我们要保证之前迭代所有的自动化验收测试能在新交付上通过

> 给所有利益相关者演示我们的新特性

> 收集反馈，讨论改进

##### ATDD的好处#

##### ATDD自动化测试框架

#### DDD：领域驱动开发

>（Domain Drive Design）

> 也就是领域驱动开发,DDD实际上也是建立在这个基础之上，因为它关注的是Service层的设计，着重于业务的实现,将分析和设计结合起来，不再使他们处于分裂的状态，建立一个具有业务伸缩性的模型。

##### 概念

> 实体（Entity）

> 值对象（Value Object）

> 服务（Service）

> 聚合（Aggregate）

> 聚合根（Aggregate Root）

> 工厂（Factory）

> 仓储（Repository）

##### 领域建模

> 实体、

> 值对象

> 服务

##### 生命周期

> 工厂

> 仓储

##### 软件系统架构风格

> 比较传统的常见的分层方式就是分三层：界面层、业务逻辑层以及数据访问层，各层之间会有数据传输对象（DTO）完成数据交互，以此隔离不同层内部的实现细节。领域驱动设计则将应用系统分为四层：用户界面层、应用层、领域层和基础设施层：

###### 经典分层架构（N-Tier Architecture）

> 用户界面层

> > 就是直接面向用户的前端应用。如果系统仅提供API，那么API这一层也属于用户界面层。

> 应用层

> > 它主要负责协调下层的执行任务，并隔离领域层与用户界面层。它们不参与任何领域或者业务相关的操作，仅仅负责协调。最常见的一种实现就是在应用层引入事务处理，有时候甚至还会跨资源实现分布式事务

> 领域层

> > 你的领域模型所涉及的所有对象都会出现在这一层，领域层对象需要尽量避免贫血模型，开发团队与领域专家一起完成领域层的设计与开发任务

> 基础设施层

> > 所有与技术细节相关的基础设施组件都属于这一层，此外还有面向切面（Aspect-Oriented）的组件，比如异常处理模块、缓存模块、安全模块等等，也都属于基础设施层

###### 事件驱动型架构（Event-Driven Architecture）


###### 微服务架构（Microservices Architecture）

> 在微服务架构中，各应用服务之间互相独立，它们可以由不同团队采用异构的平台和技术，这些服务可以使用不同的数据存储系统，甚至可以是一个仅进行数据实时处理而不存储任何数据的计算服务，微服务实例之间可以以同步或者异步的方式进行通讯。 

> 在微服务架构的官方网站上给出了四种将应用程序解构成多个微服务的模式：Decompose by business capability、Decompose by subdomain、Self-contained service以及Service per team。其中与领域驱动设计所对应的模式就是Decompose by subdomain，它要求设计者能够根据软件系统的业务领域来区分子领域，然后应用相关模式来确定微服务的划分，大致流程如下：

对业务领域进行分析，通过通用语言来描述业务领域中的关键概念和业务行为，并确定整个大的业务领域由哪些子领域（subdomain）构成
根据这些子领域来确定界定上下文（Bounded Context），每一个界定上下文会有一套独立的领域模型对子领域进行描述，界定上下文中的领域模型不会存在二义性
在界定上下文中建模，设计好领域模型以及各领域对象之间的关系
基于建立好的领域模型，划分微服务
在领域驱动设计中，界定上下文（有些文章将其翻译为“有界上下文”，意思相同）是实现通用语言的重要工具，很多情况下，有些词语或者句子在不同的上下文中会有不同的含义，界定上下文就定义了这样一个边界，它能使得在边界内的词语或者句子具有唯一明确的含义而不存在二义性。例如某公司生产产品然后卖给客户（Customer），然后会有另一个团队为这些客户（Customer）提供售后服务或技术支持。那么在这里我们有两个“客户”的概念，对于整个公司来说，它们表示的是同一个概念，然而在不同的上下文中，这个“客户”的概念又有所不同：在销售子领域中，“客户”表示产品销售的对象，因此会更多地关注它对产品的需求以及信用额度、交货方式等等；而在售后服务子领域中，“客户”表示提供服务的对象，因此会更多关注它的历史订单信息以及历史服务工单。从上面的基于Decompose by subdomain的基本流程来看，一旦区分并确定了整个领域中的界定上下文，也就基本上确定了应用系统中大致会有哪些微服务。 从领域模型上分析，界定上下文也不是绝对独立的，应该说绝大多数情况下不是。领域驱动设计引入了“上下文映射（Context Mapping）”来解决跨界定上下文的领域知识的交互。常用的方式可以是使负责不同子领域的团队之间达成共识、通过抽象手段来建立跨多个界定上下文的公共模型（Shared Kernel），或者引入防腐层（Anti-corruption Layer）来达到不同界定上下文之间无缝沟通的目的。这篇文章很好地介绍了这些内容。 这里限于文章篇幅，我仅仅简单地介绍了与领域驱动设计相关的要点，上面讨论的内容中的每一个点都可以继续展开讨论继续分析研究。你是不是已经开始考虑是否真的需要微服务架构了吧？因为是否采用微服务架构风格，以及微服务如何划分，将直接影响到今后你的业务系统的开发和演进是否真的能够帮你解决庞大的业务领域体量所带来的软件开发问题，而不是让你的架构变得逐渐臃肿不堪错误百出难以维护，给你带来无穷无尽的烦恼。 或许你的应用系统并没有那么大的业务领域体量，你也已经将你的业务领域划分成了多个微服务，那么接下来就是开发技术以及开发流程和团队管理的问题了。微服务架构真的有很多优点：由于整个业务领域被划分成多个子领域，由不同的微服务实现，因此这种架构风格具有非常好的延展性，并且可以根据需要来动态调配各个服务的运行资源。另一方面，在微服务架构中，通常都会由不同的团队来负责各个微服务的开发，这些团队可以选择合适的技术，采用自己的代码托管与分支策略，使用不同的软件开发过程来开展开发任务。如果团队采用敏捷开发过程，那么一个相对较小的团队能够更加高效地实践敏捷，使得微服务的开发能够不断向前迭代。微服务架构的另一个优点就是对于云平台的支持，虽然各个服务会采用不同技术运行在不同平台上，然而现在流行的容器化技术可以屏蔽这种应用层技术实现的差异，通过将各个服务封装成容器，使得整个应用系统可以非常方便地部署到云平台，并且非常方便地调用托管的云服务。 由于这种架构上的灵活性和分布式的特点，微服务架构也存在很多挑战：配置管理、服务发现、服务间通信、分布式事务（数据最终一致性的保证）、部署和测试复杂度、安全策略的实现等等，每一个技术难点都有可能成为你成功实践微服务架构的阻力。例如，异步通信是微服务间最为常见的通信机制之一，而大多数情况下，分布式事务就需要依赖于这种异步通信机制，而它一般都是基于事件消息的，所以，除了基本的事件消息框架的实现之外，各个微服务还需要考虑如何参与到这种分布式事务之中：如何在事务成功的时候提交变更，以及如何在事务失败的时候进行补偿操作。Saga体系结构模式就是一种实现跨服务事务的模式，它有两种实现方式：编排式和协调式，前者通过微服务之间互通领域事件来实现事务，而后者则是由一个中心化的协调器来接收来自各服务的领域事件，然后根据领域事件的处理结果来决定整个事务应该被接收还是被驳回。当某个事务参与的微服务比较少，并且处理逻辑不复杂的情况下，采用编排式的设计会比较简单；但如果参与的微服务和领域事件比较多，选择协调式的设计会使得结构更加清晰，而且不容易出错。目前有一些开发框架已经很好地实现了或者支持Saga模式，比如.NET下的NServiceBus框架，然而由于其过于复杂，学习成本比较高，因此应用范围也不是特别广。 值得一提的是，微服务架构之下各服务之间隔离度越高越好，虽然微服务架构本身并不强制要求每个服务都有自己的数据库，但是Database per service仍然是一个比较推荐的做法。前端的实现也是如此，开发团队可以有各自的前端开发人员来开发用于当前微服务的前端界面，然后通过某些微前端框架进行整合。 所以，微服务架构看上去比较先进、时尚，但是要想有效、正确地实践微服务架构却不是一件容易的事情。如果你的业务系统并没有大到需要拆分成多个子系统来进行设计，或者你的团队没有大到足以应对由这些微服务带来的技术复杂度，那么，你真的应该考虑一下，采用微服务的架构是否真的利大于弊。架构设计就是如此，没有对错，只有是否合理，整个过程就是平衡与取舍。 以下是微软官方的一个完整的微服务架构的案例：eShopOnContainers，代码开源，其业务领域是一个电商零售网站。它的架构图如下：

eShopOnContainers支持移动客户端、传统的基于ASP.NET Core MVC的浏览器客户端以及基于Angular的单页面应用（SPA）三种不同的客户端体验；在服务端，eShopOnContainers实现了面向mobile和面向web的两套API网关（API Gateway），所有的API请求都由这两套网关所代理，与后端的不同微服务进行通信。eShopOnContainers采用基于ASP.NET Identity的由IdentityServer4所实现的认证与授权机制，它是一个基于SQL Server数据库的传统的ASP.NET Core的服务。 在基于子领域的划分上，eShopOnContainers将其业务领域分为三个子领域：用于维护商品信息的Catalog子领域、用于处理订单的Ordering子领域以及用于管理购物篮信息的Basket子领域，因此，对应的微服务也就按子领域进行划分，各个微服务所采用的技术也完全不同：

Catalog微服务使用传统的Data Service/CRUD API模式，将Entity Framework Core的DbContext以构造器注入的方式注入控制器（Controller），然后在控制器中完成业务操作和数据访问，后台采用SQL Server数据库
Ordering微服务使用CQRS体系结构模式，它的运作完全基于领域事件，虽然它并非完全实现CQRS模式的所有细节，但已经足够实现它的业务逻辑，并且它的复杂度也得到了很好的控制，它后台也是采用SQL Server数据库
Basket微服务使用基于领域驱动设计的分层模式，它引入了领域模型、仓储等概念，并将仓储的实例通过构造器注入的方式注入控制器，然后让控制器充当领域驱动设计中应用层的角色，完成业务处理和领域模型的重建和持久化，后台采用Redis缓存作为数据持久化机制
这些微服务之间通过RabbitMQ（或者Azure Service Bus）的事件总线（Event Bus）完成通信，以编排式的Saga模式实现了基本的分布式事务，整个后端架构都是容器化的，运行在容器编排集群中（docker-compose或者Kubernetes）。 由此可见，在微服务的架构风格中，领域驱动设计能够被更加灵活地运用，由于不同的微服务是由不同的团队负责开发，因此就可以在不同的微服务中，以不同的程度来引入领域驱动设计的思想以辅助解决业务分析与系统开发中的难点，最终达到整个软件架构的良性发展。 软件架构风格大致就介绍这些吧，涉及的内容确实很多，也没有办法在一篇文章里完全写完，以后有机会再深入补充吧。


#### TDD(UTDD)：测试驱动开发

> （Test-Driven Development）

> TDD核心可看做一个闭环：RED -> GREEN -> REFACTOR，即运行一个失败的测试 -> 让测试通过 -> 及时重构代码。

##### 测试驱动开发是敏捷开发中的一项核心实践和技术，

> 也是一种设计方法论，TDD首先考虑使用需求（对象、功能、过程、接口等），主要是编写测试用例框架对功能的过程和接口进行设计，而测试框架可以持续进行验证。

##### TDD流程

> 写一个测试用例

> 运行测试

> 写刚好能让测试通过的实现

> 运行测试

> 识别坏味道，用手法修改代码

> 运行测试

##### TDD 的三条规则

> 除非是为了使一个失败的 unit test 通过，否则不允许修改任何产品代码

> 在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）

> 只允许编写刚好能够使一个失败的 unit test 通过的产品代码

##### 好的单元测试应该符合几条原则：

> 简单，只测试一个需求

> 符合 Given-When-Then 格式

> 速度快

> 包含断言

> 可以重复执行

##### TDD 编码方式

> 先分解任务，分离关注点（后面有演示）

> 列 Example，用实例化需求，澄清需求细节

> 写测试，只关注需求，程序的输入输出，不关心中间过程

> 写实现，不考虑别的需求，用最简单的方式满足当前这个小需求即可

> 重构，用手法消除代码里的坏味道

> 写完，手动测试一下，基本没什么问题，有问题补个用例，修复

> 转测试，小问题，补用例，修复

> 代码整洁且用例齐全，信心满满地提交

##### TDD（测试驱动开发）相关测试框架

> 1.  XUnit：相应于各语言的测试框架

> 2. EasyMock：模拟接口或类行为

> 3. DBUnit：数据库测试

> 4. Spring-test：提供数据库集成测试

> 5. 基于请求的web作测试

> > （1）Spring-mock：可以mock浏览器请求等

> > （2）JspTest：测试jsp页面

> 6. 基于控件的web作测试

> > （1）WicketTester

> > （2）Apache Shale

> 7. Apache commons VFS：虚拟文件系统，对文件系统进行模拟

> 8.  HttpUnit：http测试

> 9. Jemmy和Abbot：测试驱动开发Swing

> 10. H sqldb：内存数据库，模拟真实数据库

> 11. Dbdeploy：数据库结构的增量变动

> 12. GSBase：equals和hashcode测试

> 13. BeanInject：可以将测试替身强行赋给某个类的私有变量

> 14.  JFCUnit：JFC类测试

> 15.  ConTest：Java并发单元测试

> 16. XMLUnit：测试xml结构及内容

> 17. JUnitPerf：性能测试

##### 测试驱动开发的基本过程

> 1） 明确当前要完成的功能。可以记录成一个 TODO 列表。 

> 2） 快速完成针对此功能的测试用例编写。 

> 3） 测试代码编译不通过。

> 4） 编写对应的功能代码。

> 5） 测试通过。 

> 6） 对代码进行重构，并保证测试通过。

> 7） 循环完成所有功能的开发。

##### 测试驱动开发的原则

> 1）测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。

> 2）一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。

> 3）测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。

> 4）测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。

> 5）先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。

> 6）可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。

#### BDD：行为驱动开发

>  （Behavior Driven Development）

## 概要设计

> 把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口，模块的调用关系，每个模块的功能等等。

### 概要设计就是设计软件的结构

> 包括组成模块

> 模块的层次结构

> 设计该项目的应用系统的总体数据结构和数据库结构

> 每个模块的功能等等。

### 与详细设计区别

> 概要设计关注模块间的数据交互和算法，详细设计关注模块内部的数据交互和算法

> 根据概要设计赋予的局部任务和对外接口，设计并表达出模块的算法、流程、状态转换等内容

> 概要设计文档相当于机械设计中的装配图，而详细设计文档相当于机械设计中的零件图。

> 其实，面向对象的分析、设计方法并没有强调结构化方法那样的阶段性，

> 因此一般不引入概要、详细设计的概念。

> 如果按照公司的文档体系，非要有这种分工的话，可以将包的划分、类及对象间的关系、类的对外属性、方法及协作设计看做 概要设计；类属性、方法的内部实现看做详细设计。

> 概要设计中较顶层的部分便是所谓的方案。方案文档的作用是在宏观的角度上保持设计的合理性。

### 概要设计怎么做

> 详细阅读需求规格说明书，理解系统建设目标、业务现状、现有系统、客户需求的各功能说明；

> >   分析数据流图，弄清数据流加工的过程；

> >   根据数据流图决定数据处理问题的类型（变换型、事务型、其他型）；

> >   通过以上分析，推导出系统的初始结构图；

> >   对初始结构图进行改进完善：

> > >所有的加工都要能对应到相应模块（模块的完整性在于他们完成了需求中的所有加工），消除完全相似或局部相似的重复功能（智者察同），理清模块间的层次、控制关系，减少高扇出结构，随着深度增大扇入，平衡模块大小。

> >   由对数据字典的修改补充完善，导出逻辑数据结构，导出每种数据结构上的操作，这些操作应当属于某个模块。

> >   确定系统包含哪些应用服务系统、客户端、数据库管理系统；

> >   确定每个模块放在哪个应用服务器或客户端的哪个目录、哪个文件（库），或是在数据库内部建立的对象。

> >   对每个筛选后的模块进行列表说明。

> >   对逻辑数据结构进行列表说明。

> >   根据结构化软件设计说明书结构对其他需要说明的问题进行补充说明，形成概要设计说明书。

### 设计组成部分概述

>  4.1 简述

> >   这部分要求突出整个设计所采用的方法（是面向对象设计还是结构化设计）、系统的体系结构（例如客户/服务器结构）以及使用到的相应技术和工具（例如OMT、Rose）

>   4.2 系统结构设计

> >   这部分要求提供高层系统结构（顶层系统结构、各子系统结构）的描述，使用方框图来显示主要的组件及组件间的交互。最好是把逻辑结构同物理结构分离，对前者进行描述。别忘了说明图中用到的俗语和符号。

>   4.3 系统界面

> >   各种提供给用户的界面以及外部系统在此处要予以说明。如果在需求规格说明书中已经对用户界面有了叙述，此处不用再重复，可以指引读者参考需求说明。如果系统提供了对其它系统的接口，比如说从其它软件系统导入/导出数据，必须在此说明。

>   4.4 约束和假定

> >   描述系统设计中最主要的约束，这些是由客户强制要求并在需求说明书写明的。说明系统是如何来适应这些约束的。

> >   另外如果本系统跟其它外部系统交互或者依赖其它外部系统提供一些功能辅助，那么系统可能还受到其它的约束。这种情况下，要求清楚地描述与本系统有交互的软件类型以及这样导致的约束。

> >   实现的语言和平台也会对系统有约束，同样在此予以说明。

> >   对于因选择具体的设计实现而导致对系统的约束，简要地描述你的想法思路，经过怎么样的权衡，为什么要采取这样的设计等等。

>   5 对象模型

> >   提供整个系统的对象模型，如果模型过大，按照可行的标准把它划分成小块，例如可以把客户端和服务器端的对象模型分开成两个图表述。在其中应该包含所有的系统对象。这些对象都是从理解需求后得到的。要明确哪些应该、哪些不应该被放进图中。所有对象之间的关联必须被确定并且必须指明联系的基数。聚合和继承关系必须清楚地确定下来。每个图必须附有简单的说明。

>   6 对象描述

> >   在这个部分叙述每个对象的细节，它的属性、它的方法。在这之前必须从逻辑上对对象进行组织。你可能需要用结构图把对象按子系统划分好。

> >   为每个对象做一个条目。在系统对象模型中简要的描述它的用途、约束（如只能有一个实例），列出它的属性和方法。如果对象是存储在持久的数据容器中，标明它是持久对象，否则说明它是个临时对象（transient object）。

> >   对每个对象的每个属性详细说明：名字、类型，如果属性不是很直观或者有约束（例如，每个对象的该属性必须有一个唯一的值或者值域是有限正整数等）。

> >   对每个对象的每个方法详细说明：方法名，返回类型，返回值，参数，用途以及使用的算法的简要说明（如果不是特别简单的话）。如果对变量或者返回值由什么假定的话，Pre-conditions和Post-conditions必须在此说明。列出它或者被它调用的方法需要访问或者修改的属性。最后，提供可以验证实现方法的测试案例。

>   7 动态模型

> >   这部分的作用是描述系统如何响应各种事件。一般使用顺序图和状态图。

> >   顺序图：描述各种事件及事件发生的相对时间顺序。

>   7.1 场景（Scenarios）

> >   对每个场景做一则条目，包括以下内容：

> >   场景名：给它一个可以望文生义的名字

> >   场景描述：简要叙述场景是干什么的以及发生的动作的顺序。

> >   确定不同的场景（Scenario）是第一步，不需要确定所有可能的场景，但是必须至少要覆盖典型的系统用例。不要自己去想当然地创造场景，通常的策略是描述那些客户可以感受得到的场景。

>   7.2 状态图

> >   这部分的内容包括系统动态模型重要的部分的状态图。可能你想为每个对象画一个状态图，但事实上会导致太多不期望的细节信息，只需要确定系统中一些重要的对象并为之提供状态图即可。

>   8 非功能性需求

> > 与功能无关的需求，比如系统性能，执行时间，运行稳定性等。

### 概要设计的任务

>  制定规范：代码体系、接口规约、命名规则。这是项目小组今后共同作战的基础，有了开发规范和程序模块之间和项目成员彼此之间的接口规则、方式方法，大家就有了共同的工作语言、共同的工作平台，使整个软件开发工作可以协调有序地进行。

>   总体结构设计：

>   功能（加工）－>模块：每个功能用那些模块实现，保证每个功能都有相应的模块来实现；

>   模块层次结构：某个角度的软件框架视图；

>   模块间的调用关系：模块间的接口的总体描述；

>   模块间的接口：传递的信息及其结构；

>   处理方式设计：满足功能和性能的算法

>   用户界面设计；

>   数据结构设计：

>   详细的数据结构：表、索引、文件；

>   算法相关逻辑数据结构及其操作；

>   上述操作的程序模块说明（在前台？在后台？用视图？用过程？······）

>   接口控制表的数据结构和使用规则

>   其他性能设计。

### 概要设计的目的

> 将软件系统需求转换为未来系统的设计；

>   逐步开发强壮的系统构架；

>   使设计适合于实施环境，为提高性能而进行设计；

>   结构应该被分解为模块和库。

### 问题的提出

>  概要设计写什么？概要设计怎么做？

>   如何判断设计的模块是完整的？

>   为什么说设计阶段过于重视业务流程是个误区？

>   以需求分析文档还是以概要设计文档来评估开发工作量、指导开发计划准确？

>   结构化好还是面向对象好？

>   以上问题的答案请在文章中找。

### 概要设计的原则

> 总体原则和方法：由粗到细的原则，互相结合的原则，定性分析和定量分析相结合的方法，分解和协调的方法和模型化方法。

>   要系统考虑系统的一般性、关联性、整体性和层次性。

>   分解协调：目的是为了创造更好的系统。系统分解是指将一个复杂的系统分解为若干个子系统，系统协调一是系统内协调，即根据系统的总结构、总功能、总任务和总目标的要求，使各个子系统之间互相协调配合，在各个子系统局部优化基础上，通过内部平衡的协调控制，实现系统的整体优化；

>   屏蔽抽象：从简单的框架开始，隐含细节；

>   一致性：统一的规范、统一的标准、统一的文件模式；

>   每个模块应当有一个统一命名的容易理解的名字；

>   编码：由外向内（界面－>核心）；

>   面向用户：概要设计是对于按钮按下后系统“怎么做”的简要说明；

>   模块、组件的充分独立性、封闭性；

>   同时考虑静态结构与动态运行；

>   每个逻辑对象都应当说明其所处物理对象（非一一对应）；

>   每个物理对象都有合适的开发人员，并且利于分工与组装。（详细说明见本人另一篇文章：系统构架设计应考虑的因素）；

>   确立每个构架视图的整体结构：视图的详细组织结构、元素的分组以及这些主要分组之间的接口；

>   软件构架与使用的技术平台密切相关，目前常用的平台有J2EE、.NET、CORBA等等，因此具体的软件构架人员应当具备使用这些平台的软件开发经验；

>   通过需求功能与设计模块之间的列表对应，检查每个需求功能是否都有相应的模块来实现，保证需求功能的可追溯性和需求实现（模块）的完整性，同时可以检查重复和不必要的模块。

>   在需求调研分析过程中对业务处理过程了解的完整性和准确性非常重要。

### 概要设计的重要输出

>  编码规范

> > 信息形式、接口规约、命名规则

>   物理模型

> > 组件图

> > 配置图

>   不同角度的构架视图（可选）；

> > 用例视图

> > 逻辑视图

> > 进程视图

> > 部署视图

> > 实施视图

> > 数据视图

>   系统总体布局：

> > 哪些部分组成

> > 各部分在物理上

> > 逻辑上的相互关系

>   两个不可忽视的输出逻辑与物理位置

> 每个对象在逻辑上分别落在哪一层、哪个模块、哪个类；

>   与需求功能的关系：对于需求中的每一个功能，用哪一层、哪个模块、哪个类、哪个对象来实现（一对多关系）；

## 详细设计

### 发现很多共性的内容，需要提炼为整个程序需要遵循的设计规范

> 1）用户体验设计；（下一篇再详细介绍）

> 2）输入合法性判定；

> 3）批量数据的传输约定；

> 4）实体类的生命周期；

> 5）逻辑类的生命周期；

> 6）并发冲突的处理原则，包括判定办法、提示办法；

> 7）连接打开、关闭原则；

> 8）采用事务的原则；

> 9）异常处理机制；

> 10）日志记录机制；

### 目的

> 对概要设计的进一步细化，一般由各部分的担当人员依据概要设计分别完成，然后在集成，是具体的实现细节。是“程序”的蓝图，确定每个模块采用的算法、数据结构、接口的实现、属性、参数。
搞清楚“每个模块怎么做”。并输出《软件详细设计说明书》。

### 软件需求分析人员组织

#### 软件需求分析其根本性问题是理解用户功能需求，由此软件需求分析实际上是与客户间交流过程完成的目标。要求我们组织适当的参与人员进行交流活动。

需求分析是一个综合团队的工作，是在需求分析理论的指导下，对用户需要进行渐进方式逐步深化；通过不断变化方式形成具体约束；努力实现需求功能目标形成特色效果的商业化产品。需求分析是一个商业行为，完全是一个商业化操作，要求有商业、技术等结合的团队共同合作，解决需求和设计的同步，设计符合需求。

项目涉及内容，项目大小都需要我们考虑参加软件需求分析工作团退的人数，配置合理的参与人员。一般我们必须有商务活动人员，项目管理人员，设计技术人员等参加，而且要求组织人员必须明确负责范围，以及明确工作目标，保证实施的有效性。

### 定义

#### 软件需求分析（Software Reguirement Analysis）是研究用户需求得到的东西，完全理解用户对软件需求的完整功能，确认用户软件功能需求，建立可确认的、可验证的一个基本依据。

软件需求分析是一个项目的开端，也是项目实施最重要的关键点。据有关的机构分析结果表明，我们设计的软件产品存在不完整性、不正确性等问题80％以上是需求分析错误所导致的，而且由于需求分析错误造成根本性的功能问题尤为突出。因此，一个项目的成功软件需求分析是关键的一步。

### 软件需求分析理论

#### 如果我们用数学方法来描述软件需求分析，可以将一个应用软件定义为S，可能应用软件涉及功能性问题非常广，我们用抽象化理论分析，可以划分为各个功能域，可以用D1、D2、… Dn表示，那么，我们可以用一个表达式描述为

S={D1，D2，D3，…Dn}
但是，功能域Di依然存在着有若干个问题P1、P2、P3、… Pm组成，并且每个功能对应于子系统中的一个软构件，我们可以表示为
     Di={P1，P2，P3，…Pm}
同样，功能Pj有若干个行为F1、F2、F3、… Fk，每个行为对应于软构件中的实现方法

Pj={F1，F2，F3，…Fk}

一个软件包含了所有功能的集合，同时包含了实现所有功能的所有方法和算法描述。需求分析是依据于用户需求，经过需求问题识别，进行分析、消化与综合，制订规格说明，评审，分为四个阶段，形成用户需求与设计同步，设计满足用户需求目标。

需求分析方法始终贯穿着吸收、同化、贯彻方法和手段，用商业化行为解决需求与实现中存在的矛盾，解决用户需求与商业化产品融通，解决规范与个性化追求。

### 主要实现目标

#### 1）对实现软件的功能做全面的描述，帮助用户判断实现功能的正确性、一致性和完整 性，促使用户在软件设计启动之前周密地、全面地思考软件需求；

#### 2）了解和描述软件实现所需的全部信息，为软件设计、确认和验证提供一个基准；

#### 3）为软件成本计价和软件开发计划提供依据；

#### 需求分析具体内容可以归纳为六个方面：

##### 软件的功能需求

##### 软件与硬件或其他外部系统接口

##### 软件的非功能性需求

##### 软件的反向需求

##### 软件设计和实现上的限制

##### 阅读支持信息

#### 软件需求分析应尽量提供软件实现功能需求的全部信息，使得软件设计人员和软件测试人员不再需要需求方的接触。这就要求软件需求分析内容应正确、完整、一致和可验证。此外，为保证软件设计质量，便于软件功能的休整和验证，软件需求表达无岔意性，具有可追踪性和可修改性。

### 软件功能需求

#### 软件的功能需求是整个需求分析最主要、最关键和最复杂的部分，它描述软件的各种可能的条件下，对所有可能输入的数据信息，应完成那些具体功能，产生什么样的输出。描述软件功能需求是应注意下面几点：

#### 1）功能需求的完整性和一致性

##### 对功能的描述应包含与功能相关的信息，并应具有内在的一致性（即各种描述之间不矛盾、不冲突）。应注意以下几点：

##### （1）    给出触发功能的各种条件（如：控制流、运行状态、运行模式等）；

##### （2）    定义各种可能性条件下的所有可能的输入（包括合法的输入空间和非法的输入空间）；

##### （3）    给出各种功能间可能的相互关系（如各个功能间的控制流、数据流、信息流，功能运行关系：顺序、重复、选择、并发、同步）；

##### （4）    给出功能性的主要级别（如：基本功能、可由设计者选择逐步实现的功能、可由设计者改变实现的功能等）；

##### （5）    尽可能不使用“待定”这样的词。所有含有待定内容的需求都不是完整的文件，如果出现待定的部分，必须进行待定部分内容说明，落实负责人员、落实实施日期。

#### 2）功能描述的无岔意性和可追踪性

##### 需求功能描述的无岔意性、可追踪性和规范化：

##### （1）    功能描述必须清晰地描述出怎样输入到怎样输出，并且输入、输出描述应对应有数据流描述、控制流描述图，这些描述必须与其它地方描述一致；

##### （2）    可以用语言、方程式、决策表、矩阵或图等对功能的描述。如果选用语言描述必须使用结构化的语言，描述前必须说明该步骤（或子功能）的执行是顺序，选择，重复，还是并发，然后说明步骤逻辑。整个描述必须单入单出。

##### （3）    描述时，每一个功能名称和参照编号必须唯一，且不要将多个功能混在一起进行描述，这样便于功能的追踪和修改。

##### （4）    功能描述应注意需求说明和程序设计的区别。需求设计仅仅是软件的功能设计，它给出软件运行的的外部功能描述，以及为了实现这一外部功能必须做哪些事情（采用和种数据结构，定义多个模块，接口间的接口等）是设计阶段的事情，功能描述不应涉及到那些细节问题，以避免给软件设计带来不必要的约束。

#### 2.2、      软件与硬件或其他外部系统接口

##### （4）    通讯接口：指定通讯接口和通讯协议等描述。

##### 软件与硬件或其它外部系统接口包括下述内容：

##### （1）    人机接口：说明输入、输出的内容、屏幕安排、格式等要求；

##### （2）    硬件接口：说明端口号，指令集，输入输出信号的内容与数据类型，初始化信号源，传输通道号和信号处理方式。

##### （3）    软件接口：说明软件的名称、助记符、规格说明、版本号和来源；

#### 2.3、      软件的非功能性需求

##### 软件非功能性需求是指软件性能指标，容限等功能以外的需求。一般指下述内容：

##### （1）    时间需求：输入、输出频率，输入、输出响应时间，各种功能恢复时间等；

##### （2）    处理容限、精度、采样参数的分辨率，误差处理等；

##### （3）    可靠性的MTBF要求，可维护性、安全性要求等。（对可能的不正常的输入给以正常响应是可靠性的重要内容，这属于功能性需求。）

#### 2.4、      软件反向需求

##### 软件的反向需求描述软件在那些情况下不能做什么。这一条是随软件实际要求而定。有两类情形需要采用反向需求的形式。第一种情况：某些用户需求适宜采用反向形式说明，如数据安全性要求属于这类形式。第二种情况：对一些可靠性和安全性要求较高的软件，有些必须描述软件不能做些什么。如控制点火时序，我们必须交代清楚在那些情况下不能点火，否则会造成故障。

#### 2.5、      软件设计和实现上的限制

##### 软件设计和实现上的限制主要指对软件设计者的限制。如软件运行环境的限制（选择计算机类型，使用配置，操作系统的限制等）、设计工具的限制（使用语言、执行的标准）和保密要求等。

#### 2.6、      阅读支持信息

##### 这部分内容是为了更好的帮助我们理解用户需求，也是为了使需求便于修改和追踪。其本身并不是对需求的描述，但它影响到需求分析的可读性，也属于需求分析的一个重要部分。一般目录、需求背景信息、内容索引、交叉引用表、注释等均属于这个部分的内容。

### 软件需求分析方法

#### 为了保证项目的正常实施，并且能够顺利的完成，我们必须加强项目管理和重视项目分析工作。我们只有从实际出发，切切实实地把握用户需求，把握用户需求目标，把握用户将来功能界定，保证我们开发工作正确性方向。

#### 4.1、重点监控软件需求分析办法

##### 由于软件项目的特殊性和行业覆盖的广阔性，以及需求分析的高风险性，软件需求分析的重要性是不言而喻的，同时需求分析又的的确确难做。其原因基本是由于以下情况造成的。

##### 4.1.1、客户说不清楚需求

###### 有些客户对需求只有朦胧的感觉，当然说不清楚具体的需求。例如全国各地的很多部门、机构、单位在进行应用系统以及网络建设时，客户方的办公人员大多不清楚计算机网络有什么用，更缺乏IT系统建设方面的专家和知识。此时，用户就会要求软件系统分析人员替他们设想需求。工程的需求存在一定的主观性，为项目未来建设埋下了潜在的风险。

##### 4.1.2、需求自身经常变动

###### 根据以往的历史经验，随着客户方对信息化建设的认识和自己业务水平的提高，他们会在不同的阶段和时期对项目的需求提出新的要求和需求变更。事实上，历史上没有一个软件的需求改动少于三次的！所以必须接受“需求会变动”这个事实，在进行需求分析时要懂得防患于未然，尽可能地分析清楚哪些是稳定的需求，哪些是易变的需求，以便在进行系统设计时，将软件的核心建筑在稳定的需求上，同时留出变更空间。咨询监理方在需求分析的功能界定上担任一个中间、公平、公正的角色，所以也必须积极参与到需求分析的准备中来，以便协助客户方和承建方来界定“做什么”、“不做什么”的系统功能界限。

##### 4．1．3、分析人员或客户理解有误

###### 软件系统分析人员不可能都是全才，更不可能是行业方面的专家。客户表达的需求，不同的分析人员可能有不同的理解。如果分析人员理解错了，可能会导致以后的开发工作劳而无功。记得一则笑话，有个外星人间谍潜伏到地球刺探情报，它给上司写了一份报告：“主宰地球的是汽车。它们喝汽油，靠四个轮子滚动前进，嗓门极大，双眼在夜里能射出强光……有趣的是，车里住着一种叫作‘人’的寄生虫，这些寄生虫完全控制了车。”所以分析人员知识的专一性也会造成需求分析的误解和失败。这时，咨询监理公司就必须根据实际的项目需求调研计划，提醒承建方加强业务了解程度和注重沟通技巧。

#### 4.2、有效性软件需求分析三步法

##### 根据以往的工程经验，需求分析工作方法，应该定位在“三个阶段”（也称“三步法”）。

##### 4.2.1、“访谈式Visitation”阶段

###### 这一阶段是和具体用户方的领导层、业务层人员的访谈式沟通，主要目的是从宏观上把握用户的具体需求方向和趋势，了解现有的组织架构、业务流程、硬件环境、软件环境、现有的运行系统等等具体情况、客观的信息。建立起良好的沟通渠道和方式。针对具体的职能部门以及各委办局，最好能指定本次项目的接口人。

####### 实现手段：访谈、调查表格

####### 输出成果：调查报告、业务流程报告

##### 4.2.2、“诱导式Inducement”阶段

###### 这一阶段是在承建方已经了解了具体用户方的组织架构、业务流程、硬件环境、软件环境、现有的运行系统等等具体实际、客观的信息基础上，结合现有的硬件、软件实现方案，做出简单的用户流程页面，同时结合以往的项目经验对用户采用诱导式、启发式的调研方法和手段，和用户一起探讨业务流程设计的合理性、准确性、便易性、习惯性。用户可以操作简单演示的DEMO，来感受一下整个业务流程的设计合理性、准确性等等问题，及时地提出改进意见和方法。

####### 实现手段：拜访（诱导）、原型演示

####### 输出成果：调研分析报告、原型反馈报告、业务流程报告

##### 4.2.3、“确认式Afirm”阶段

###### 这一阶段是在上述两个阶段成果的基础上，进行具体的流程细化、数据项的确认阶段，这个阶段承建方必须提供原型系统和明确的业务流程报告、数据项表，并能清晰地向用户描述系统的业务流设计目标。用户方可以通过审查业务流程报告、数据项表以及操作承建方提供的DEMO系统，来提出反馈意见，并对已经可接受的报告、文档签字确认。

###### 实现手段：拜访（回顾、确认），提交业务流程报告、数据项表；原型演示系统

###### 输出成果：需求分析报告、数据项、业务流程报告、原型系统反馈意见（后三者可以统一归入需求分析报告中，提交用户方、监理方进行确认和存档）

###### 整体来讲，需求分析的三个阶段是需求调研中不可忽视一个重要的部分，三个阶段或者说三步法的实施和采用，对用户和承建方都同样提供了项目成功的保证。当然在系统建设的过程中，特别在采用迭代法的开发模式时，需求分析的工作需一直进行下去，而在后期的需求改进中，工作则基本集中在后两个阶段中。

### 软件需求分析工具

#### 我们根据用户需求，通过反复讨论、分析，最终明确一个唯一性的用户需求，这个结果其实就是我们的软件需求分析报告。一般我们采用Word、PowerPoint、Visio、ProntPage、Excel等Office工具，同时可能采用一些开发工具，如VC或BC等，同样也会使用一些图形工具，如Potoshop、调色板等画图工具。

#### 使用各种工具表达软件需求分析，其具体表达手段可以分为：

#### l        效果图描述。主要是用户UI界面的描述反映用户需求功能；

#### l        逻辑图描述。根据用户需求功能，使用抽象化理论，以及需求分析理论，对用户需求功能进行全面的分析，建立功能性逻辑关系图，流程逻辑关系图等；

#### l        关系图表描述。主要是对信息关系、数据库表格、接口函数等描述；

#### l        工程数学描述。分析用户需求，分析用户需求信息，运用工程数学进行算法推导，进行合理化需求分析推导；

#### l        甘地图描述。主要是软件项目工作安排，开发周期预估；

#### l        其它方法描述。保证完整性合理性的有效描述。

### 软件需求分析评估

#### 软件需求分析评估是为了检查我们进行软件需求分析工作，保证软件需求分析工作正确性、完整性、有效性、合理性、可确认性、可实施性，完全保证用户所需求的功能。

#### 6.1、组织结构与责任管理

##### 我们对组织结构与责任管理的评估主要有：参与人员任务和责任界面的明确；安排计划按时完成状况；相互间的协调能力状况。

#### 6.2、满足用户需求的功能

##### 我们进行需求分析的目的是完整、准确地描述用户的需求，跟踪用户需求的变化，将用户的需求准确地反映到系统的分析和设计中，并使系统的分析、设计和用户的需求保持一致。

##### 需求分析的特点是需求的完整性、一致性和可追溯性。完整性：是准确、全面的描述用户的需求。一致性：是通过分析整理，剔除用户需求矛盾的方面，规范用户需求。可追溯性：有两个方面的含义，整理和规范的需求，其一，需要不断的和用户进一步交流，保持和用户最新的需求一致。其二，和系统分析（设计）保持一致。

##### 因此在需求分析之前我们必须建立需求分析技术层面的基本框架，从技术上保证需求分析的要求，在此基础上我们进行的需求分析才能满足项目对需求分析的要求。

#### 6.3、保证可实施性

##### 我们必须以用户软件需求为依据，以求实的态度详细的、准确的、完整的编写软件需求分析，避免空想世界，空中楼阁的想法；避免无逻辑性、无核心的描述；避免无量化思维，无实际空间概念。

#### 6.4、需求分析评价指标

##### 功能性

##### 完整性

##### 正确性

##### 逻辑性

##### 表现性

##### 合理性

##### 可实施性等

#### 6.5、工作周期

##### 评价人员投入，以及费用支出的合理性问题。正确制定工作周期，保证软件项目的顺利完成。

#### 6.6、需求不确定更改与可确认保证

##### 可确认需求功能是实现用户需求的基本保证，如果不可确认的、不确定更改存在，将会阻碍软件实现，或者软件设计存在着不完整性缺陷，或者存在着不可实施性问题，我们必须区分是功能性障碍问题，还是未来性问题。如果不能够明确是未来性问题，则必须调整功能需求，化解不确定更改的问题。因此，判断不确定性更改是一个非常重要的问题

## 数据分析

### 数据采集

#### 数据源

##### 开源数据源

##### 日志采集

##### 爬虫抓取

##### 传感器

#### 工具使用

##### 八爪鱼

##### 火车采集器

##### 搜集客

#### Python爬虫利器

##### phantomjs

##### scrapy

##### lxml

##### selenium

### 数据挖掘

#### 数学基础

##### 概率论与数据统计

##### 线性代数

##### 图论

##### 最优化方法

#### 基本流程

##### 商业理解

##### 数据理解

##### 数据准备

##### 模型建立

##### 模型评估

##### 上线发布

#### 十大算法

##### 分类算法

##### 聚类算法

##### 关联分析

##### 连接分析

### 数据可视化

#### Python可视化

##### Matplotlib

##### Seaborn

#### 第三方工具

##### 微图

##### DataV

## 软件测试

### 系统测试：系统测试是对已经集成好的软件系统进行彻底的测试，
以验证软件系统的正确性和性能等是否满足其规约所指定的要求。

#### 测试种类

##### 功能测试： 

##### 功能测试是对产品的各功能进行验证，以检查是否满足需求的要求。 

##### 性能测试：

##### 性能测试是通过自动化测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。 

##### 安全测试：

##### 安全测试检查系统对非法入侵的防范能力。 

##### 兼容测试： 

##### 兼容性测试主要是测试系统在不同的软硬件环境下是否能够正常的运行。

### 验收测试：
验收测试是部署软件之前的最后一个测试操作。
验收测试的目的是确保软件准备就绪，
向软件购买都展示该软件系统满足其用户的需求。

#### 验收测试内容

##### 功能确认测试 

##### 安全可靠性测试 

##### 易用性测试 

##### 可扩充性测试 

##### 兼容性测试 

##### 资源占用率测试 

##### 用户文档资料验收

### 集成测试：
集成测试是在软件系统集成过程中所进行的测试。
目的是检查软件单位之间的接口是否正确。 

#### 关注内容

##### 1.        把各个模块连接起来时，穿越模块接口的数据据是否会丢失。  

##### 2.        各个了模块组合起来，能否达到预期要求的功能。

##### 3.        一个模块的功能是否会对另一个模块的功能产生不利影响。 

##### 4.        全局数据据结构是否有问题。 

##### 5.        单个模块的误差积累起来是否会被放大，从而达到不可接受的程序。

### 单元测试:
单元测试是对软件中的基本组成单位进行的测试。
目的是检验软件基本组成单位的正确性。 

#### 单元测试的好处

##### （1）单元测试帮助设计

###### 单元测试迫使我们从关注实现转向关注接口，编写单元测试的过程就是设计接口的过程，使单元测试通过的过程是我们编写实现的过程。我一直觉得这是单元测试最重要的好处，让我们关注的重点放在接口上而非实现的细节。

##### （2）单元测试帮助编码

###### 应用单元测试会使我们主动消除和减少不必要的耦合，虽然出发点可能是为了更方便的完成单元测试，但结果通常是类型的职责更加内聚，类型间的耦合显著降低。这是已知的提升编码质量的有效手段，也是提升开发人员编码水平的有效手段。

##### （3）单元测试帮助调试

###### 应用了单元测试的代码在调试时可以快速定位问题的出处。

##### （4）单元测试帮助重构

###### 对于现有项目的重构，从编写单元测试开始是更好的选择。先从局部代码进行重构，提取接口进行单元测试，然后再进行类型和层次级别的重构。

###### 单元测试在设计、编码和调试上的作用足以使其成为软件开发相关人员的必备技能。

#### 基本

##### 单元测试的好处

###### （1）单元测试帮助设计

####### 单元测试迫使我们从关注实现转向关注接口，编写单元测试的过程就是设计接口的过程，使单元测试通过的过程是我们编写实现的过程。我一直觉得这是单元测试最重要的好处，让我们关注的重点放在接口上而非实现的细节。

###### （2）单元测试帮助编码

####### 应用单元测试会使我们主动消除和减少不必要的耦合，虽然出发点可能是为了更方便的完成单元测试，但结果通常是类型的职责更加内聚，类型间的耦合显著降低。这是已知的提升编码质量的有效手段，也是提升开发人员编码水平的有效手段。

###### （3）单元测试帮助调试

####### 应用了单元测试的代码在调试时可以快速定位问题的出处。

###### （4）单元测试帮助重构

####### 对于现有项目的重构，从编写单元测试开始是更好的选择。先从局部代码进行重构，提取接口进行单元测试，然后再进行类型和层次级别的重构。

####### 单元测试在设计、编码和调试上的作用足以使其成为软件开发相关人员的必备技能。

##### 应用单元测试：
单元测试不是简单的了解使用类似XUnit和Moq这样的测试和模拟框架就可以使用了，
首先必须对我们要编写的代码有足够的了解。
通常我们把代码看成一些静态的互相关联的类型，类型之间的依赖使用接口，实现类实现接口，
在运行时通过自定义工厂或使用依赖注入容器管理。
一个单元测试通常是在一个方法中调用要测试的方法或属性，
通过使用Assert断言对方法或属性的运行结果进行检测，通常我们需要编写的测试代码有以下几种。

###### （1）测试领域层

####### 领域层由POCO组成，可以直接测试领域模型的公开行为和属性。

###### （2）测试应用层

####### 应用层主要由服务接口和实现组成，应用层对基础设施组件的依赖以接口方式存在，这些基础设施的接口通过Mock方式模拟。

###### （3）测试表示层

####### 表示层对应用层的依赖表现在对服务接口的调用上，通过Mock方式获取依赖接口的实例。

###### （4）测试基础设施层

####### 基础设施层的测试通常涉及到配置文件、Log、HttpContext、SMTP等系统环境，通常需要使用Mock模式。

###### （5）使用单元测试进行集成测试

####### 首先系统之间通过接口依赖，通过依赖注入容器获取接口实例，在配置依赖时，已经实现的部分直接配置，伪实现的部分配置为Mock框架生成的实例对象。随着系统的不断实现，不断将依赖配置的Mock对象替换为实现对象。

##### 3.使用Assert判断逻辑行为正确性

##### 4.使用伪对象

###### （1）使用接口依赖取代原始类型依赖。

###### （2）通过对原始类型的适配实现上述接口。

###### （3）手动创建用于单元测试的接口实现类或在单元测试时使用Mock框架生成接口的实例。

##### 5.单元测试常用框架和组件

###### （1）单元测试框架。

####### XUnit是目前最为流行的.NET单元测试框架。NUnit出现的较早被广泛使用，如nopCommerce、Orchard等项目从开始就一直使用的是NUnit。XUnit目前是比NUnit更好的选择,从github上可以看到asp.net mvc等一系列的微软项目使用的就是XUnit框架。

###### （2）Mock框架

####### Moq是目前最为流行的Mock框架。Orchard、asp.net mvc等微软项目使用Moq。nopCommerce使用Rhino Mocks。NSubstitute和FakeItEasy是其他两种应用广泛的Mock框架。

###### （3）邮件发送的Mock组件netDumbster

####### 可以通过nuget获取netDumbster组件，该组件提供了SimpleSmtpServer对象用于模拟邮件发送环境。

####### 通常我们无法直接对邮件发送使用Assert，使用netDumbster我们可以对模拟服务器接收的邮件应用Assert。

###### （4）HttpContext的Mock组件HttpSimulator

####### 同样可以通过nuget获取，通过使用HttpSimulator对象发起Http请求，在其生命周期内HttContext对象为可用状态。

##### 6.使用单元测试的难处

###### （1）不愿意付出学习成本和改变现有开发习惯。

###### （2）没有思考的习惯，错误的把单元测试当框架学。

###### （3）在项目后期才应用单元测试，即获取不到单元测试的好处又因为代码的测试不友好对单元测试产生误解。

###### （4）拒绝考虑效率、扩展性和解耦，只考虑数据和功能的实现。

#### 分类

##### 模块接口测试

###### 通过所测模块的数据流进行测试。调用所测模块时的输入参数与模块的形式参数的个数、属性和顺序是否匹配。 

##### 局部数据结构测试 

###### 局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整、正确、模块的局部数据结构往往是错误的根源。 

##### 路径测试 

###### 对模块中重要的执行路径进行测试。 

##### 错误处理测试 

###### 比较完善的模块设计要求能遇见出错的条件，并设置适当的出错处理，以便在一旦程序出错时，能对出错程序重做安排，保证其逻辑上的正确性。 

##### 边界条件测试 

###### 软件经常在便捷上失效，边界条件测试是一项基础测试，也是后面系统测试中的功能测试的重点。 

### 其他层面分类

#### 测试工作对软件代码的的可见程度的划分

##### 白盒测试

###### 白盒测试，指的是把盒子盖子打开，去研究里面的源代码和程序结果。

　　它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作 

##### 黑盒测试

###### 灰盒测试介于黑盒测试与白盒测试之间。

　　可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，
但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，
有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。  

##### 灰盒测试

###### 黑盒测试，指的是把被测的软件看作是一个黑盒子，我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。

它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。  

#### 功能测试、性能测试 

##### 功能测试

###### 功能测试检查实际的功能是否符合用户的需求。测试的大部分工作也是围绕软件的功能进行，设计软件的目的也就是满足客户对其功能的需求。如果偏离的这个目的任何测试工作都是没有意义的。

　　功能测试又可可以细分为很多种：逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等。 

##### 性能测试

###### 　性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。

　　软件的性能包括很多方面，主要有时间性能和空间性能两种。

　　时间性能：主要是指软件的一个具体的响应时间。比如一个登录所需要的时间，一个交易所需要的时间等。当然，抛开具体的测试环境，来分析一次事务的响应时间是没有任何意义的。需要搭建一个具体且独立的测试环境。

　　空间性能：主要指软件运行时所消耗的系统资源，比如硬件资源，CPU、内存，网络带宽消耗等。  

#### 手工测试与自动化测试 

##### 手工测试

###### 手工测试：

　　手工测试就是由人去一个一个的去执行测试用例，通过键盘鼠标等输入一些参数，查看返回结果是否符合预期结果。

（其实，不太喜欢别人把一般的功能测试工作叫手工测试，就像一个雕塑家不喜欢别人叫他刻石头的一样。手工测试同样需要业务熟悉、基本测试方法的理解。看似简单的工作却能够发现别人不能发现的软件问题。在目前的测试领域，手工测试仍然是无法替代的一种测试方法） 

##### 自动化测试

###### 自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。 

　　自动化测试：又可分为功能自动化测试与性能自动化测试。

　　我们一般所说的自动化测试就是指功能自动化测试，通过相关的测试技术，通过编码的方式用一段程序来测试一个软件的功能，这样就可以重复执行程序来进行重复的测试。如果一个软件一小部分发生改变，我们只要修改一部分代码，就可以重复的对整个软件进行功能测试。这样就大大的提高了测试效率。

　　性能自动化测试，当然，除了早期阶段，现在的性能测试工作都是通过性能测试工具辅助完成的。能过工具可以模拟成千上万的用户向系统发送请求，用来验证系统的处理能力。  

###### 优点

####### 可以频繁的进行测试

####### 可以在任何时间进行测试，也可以按计划定时进行，例如：可以在半夜进行自动化测试

####### 比人工测试速度快

####### 可以更快速地发现错误

####### 基本上是非常可靠的

####### 测试代码与生产代码紧密结合

####### 使得开发团队更具有幸福感

#### 其他测试

##### 冒烟测试

###### 是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。

　　引入到软件测试中，就是指测试小组在正规测试一个新版本之前，先投入较少的人力和时间验证一个软件 的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做的好处是可以节省大量的时间成本和人力成本。 

##### 回归测试

###### 回归测试是指修改了旧代码后，重新时行测试以确认修改后没有引入新的错误或导致其他代码产生错误。

　　回归测试一般是在进行软件的第二轮测试开始的，验证第一轮中发现的问题是否得到修复。当然，回归也是一个循环的过程，如果回归的问题通不过，则需要开发人员修改后再次进行回归，直到通过为止。  

##### 随机测试

###### 是指测试中的所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。

　　随机测试可以发现一些隐蔽的错误，但是也有很多缺点，比如测试不系统，无法统计代码覆盖率和需求覆盖率，发现的问题难以重现。一般是放在测试的最后执行。其实随机测试更专业的升级版叫 探索性测试  

##### 探索性测试

###### 探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。 

　　探索性测试应该是未来测试领域的一个方向。  

##### 安全测试

###### 安全测试是在IT软件产品的生命周期中，特别是产品开发基本完成到发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程。 

     安全测试也在越来越受到企业的关注和重视，因为由于安全性问题造成的后果是不可估量的。尤其对于互联网产品最容易遭受各种安全攻击。  

## 系统架构

### 定义

  定义 1：软件或计算机系统的软件架构是该系统的一个（或多个）结构，而结构由软件元素、元素的外部可见属性及它们之间的关系组成。 
    定义 2：软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式及这些模式的约束组成。 
    定义 3：软件架构是指一个系统的基础组织，它具体体现在：系统的构件，构件之间、构件与环境之间的关系，以及指导其设计和演化的原则上。（IEEE1471- 2000）    前两个定义都是按“元素—结构—架构”这一抽象层次来描述的，它们的基本意义相同，其中定义 1 较通俗，因此，本章采用这一定义。该定义中的“软件元素”是指比“构件” 更一般的抽象，元素的“外部可见属性”是指其他元素对该元素所做的假设，如它所提供的服务、性能特征等。 

#### 说明

##### （1）	架构是对系统的抽象，它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象。因此，仅与内部具体实现有关的细节是不属于架构的，即定义强调元素的“外部可见”属性。

##### （2）	架构由多个结构组成，结构是从功能角度来描述元素之间的关系的，具体的结构传达了架构某方面的信息，但是个别结构一般不能代表大型软件架构。 

##### （3）	任何软件都存在架构，但不一定有对该架构的具体表述文档。即架构可以独立于架构的描述而存在。如文档已过时，则该文档不能反映架构。 

##### （4）	元素及其行为的集合构成架构的内容。体现系统由哪些元素组成，这些元素各有哪些功能（外部可见），以及这些元素间如何连接与互动。即在两个方面进行抽象：在静态方面，关注系统的大粒度（宏观）总体结构（如分层）；在动态方面，关注系统内关键行为的共同特征。 

##### （5）	架构具有“基础”性：它通常涉及解决各类关键的重复问题的通用方案（复用性），以及系统设计中影响深远（架构敏感）的各项重要决策（一旦贯彻，更改的代价昂贵）。 

##### （6）	架构隐含有“决策”，即架构是由架构设计师根据关键的功能和非功能性需求（质量属性及项目相关的约束）进行设计与决策的结果。不同的架构设计师设计出来的架构是不一样的，为避免架构设计师考虑不周，重大决策应经过评审。特别是架构设计师自身的水平是一种约束，不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路。 

#### 影响因素

##### （1）	影响架构的因素。
软件系统的项目干系人（客户、用户、项目经理、程序员、测试人员、市场人员等）
对软件系统有不同的要求开发组织（项目组）有不同的人员知识结构、架构设计师的素质与经验、当前的技术环境等方面都是影响架构的因素。
 这些因素通过功能性需求、非功能性需求、约束条件及相互冲突的要求，影响架构设计师的决策，从而影响架构。

##### （2）	架构对上述诸因素具有反作用，
例如，影响开发组织的结构。
架构描述了系统的大粒度（宏观）总体结构，因此可以按架构进行分工，将项目组为几个工作组，从而使开发有序；
影响开发组织的目标，即成功的架构为开发组织提供了新的商机，这归功于：系统的示范性、架构的可复用性及团队开发经验的提升，
同时，成功的系统将影响客户对下一个系统的要求等。这种反馈机制构成了架构的商业周期。 

### 模型

#### 结构模型

#### 框架模型

#### 动态模型

#### 过程模型

#### 功能模型

### 4+1视图

####  逻辑视图

#### 子主题6

#### 进程视图

#### 物理视图

#### 场景视图

### 开发质量属性

#### 运行期

##### 性能

##### 安全

##### 易用

##### 可伸缩

##### 互操作

##### 可靠

##### 持续可用

##### 鲁棒

在有些非正常情况下仍然能用

#### 开发期

##### 易理解性

##### 可扩展性

##### 可重用性

##### 可测试性

##### 可维护性

##### 可移植性

### 企业架构成熟度模型（EAMM）

#### EAMM从以下几个方面来对不同级别进行描述:

##### Administration – 治理角色与职责

##### Planning – 企业架构开发路标以及实现计划

##### Framework – 流程和模板

##### Blueprint – 实际的标准和规范集合

##### Communication – 交流与发布EA和详细蓝图

##### Compliance（一致性） – 遵循发布的标准、流程和其它EA元素，文档化流程并且能够跟踪变化

##### Integration – touch-points of management processes to the EA

##### Involvement – 整个组织对EA的支持

#### 分级

##### EA LEVEL 0 - NO PROGRAM

###### 没有文档化的架构框架，虽然解决方案已经开发并实现了，但是并没有公认的标准和最佳实践的指导，组织完全依赖于独立个人贡献者的知识。

###### Administration

####### 没有架构治理

###### Planning

####### 没有开发企业架构的方法

###### Framework

####### 没有架构流程和模板

###### Blueprint

####### IT技术标准没有文档化

###### Communication

####### 主要管理人员和机构人员不知道企业架构是什么

###### Compliance

####### 组织内没有统一的流程

###### Integration

####### 没有企业集成的程序

###### Involvement

####### There is no program in place for Enterprise Architecture awareness

####### 多个独立部门或个人分别在解决同一个问题

##### EA LEVEL 1 - INFORMAL PROGRAM

###### 定义了基本的企业架构和标准。大家对这些步骤达成基本一致，但是并不一定会遵守并执行，基本上是在非正式的情况下使用。这个状态下组织仍旧依赖于独立个人贡献者的知识。

###### Administration

####### The need for committees to define the standards and processes has been identified

###### Planning

####### Need for Enterprise Architecture has been identified

####### EA活动没有正式化和结构化

###### Framework

####### 个性化和非正式的流程，流程不一致

####### 在业务和技术上没有统一的架构流程

###### Blueprint

####### 非正式和非一致性的文档化业务驱动、技术标准等等

###### Communication

####### The need to create greater awareness about EA has been identified

####### 在EA流程改善上很少沟通

###### Compliance

####### Compliance is informal and unstructured

####### The need for compliance to standards has been identified

####### Compliance cannot be measured effectively, because processes and procedures are not consistent across areas and/or projects

###### Integration

####### The need to document common functions that integrate with an EA Program has been identified

####### Projects and purchases are typically done in isolation, resulting in costly purchases and redundant development and training requirements

###### Involvement

####### EA awareness efforts are informal and inconsistent

####### The organization has identified a need to make staff throughout the enterprise aware of the benefits and concepts of Enterprise Architecture

####### Some groups are unsupportive of the efforts and may cause unrest in the organization

##### EA LEVEL 2 - REPEATABLE PROGRAM

###### 基本架构和标准已经制定并跟踪验证，开发时作为可重用方法，产品和组件遵守标准，需求得到一致认同，对流程绩效也进行了度量。

###### Administration

####### 开始制定清晰的角色和职责

####### A need for Architecture Governance has been identified

####### Governance committees are starting to form

###### Planning

####### 组织开始标识EA任务和资源需求

####### 组织已经开始开发企业架构愿景

####### 组织决定使用一个方法论，并且开始开发一个EA计划

###### Framework

####### 流程计划并跟踪

####### 编制了基本的EA程序

####### The organization is beginning to reuse methods for capturing critical EA information

###### Blueprint

####### 明晰了业务驱动和策略信息

####### The need for an EA repository for storage and dissemination of the captured EA information has been identified

###### Communication

####### The need for Enterprise Architecture is being communicated to Senior Management

####### EA awareness activities are beginning to emerge or be developed

###### Compliance

####### The organization has begun to develop a compliance process to ensure that projects and enhancements are consistent with EA standards

###### Integration

####### The need for integration to the EA Program Framework (Architecture Lifecycle Processes) has been identified

###### Involvement

####### The organization has begun to develop plans for EA educational sessions and materials to increase the awareness and understanding of the EA concepts and processes

####### EA concepts are beginning to be introduced and more consistently discussed in normal day-to-day meetings

### 软件分层

#### 分层原则

##### 1.每一层都应该都是由类或组件组成。

##### 2.只存在上层对下层的依赖，下层不依赖于上层。

##### 3.上层调用下层的api，下层实现细节的变动不会影响到上层的代码。

#### 框架模型

##### 1.可伸缩性：可以把每一层分布在不同机器上，实现分布式应用。

##### 2.可维护性：如果需求变动，只要相应调整某一层的实现即可。

##### 3.可管理性：分层有利用分工。

##### 4.可扩展性：增加功能只需要在相应层上调整即可。

##### 5.可重要性：业务逻辑模块则可供系统的多个模块公共。

### 微服务

### consul

## 敏捷开发

### 敏捷软件开发宣言

#### 个人与交互 高于 流程和工具

#### 可用软件 高于 详尽的文档

#### 客户合作 高于 合同谈判

#### 响应变化 高于 遵循计划

### 敏捷宣言的十二条原则

#### 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。

#### 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。

#### 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。

#### 业务人员和开发人员必须相互合作，项目中的每一天都不例外。

#### 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。

#### 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。

#### 可工作的软件是进度的首要度量标准。

#### 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。

#### 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。

#### 以简洁为本，它是极力减少不必要工作量的艺术。

#### 最好的架构、需求和设计出自自组织团队。

#### 团队定期地反思如何能提高成效，并依此调整自身的举止表现。

### 应该着重注意的点

#### 需求在开发中的重要性

##### 大量的开发过程告诉我，需求在软件开发过程中是极其重要的。传统的开发强调初期的需求调研及需要分析，这个过程对于一些正规的团队会产生大量的文档，而后交由开发展开产品生产。

##### 然而，事实却不是想象这么简单，无数的例子说明了一点，仅仅在需求调研过程中了解到的需求是无法保证的。数不清的例子告诉我们，需求是会变的，变的原因很多。在极端的情况下，有些客户签字的需求在开发完后，有需要变更也很正常。

##### 所以需求是影响软件开发的第一重要因素，需求来源于业务，我们开发的产品不就是因为这些业务才去做的吗？如何需求都无法把握好，还谈什么开发出好用的产品？

##### 然而如何做好需求呢？我想首先要确立需求的地位，然后只有通过不断的沟通、尝试、反馈向真实需求迈进。

#### 强调人与人的交流

##### 不管怎么样开发过程中主要还是靠人的，而且软件开发是个复杂的团体工程，一个小些的产品也会涉及到各类人：客户、业务分析、管理人员、程序员、测试员等等。这么多人在一起做事情，有一方没有处理好结果肯定就会有问题。

##### 有这样一个例子：客户提出了一个会员管理功能需求，需求人员了解后组织了解决方案，于是交付了开发实现。而经过二个月无尽的黑夜之后交付，需求一看有个模块做的有偏差，但是已经来不及修改了。交给客户看后，发现这不是他们要的会员管理功能相差较大，另外在功能开发的这一段时间，客户又有了新想法，要对原先需求做调整。

##### 这种例子可能大家经常经历吧？

##### 这种问题在敏捷开发方法中提出了解决方法，就是通过不断的交付可用的制品。看起来很抽象，其实很简单。同样是上面的例子：

##### Ø 客户提出会员管理功能需求

##### Ø 需求人员在了解需求后与开发负责人商量，确定一个快迭代的开发计划，每二周向客户演示一次，并将这个计划与客户确认

##### Ø 确认后需求人员向全体成员讲解需求背景故事

##### Ø 开发负责人组织并确定迭代计划内容，明确每个迭代提交的产品目标、开发任务安排、测试跟踪计划

##### Ø 每个迭代过程中都由需求及测试进行确认每个任务的实现结果是否跑偏

##### Ø 后面就是每二周向客户演示一次产品，并获得客户的反馈

##### Ø 根据客户的反馈调整下个迭代计划，并继续下一个迭代

##### Ø 直到产品交付

##### 通过上面的步骤，就不至于在开发完成后才知道用户的真实想法，因为很多用户对软件开发是没有概念的，他只知道自己有某种需求，但最开始是没有一个完整的概念的。所以就要通过不断的让用户看到产品的模型，这个过程用户才会逐步的对产品产生概念。同样的在过程中客户的提出需求变更也是在一定的可控制范围之内，这样一来可以大大的减少软件返工的情况，自然就不会拖延计划了。

##### 而这个过程中，需求已经完成了一个真正的过渡，不再是一头重的情况了。他让需求从客户那快速的反馈到开发团队中。同样的，在开发不断的交付制品时，需求也更加及时的了解到产品的进度，把握开发人员开发的功能是否符合需求。

##### 当然这并不是一个标准做法，不同的团队可以有不同的处理方式。这里只是想强调需求需要更多的投入到开发过程中去，及时的与客户沟通交流，了解到客户的真实想法。

#### 强调文档的作用

##### 我觉得很多对敏捷开发的一个误解就是不需要文档，敏捷开发并未抛弃文档。只是更强调更有效的方式使用文档。在很多传统开发方法中，特别是很多很正规的开发团队对文档的要求非常苛刻。然而事实是文档不易管理，最痛苦的是不好维护，文档需要随着变化而变化，比如需求调整、技术架构升级、产品维护等等。如果要保证文档的一致性，太难了。特别是对于一些无法进行有效管理的开发团队就更加明显，经常是软件已经几个版本了，文档却是两年前的。

##### 但敏捷真的不需要文档吗？我想不是的，如何把文档做到好维护我想才是最重要的。文档到底指的指的什么？什么样的算文档？

##### 提出上面两个问题，我们先想想经常说的文档的作用是什么？不就是一个传播工具吗？可以用作记录、给他人看、用于以后查看。有很多方法可就解决了这个问题，比如wiki系统。维护一个wiki系统，可以随时写，随时维护，可以方便的查找。嗯，多方便。

##### 另外一个问题就是什么样的工作需要形成文档呢？

##### 记得在前一家公司，维护一个10多年的老系统修改一个公式计算的BUG，但是怎么也不知道这个复杂的公式是什么意思，问过了公司大部分的人也无人可解。这时想，如果当初有那么一份文档，谢天谢地。

##### 像这种关键的内容有份文档还是很重要的，否则随着时间推移，谁也不能保证能记得住当时为什么会这么干。

##### 记得多年前一次记笔记的经历，我看了一篇文章了解了DELPHI实现单实例模式的方法，这种方法很酷。于是整理成了笔记写在了wiki上，第二天就得到了回复，帮助到了别外产品开发组的同事。

##### 嗯，文档就是这样他具有传播性，你不可能跑去跟所有人说出你的想法，但是文档却更容易达成。他也有传承性，有些文档也许10多年后又起了重要作用。

#### 团队协作

##### 1、减少对开发人员的干扰

##### 曾经接手一个产品的开发，最初遇到一个很头痛的问题，原先写好的迭代计划，而且工作量也较大，大家都在忙着。即便在这样的状态下，客服人员却经常跑来找某个程序员A维护各种系统问题，程序员A在一次维护中竟然导致了系统数据出现大面积错误。程序员A心理上承受着巨大的压力，而每天的这些问题又不得不解决，加之新版本又有很重的开发任务无法完成，最终导致整个开发计划变更。

##### 我无法再忍受，找到了需求及客服的负责人，沟通后发现这些问题很多都是重复性的，主要是因为原先系统的不足。于是回去组织人员做了几个后台临时功能，并交付给了客服人员，之后就没有再来找过这位程序员A。后续我又找到了客服负责人，要求不能直接找开发人员解决这类问题，并与负责人约定了处理过程。

##### 这是个例子，在实际情况中还有很多这种事情，甚至有很多开发人员要直接面对客户。我想对于职能型团队来说，开发团队最好是减少这些方面的干忧。当然对于一个人包干的情况就不讨论了。

##### 大部分的人都不是超人，在一个时间段内处理超出自己负荷的工作是很难做好保质保量的。所以对于开发管理人员一定要考虑到这点，尽量让开发人员有比较好的工作进度环境，通过外界的方式来解决一些开发团队的干扰。

##### 我接触过的很多程序员都很反感这种干扰，虽然有些人在这种全面的工作强度下成长很快，但是并非所有人都适应，长期下来会有怨恨和不快，工作效率会下降。心情舒畅还是很重要的，记得有一次迭代总结时，有个程序员总结说：发现心情舒畅自己的工作效率很高。呵呵。我想你也有同感吧。

##### 2、不要忽略测试人员在开发阶段的作用

##### 曾经多少次在项目发布前加班到深夜2点的情景还历历在目，那种感觉即快乐又痛苦。由于和客户签定的合同的交付日期就要到了，产品却迟迟未集成完成，测试只能干等着上网聊QQ。就在下班前的一刻发布了，测试开始了紧张的测试，在屏幕闪动中，一个个的BUG提交，直到流程都无法都走不下去，测试无奈了。第二天就要发布，实施人员就等着制品第二天出差。只有不断的改，再发布，无尽的循环。直到大家都憔悴的看着老大，终于老大说：还剩下的这几个问题无关紧要，大家回去吧。

##### 几个月的开发过去后在总结会上，只能抱怨测试资源不足，时间太短，需求更改太多，需求更改后测试不知道。无数的问题一次一次的出现在同样的总结会议上。

##### 上面的这个例子很多人应该经历过，真的测试只有最后一刻才能体现价值吗？我想不是的。

##### 在后面的项目中我总结了这个问题的，针对每个开发任务要求进行测试验证。而测试如何验证呢？他需要知道这个开发任务的需求是如何，提前做好测试计划及测试用例，在接到开发制品后测试并提交BUG，这个工作是可以开发过程中就能不断的进行的。保证每一个任务的质量，可以大大减少后期集成的错误量。

##### 另外根据敏捷开发的思想，测试团队在开发过程中也需要加强与开发团队的交流，甚至有必要组成虚拟团队，位置调整到一起，这样可以及时快速的交流，参加开发团队的站立会议同样可以及时了解到开发的实际情况及进度，反过来把握测试计划及测试内容。

##### 特别是测试从另一个角度来审视需求，这样也可以一定程度上发现或者改善需求上的不足。

##### 3、发挥团队人员的潜力

##### 敏捷开发比较提倡开发任务由开发自己评估并认领工作任务，这样可以激发开发的潜在动力。

##### 之前在做一个新产品时，需要使用java，而我们团队是使用C#的，面临转型问题。而有一位同事很感兴趣，于是我就让他负责前期的框架探索与搭建。结果就是这位小伙工作效率很高，我最初给他的目标全部都完成了。最有意思的是后面产品开始研发时，这位小伙已经成为了团队的大牛，大家有问题都找他解决。也正是因为这个过程，这位小伙被全面激活，也在大家面前展示了能力。甚至在小伙离职时也被领导给予大幅涨薪来挽留。只不过谁又能想象到这位小伙进入我团队之前是因为被定为裁员的目标而调剂过来的呢!

##### 所以充分发挥好每个人员的特点，让人能够在自己感兴趣的工作中，效果会很多。减少指派方式的任务的分配，充分发挥个人的主动性，这个团队精神面貌也会好很多。

##### 4、管理者不要离团队太远

##### 作为团队的Leader要参与到团队的工作中去，比如一个开发主管一定要写写代码，参与架构等对项目有关的事情，而不是在那里分分任务。这样团队成员才会觉得这个Leader很亲近感。

##### 特别是有些开发主管在带队后离团队越来越远，有时对于开发进度不如意时就说：“这么个简单功能怎么会搞了这么久？”，其实每天都在加班的同事心里想着：“有本事你来？”，即使这个小组长有这个能力，但对于团队来说也不是一件好事，因为大家都抱有怨恨之心，还谈什么好好工作呢？这个小组长就是失职的。所以这种情况下应该主动去了解进度滞后的原因，并且自己要加入到解决问题的工作中去，而不是在边上抱怨别人。

##### 5、小组织不要搞太多的官

##### 中国几千年的文化，官本位一直影响着我们，大家都想坐在那指挥，自己啥事也不用干，想想都惬意。在我们这个行业是不是发现也很类似？大家都想着干几年当个小组长，然后升个部门经理，当上CTO迎娶白富美。

##### 团队的管理基本是事与人的管理，非常的伤脑和心。如果一个组织内，特别是小组织内“官”太多，协调就会非常的难，大家就会经常性的扯皮。

##### 结束

### 敏捷开发的推理

#### 符合现实的软件

#### 软件是为着解决现实的问题而产生的。从而软件存在的意义就是与现实相适应。敏捷开发的核心即：符合现实的软件。一个符合现实的软件，才能够可持续地与现实共同发展。一旦软件与现实背离，软件的生命周期也就到了结束的时候了。

#### 现实的世界是动态变化的，人类造出来的东西，往往是落后于世界的变化的。如，地图造出来之后，可能又多修了几条路，几个建筑；刚买了一款高配置的计算机，几个月后，自己的机器配置又处于被甩的地位了……这些变化，人是被迫要去接受。因为这些东西属于硬件，人在目前还无法轻易地改变硬件。

#### 而与此不同的软件，则是另外一种现象了。改变软件的代价是相当低廉的。改变软件，实际上只是改变硬盘上的磁性。改变软件的容易性，带来的结果是： 一、软件开发者容易以自己的想象来决定软件怎么做。 开发出一个无用的软件，比起因为出错而要毁掉待出售的10万张地图，比起因为工艺漏洞而要招回已经出售的计算机来讲，代价太低廉了。 二、软件更加具备符合现实的条件。 开发者让软件与现实相适应，所要付出的代价非常低廉。

#### 所以，敏捷开发的核心就是符合现实的软件。为了造出符合现实的软件，才有了进一步的价值观及方法论。

#### 简单

#### 简单，是在人认识到事物的本质的时候才能够获得的。在开发软件的时候，我们往往疲于应付各种各样的需求。很少有人能够将复杂的需求化为简单的概念。比如，做一个音乐软件，有“我喜欢的”、“最近播放”、“最新添加”等不同的性质的歌。有些开发者会做出三个列表来存放三种性质的歌。而实际上他们的本质是一样的，即播放列表。区别在于触发加入播放列表的条件不同而已。因而只需要做一个列表，在列表中标记每首歌的触发条件。

#### 把软件做得很复杂，通常说明软件所抓住的本质还很少。需要再好好考虑一下如何进一步进行简化。软件的概念简单，一方面可以让用户很容易理解和操作；另一方面能够适应世界的变化。再拿以上的音乐软件来说。如何做成三个列表，再要加一个“听了又听”的歌，又得创建一个列表。而使用一个列表的方法，则只需要处理“听了又听”这个触发条件。

#### 符合现实的软件必然是简单的。所以，敏捷开发的第一条价值观是：简单。我们在实施敏捷开发的时候，都是围绕“简单”这一价值观而进行实施的。即，时刻保证软件的简单性。简单性包括两个方面：一是对于用户而言，概念很简单；二是对于开发者而言，开发的技术及代码很简单。

#### 软件的可持续性也取决于软件是否简单。可持续性是指，快速响应现实的变化。一个复杂的软件，要么让用户无所适从，要么让代码无法维护。这都将导致软件无法持续。这会迫使我们以制造硬件的方式来开发软件。硬件是在迫不得已的情况下才丢掉重新升级（计算机在实在没有办法用的时候，才买新的），要让软件也这样做，软件开发低廉代价的优势就白白浪费掉了。

#### 反馈

#### 一个软件要符合现实，就需要通过现实的反馈来发展。软件前进的动力是现实的反馈。敏捷开发是欢迎现实，拥抱变化的开发。强调该条价值观，是为了消除开发者容易犯的错误——以自己的想象去决定软件怎么做。

#### 因而，在做一个软件之前，首先要找到能够给出反馈的人。如果连能够给出反馈的人都没有，那么这个软件就没有做的必要了。

#### 反馈的重要性，更可以这样说：矛盾推动事物的发展。反馈是指出不足的矛，软件是弥补不足的盾。在矛的不断攻击之下，盾才能不断完善。矛之不存，盾何以壮。

#### 在方法论上面，敏捷开发强调快速发布版本，取得现实的反馈而不是开发者大脑中自己想像的反馈。如果开发者正好也是使用者，那么软件做成的几率就要大很多。开源软件大多数都是开发者自己要解决问题而产生的。

#### 沟通

#### 沟通是开发者取得反馈的手段。一个优秀的开发者，是善于沟通的。沟通包含口语、写文档等各种方式。优秀的开发者应该能够清晰而有条理地表达自己的想法。

#### 现实世界中，人们普遍认为：软件开发者因为跟机器打交道，从而是内向的，不善于沟通的。实际上，这样的开发者不能算是优秀的。他们所做的事情，更多地是把需求转化为计算机语言的工作，即翻译员。而现在都出来谷歌翻译了，人类语言翻译成计算机语言只是时间问题了。

#### 沟通的目的是进行思想碰撞。在沟通当中了解别人的思维方式，表达自己的思维方式，进一步扬弃为更加优秀的思维方式。在优秀的思维方式之下才能保持让自己与现实相符合。优秀的开发者是不会放弃获取优秀的思维方式的机会的。

#### 在敏捷开发当中，提出这一价值观，正是要开发者变得优秀。放弃优秀的开发者无法适应敏捷开发。

#### 勇气

#### 在现实生活中，缺乏勇气比较常见。比如，不敢大大方方地表白，不敢尝试新的事物……在软件开发领域，缺乏勇气更是常见：技术更新好几代了，公司还不敢使用新技术；公司不敢尝试新的开发模式（敏捷开发）……

#### 勇气，本质上来讲，是对现状的否定。人们往往一厢情愿地相信永恒；一旦确定，就不愿意改变。这正是勇气的用武之地。勇气使人去否定永恒，拥抱改变。勇气是创造的源泉。人没有勇气，人就永远是他现在的这样了，正是勇气才迫使他去改变。

#### 在开发的时候，我们可能花了很多时间写了很多代码，但要决定放弃已经写过的所有代码，这是非常需要勇气的。而如果能够做到这一点，在软件开发上就占据了非常有利的位置。比如，我们可能会花大量时间去写页面原型，以希望能够得到用户反馈。在确定得到用户反馈之后，我们可以完全放弃原型代码，进而可以得到更加符合现实（也更加简单）的代码。

#### 敏捷开发强调勇气这一价值观，正是要开发者去拥抱现实的变化，让开发者及软件朝着符合现实的路线走。

#### 迭代开发

#### 讲完四个价值观之后，接下来我把四个价值观联系起来，得到一个方法论——迭代开发。

#### 如图所示，简单是软件开发的起点，也是软件开发的终点。

#### 说它是起点，是因为，如果开发的东西还是复杂的，那就有必要把概念弄得简单一些。这包含两个方面的行动：一、把复杂的系统砍掉一半的功能（广度上）；二、尽可能对各个功能进行抽象（深度上，参考前面音乐软件的例子）。

#### 接下来，我们拿着简单的软件（或者软件原型）进入沟通环节。我们可以在两个方面进行沟通：一、与用户沟通软件的逻辑是否满足要求；二、与开发者沟通软件是否在技术上代价很高，如何权衡。

#### 沟通之后，我们可以得到现实的反馈，在现实的反馈之下，我们才有勇气进行改变，使用我们的软件继续维持其简单性。这就完成了软件的一个迭代。

### 敏捷方法

#### Scrum

##### Scrum是和种迭代式及递增式的敏捷软件开发框架，它用于管理软件项目，产品，或程序的开发。它的着重点是一个灵活的，全面的产品开发策略，它把一个开发团队通常作为一个单位进而实现一个常规目的。相反，它不着重于传递的序列化式的方法。Scrum会问传统瀑布式开发“为什么我们要花费这么长时间，这么多努力去做一件事？为什么我们不能衡量出做一件事所需时间和人力？” Scrum拥抱变化和创造力，因为这是人们的工作方式。Scrum有一个流程学习结构，能够让团队评估他们做了什么以及他们怎样做的。

##### Scrum角色

###### 产品持有人 Product Owner

####### 产品持有人代表着公司或股东的权益并传递客户的声音。

####### 专门负责确保商业价值

####### 制定以客户为中心的一些工作条目，排序后放到产品待处理列表（Product backlog）中。

####### Scrum团队应该有一个产品持有人，他/她也可以是开发团队中的一员。

####### 产品持有人不是Scrum领导者(ScrumMaster)。

###### 开发团队 Development Team

####### 在每一个Sprint周期结束后，负责交付将来需要发布的产品的模块。

####### 由3到9人组成并拥有各种所需技能（分析，设计，开发，测试，技术沟通，文档，等等）。

####### 自我组织，有可能需要与更高级的项目管理部门交流。

###### Scrum领导人 ScrumMaster

####### 专门负责扫清团队在交付Sprint目标或产品中遇到的障碍。

####### 不是团队领导人，但是扮演着团队与可能分散团队注意力的影响之间的缓冲区。

####### 确保Scrum流程的使用在计划中。

####### 规则强制执行人。团队保护者，以保持团队专注于他们手中的工作。

####### 也会被看作一个人民公仆去加强这些双重观点。

####### 不同于一个项目经理，没有与ScrumMaster不相关的人员管理职责

####### 没有任何额外的员工责任。

##### 会议

######   1、Sprint计划会议 

#######   Sprint是短距离赛跑的意思，这里面指的是一次迭代，而一次迭代的周期是1个月时间（即4个星期），也就是我们要把一次迭代的开发内容以最快的速度完成它，这个过程我们称它为Sprint。

###### 2、每日例会

####### 

###### 3、Sprint评审会议

####### 

###### 4、Sprint回顾会议

####### 

##### 三个构件

###### 1、产品Backlog  产品Backlog指根据初始需求分解出的任务列表，包括功能性和非功能性的所有功能。

####### Backlog未完成项列表

   * 产品的待完成项列表是一个需求的排列列表，我们维护这个列表是为了更好的开发产品。它的组成有功能，BUG修复，非功能需求等任何为了成功发布可用软件系统的所必须的内容。在Scrum中，开始一个项目不必先开发一个冗长文档去记录所有的需求。这个敏捷产品backlog对于第一个Sprint足够了。当有更多产品需求时和客户需求时，Scrum产品backlog允许变更和增加。

   * Sprint backlog是开发团队下个Sprint需要处理的工作列表。这个列表是产品backlog最上面的需求项衍生出来的，直到开发团队在这个Sprint中有足够的工作去做。开发团队通过问一些问题来完成backlog的选择，如“我们是不是也能做这个？”。

   * 从概念上讲，团队从优先级最高的Scrum backlog开始画一条线划分出优先级较低的项，同时线上面的backlog也是团队认为他们可以完成的项。在实践中，团队通常不会去选择优先级最高的五项再选择优先级较低的两项组合在一起即使它们是互相关联的。

######    2、Sprint Backlog Sprint Backlog就是任务列表，如果映射到传统的项目管理理论中就是WBS（work breakdown structure)，而且是典型的采用面向交付物的任务分解方法得到的WBS。

####### 任务看版包含 未完成、正在做、已完成 的工作状态，假设你今天把一个未完成的工作已经完成，那么你要把小卡片从未完成区域贴到已完成区域。

######    3、燃尽图。

##### 完成Scrum敏捷开发的流程为：

###### 第一步：Product Backing   找出完成产品需要做的事情。

###### 第二步:Sprint Backlog   决定当前冲刺需要解决的事情。

###### 第三步：Sprint   冲刺。

#######  1.我昨天做了什么。

####### 2.我今天要什么。

#######  3.我碰到了哪些问题。

###### 第四步：得到软件的一个增量版本，发布给用户。然后在此基础上进一步计划增量的新功能和改进。

##### Scrum开发的一些注意事项：

###### 1、我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；

###### 2、Scrum Team根据Product Backlog列表，做工作量的预估和安排；

###### 3、有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；

###### 4、Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；

###### 5、在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天 要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；

###### 6、做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可 以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本 发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；

###### 7、当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；

###### 8、最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；

##### 需求收集

###### 1.1  需求的分类

####### 需求可与分为业务团队的，也可以包括团度内部的，比如性能优化。

###### 1.2  需求提交模板

####### 需求种类	优先级	需求类型	需求标题	详细描述	验收条件	价值验证	提交时间	需求人	备注

   * ① 需求种类 可从以下四种情况中选择

      * – 概念想法

      * – 可用性问题（Bug）

      * – 任务

      * – 性能问题

      * 注意：即使是概念性的想法，目前技术上无法实现的想法都可以收集。

###### ② 优先级 可从以下五种情况中选择

####### – 普通

####### – 非常重要

####### – 特别的严重

####### – 很重要

####### – 低

####### 注意：切忌将所有的任务的优先级都设置的非常的高，这里不提供非常紧急这样的表述。我们只会根据重要程度去执行任务，所以紧急的任务需要业务部门及需求方尽早的提出。

###### ③ 需求类型 可以是两种类型

####### – 毛坯需求

####### – 详细需求

####### 注意：我们的需求并不是要求一定要完整的，及时是一些非常毛坯的需求，也可以提交过来，毛坯的需求由产品负责人进行分析和梳理，暂不清楚的可选择搁置。

###### ④ 需求标题 有自己进行书写，但是需要遵守的规范是采用动宾短语格式。

####### 比如：“导出+CN酒店每天的PV、UV等流量数据”

####### 注意：这里的需求内容一定是站长使用者角度是提出的，切勿出现专业的程序方面的表述：如添加一个导出的按钮。还有需要注意的是动词切忌使用大而宽泛的词，比如“管理”，类似“管理关键词”这样的需求是严格避免的，这样会使得要开发的内容变得没有清晰的边界。

###### ⑤ 详细描述 需要按照用户故事的格式进行书写。具体用户故事格式的要求如下：

####### 活动：需要完成什么样的功能。

####### 角色：谁要使用这个功能。

####### 商业价值：为什么需要这个功能，这个功能带来什么样的价值。

###### 用户故事是从用户的角度来描述用户渴望得到的功能。需要注意的是用户故事不能够使用技术语言来描述，要使用用户可以理解的业务语言来描述。一个好的用户故事包括三个要素：

####### 活动：需要完成什么样的功能。

####### 角色：谁要使用这个功能。

####### 商业价值：为什么需要这个功能，这个功能带来什么样的价值。

###### 用户故事通常按照如下的格式来表达：作为一个<角色>, 我想要<活动>, 以便于<商业价值>

###### 比如：作为一名酒店前端开发人员，我期望查看所有酒店页面的页面打开时间，以便了解哪些页面需要进行技能优化。

###### 一个好的用户故事同时要符合INVEST原则，INVEST原则分别是：

####### 短小（Small）: 一个好的故事在工作量上要尽量短小，最好不要超过8个人/天的工作量,至少要确保的是在一个迭代能够完成。用户故事越大，在安排计划，工作量估算等方面的风险就会越大。

####### 有价值（Valuable）: 每个故事必须对客户具有价值。一个让用户故事有价值的好方法是让客户来写下它们。一旦一个客户意识到这是一个用户故事并不是一个契约而且可以进行协商的时候，他们将非常乐意写下故事。

####### 独立性（Independent）: 要尽可能的让一个用户故事独立于其他的用户故事。用户故事之间的依赖使得制定计划，确定优先级，工作量估算都变得很困难。通常我们可以通过组合用户故事和分解用户故事来减少依赖性。

####### 可协商性（Negotiable）: 一个用户故事的内容要是可以协商的，用户故事不是合同。一个用户故事卡片上只是对用户故事的一个简短的描述，不包括太多的细节。具体的细节在沟通阶段产出。一个用户故事带有了太多的细节，实际上限制了和用户的沟通。

####### 可以估算性（Estimable）:开发团队需要去估计一个用户故事以便确定优先级，工作量，安排计划。但是让开发者难以估计故事的问题来自：对于领域知识的缺乏（这种情况下需要更多的沟通），或者故事太大了（这时需要把故事切分成小些的）。

####### 可测试性（Testable）: 一个用户故事要是可以测试的，以便于确认它是可以完成的。如果一个用户故事不能够测试，那么你就无法知道它什么时候可以完成。

###### 注意：

###### 角色的范围不能过大，比如是作为一名“用户”，这样是的不被接受的。

###### 商业价值也不能大而宽泛，比如，能为公司创造业绩。如果要写也一定要对业绩做初步估算，比如，预期会给公司带来每月1万张订单。

###### ⑥ 验收条件 是开发完成后检验的标准，所以一定要认真填写，否则可能开发出来的东西与预期不达标。

####### 4)   对于导出数据做好日志记录，后期可查是谁进行了导出。

####### 2)   导出的时间可以细化的天。即可导出每天的流量。

####### 以上面的“导出+CN酒店每天的PV、UV等流量数据”为例，它的验收条件可以为：

####### 1)   可以为每个用户设置是否拥有此导出权限

####### 3)   导出数据的最大时间跨度为31天

####### 5)   导出的字段包括：PV、UV、跳出率、新访客占比。

###### ⑦   价值验证 说明如何跟踪上线后的效果

##### Sprint 计划会议 1

###### 目标：定出 Sprint 目标和既定产品 Backlog。

###### 2.1 会议准备

####### □ Sprint 验收会议的时间安排

####### □ Sprint 的最后一天已确定

####### □ Sprint 计划会议 2 的时间安排

####### □ Sprint 时间表已经安排

####### □ 开发团队

####### □ 产品负责人

####### □ 在会议前一天确定议程，将目标和议程发送给所有与会者

####### □ 投影仪

####### □ 所有会议资源都已预订

####### □ 会议室

####### □ 笔记本

####### □ 原始需求人（可选择不来）

####### □ Scrum Master

####### □ 已按优先级排列产品 Backlog整理完毕

####### □ Sprint 计划会议 1 的时间安排

####### □ Sprint 的第一天已确定

####### □ Scrum 每日例会的时间安排

####### □ Sprint 回顾会议的时间安排

###### 2.2 会议议程

####### □ 如果对需求的优先级存在异议，可会上讨论，确定最终的执行顺序。

####### □ 产品负责人或者原始需求者负责解答不清楚的故事点。

####### □ 产品负责人向团队产品阐述需求（用户故事）

####### □ 把 Sprint 时间表公开给所有人

####### □ 开发人员对用户故事不清楚的点可以及时提出。

####### □ 如果讨论现场发现有遗漏的需求，可由产品负责人添加至产品Backlog。

####### □ 产品负责人& 需求方和小组成员相互认可这 Sprint 目标和既定产品 Backlog

###### 2.3 会议结果

####### □ 为 Sprint 计划会议2的进行准备好既定产品 Backlog

###### 2.4 补充内容

####### 需求种类	优先级	需求类型	需求标题	详细描述	验收条件	提交时间	需求人	备注	跟进人	预计完成时间	实际完成时间	Sprint版本号	处理情况

####### 产品Backlog模板（基本同需求模板）

####### 处理情况可从以下几种类型中选择

   * –    暂时搁置

   * –    已经完成

   * –    等待处理

   * –    正在进行

   * –    不予处理

   * –    需要讨论

##### Sprint 计划会议 2

###### 目标：确定所有任务，生成 Sprint Backlog，确认 Sprint 目标

###### 3.1 会议准备

####### □ Sprint 计划会议1中整理的既定产品 Backlog

####### □ 开发团队

####### □ 产品负责人

####### □ 要求原始需求者离开会议，参会人员为

####### □ Scrum Master

####### □ 在Sprint 计划会议1后10分钟举行

####### □  任务估时牌（按1,2,3,5,8,13估算）

###### 3.2 会议进程

####### □ 如果团队评估下来任务过多，可和产品负责人一起删减任务

####### □ 可看情况确定是否使用扑克估时

####### □ 部署

####### □ 学习新技术

####### □ 测试

####### □ 团队成员按顺序分析既定产品 Backlog的讨论实现细节

####### □ 编码

####### □ 代码审核

####### □ 编写文档

####### □ 上传

####### □ 任务超过一天时，需要拆成多个小任务

####### □ 如果团队评估下来任务过少，可和产品负责人一起从产品Blaclog中引入新的需求。

###### 3.3 会议结果

####### □ 将最终确认的可完成的需求清单邮件至

   * □ Scrum Master

   * □ 原始需求人

   * □ 产品负责人

   * □ 开发团队

####### □ 将最终确认的任务列表邮件至

   * □ Scrum Master

   * □ 产品负责人

   * □ 开发团队

###### 3.4 补充内容

####### 优先级	需求标题	详细描述	验收条件	需求人	跟进人	处理人	任务描述	处理日期	估时	实际耗时

####### Sprint Backlog模板

####### 需求和任务是一对多的关系，及一个需求可以产生多个任务，任务可以是程序类描述，如“数据数据库设计”

##### Scrum 每日例会

###### 目标：团队成员间工作进度的沟通和协调

###### 4.1 会议准备

####### □ 在 Sprint Backlog 上的所有任务都是可以增删修改，可重排序的

####### □ 外部团队协助人员（如有有需要的话）

####### □ 邀请与会者

####### □ 原始需求人（只有选择是否参加，过程中不可发言）

####### □ 一台电脑，中间标识任务的状态，可设为“待处理”，“正在处理”，“已完成”的。

###### 4.2 会议进程

####### □ 如果相关人员想发表些言论

####### □ 如果展开了一个问题的讨论

####### □ 有什么问题阻碍了你的开发

####### □ 如果任务可以在一天内完成：把任务状态设为“正在处理”

####### □ 如果任务不在 Sprint Backlog 上：添加这个任务

####### □ 下一次会议之前，你计划完成什么任务？

####### □ 上次会议时的任务哪些已经完成?

####### – 会议限定在15分钟内

####### 注意：

####### – 团队里的每个成员都必须回答以下三个问题，并考虑其相关的行动。

####### □把任务从“正在处理”状态转为“已完成”状态

####### □ 如果任务状态为“待处理”：转为“正在处理”状态

####### □ 如果任务不能在一天内完成：把这任务细分成多个任务

####### □ 如果任务状态已经是“正在处理”：询问是否存在阻碍任务完成得问题

####### □ 如果有阻碍你开发进度的问题：把该障碍加入到障碍 Backlog 中，Scrum Master负责记录

####### □ 提醒团队的成员们注意把精力集中在回答关键问题上

####### □ 礼貌地提醒他，该会议只允许让小组成员讨论

###### 4.3 会议结果

####### 4.4 障碍Backlog

####### □ 最新的工作进度图（燃尽图）

####### □ 得到最新的障碍 Backlog

####### □ 得到最新的 Sprint Backlog

####### □ 第一次的例会创建一封邮件，由Scrum Master会议后将例会内容回复此邮件。

####### 障碍 Backlog 列举了所有团队内部和团队相关的和阻碍项目进度的问题。Scrum Master 需要确保所有的障碍 Backlog 中的问题都已分配并可以得到解决。

   * 10 大典型障碍

      * –    团队的 Sprint Backlog 混乱

      * –    团队人数过多

      * –    并不是所有负责交付产品的人员都是团队里的成员

      * –    没有产品负责人负责回答提问

      * –    会议规则没能被遵循

      * –    产品远景和 Sprint 目标不清晰

      * –    产品 Backlog 未能按商业价值区分优先级

      * –    Scrum Master 还要处理其他任务，不能集中精力

      * –    团队没有能坐在一起工作的空间

      * –    中间遇到了技术难题

##### Sprint 验收会议

###### 目标：根据团队这次 Sprint 所发布的版本，评审相关的 Backlog 中的问题，检查是否已达到 Sprint 的目标。

###### 5.1 会议准备

####### □ 对于每个人来说 Sprint 目标都是公开的

####### □ Scrum Master

####### □ 原始需求人（可选择不来）

####### □ 笔记本

####### □ 会议室

####### □ 所有会议资源都已预订

####### □ 投影仪

####### □ 在会议前一天确定议程，将目标和议程发送给所有与会者

####### □ 产品负责人

####### □ 开发团队

####### □ 对每个人来说既定产品 Backlog 是公开的，可获取的

###### 5.2 会议进程

####### □ 如果对功能有一个新的想法：添加一个新问题到产品 Backlog 中

####### □ 团队按 Backlog 中的问题，逐个地介绍这次 Sprint 的结果，和演示新功能。

####### □ 如果产品负责人或需求方想要改变功能：添加一个新问题到产品 Backlog 中

####### □ 如果小组报告项目遇到阻碍现在还没能解决：把该障碍加入到障碍 Backlog

###### 5.3 会议结果

####### □ 对这次 Sprint 的结果和整个产品的开发状态的共识

##### Sprint 回顾会议

###### 目标：通过总结以往的实践经验来提高团队生产力。

###### 注意：主要指导原则：不管我们现在发现了什么问题，我们必须懂得并坚信每个人通过他们当时所知的，他所拥有的技能和可得到的资源，在限定的环境下，都尽其所能做出了最好的成绩。

###### 6.1 会议准备

####### □ 在白板上写上“谁负责”，然后分成两个区域——“团队”和“公司”

####### □ 在白板上写上“我们的成功经验是什么”

####### □ 在白板上写上主要指导原则

####### □ 便签纸

####### □ 产品负责人（可选）

####### □ Scrum Master

####### □ 邀请与会者：

####### □ 团队所有成员

####### □ 附属工具

####### □ 白板

####### □ 在白板上画上一个至少三页纸连在一起长的时间轴

####### □ 在白板上写上“有什么能够改进”

####### 附属工具：

###### 6.2 会议进程

####### □ 给会议做个总结

####### □ 把便签纸移到挂纸板中“谁负责”的区域中

####### □ 对于挂纸板上“有什么能够改进”的区域中的每一项

####### □ 分发便签纸，并让每人写上“有什么能够改进的”，限时5分钟

####### □ 分发便签纸，并让每人写上“我们的成功经验是什么”，限时5分钟

####### □ 派发便签，并且让每人写上他们认为这次 Sprint 中最为重要的事，限时 5 分钟

####### □ 在时间轴上，标记出 Sprint 的开始和结束时间

####### □ 介绍会议目标

####### □ 介绍会议主要指导原则

####### □ 向与会者解说如何使用该便签纸进行工作

####### □ 每个与会者轮流把他的贴纸贴到白板的时间轴上，并用两句话来解说这事有什么特别的地方

####### □ 每个与会者轮流把他的贴纸贴到白板“我们的成功经验是什么”的区域上，并解说。

####### □ 每个与会者轮流把他的贴纸贴到白板“有什么能够改进的”的区域上，并解说。

####### □ 询问团队“谁去负责解决这个问题？”

####### □ 和团队一起把这些区域按优先次序排好

####### □每个与会者对 Sprint 回顾会议作简短的回馈

###### 6.3 会议结果

####### □ 把与团队范围相关的障碍增加到障碍 Backlog 中去

####### □ 白板上“谁负责”这栏对于公司内所有人是公开的

####### □ 把与公司范围相关的障碍增加到障碍 Backlog 中去

####### □ 整理所有会议结果，邮件至团队中所有人

#### 极限编程XP

##### 极限编程是一个轻量级的、灵巧的软件开发方法；
同时它也是一个非常严谨和周密的方法。
它的基础和价值观是交流、朴素、反馈和勇气；
即，任何一个软件项目都可以从四个方面入手进行改善：加强交流；
从简单做起；寻求反馈；勇于实事求是。
XP是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；
通过积极的交流、反馈以及其它一系列的方法，
开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。

###### 开发人员知道要做什么，以及要优先做什么；

###### 工作有效率；

###### 有问题或困难时，能得到客户、同事、上级的回答或帮助；

###### 对工作做评估，并根据周围情况的变化及时重新评估；

###### 积极承担工作，而不是消极接受分配；

###### 一周40小时工作制，不加班。 

##### 与其他方法论相比，其最大的不同在于

###### 在更短的周期内，更早地提供具体、持续的反馈信息。

###### 在迭代的进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断的发展它。

###### 依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。

###### 依赖于口头交流、测试和源程序进行沟通。

###### 倡导持续的演化式设计。

###### 依赖于开发团队内部的紧密协作。

###### 尽可能达到程序员短期利益和项目长期利益的平衡。

##### 四大价值观

###### XP的核心是其总结的沟通、简单、反馈、勇气四大价值观，它们是XP的基础，也是XP的灵魂。

###### 1. 沟通

####### 通畅程序员给人留下的印象就是“内向、不善言谈”，然后项目中的许多问题就出在这些缺乏沟通的开发人员身上。经常由于某个程序员做出了一个设计决定，但是却不能及时地通知大家，结果使得大家在协作与配合上出现了很多的麻烦，而在传统的方法论中，并不在意这种口头沟通不畅的问题，而是希望借助于完善的流程和面面俱到的文档、报表、计划来替代，但是这同时又引入了效率不高的新问题。

####### XP方法论认为，如果小组成员之间无法做到持续的、无间断的交流，那么协作就无从谈起，从这个角度能够发现，通过文档、报表等人工制品进行交流面临巨大的局限性。因此，XP组合了诸如对编程这样的最佳实践，鼓励大家进行口头交流，通过交流解决问题，提高效率。

###### 2. 简单

####### 另外，在XP中提倡时刻对代码进行重构，一直保持其良好的结构与可扩展性。也就是说，可扩展性和为明天设计并不是同一个概念，XP是反对为明天考虑而工作，并不是说代码要失去扩展性

####### 正如对传统开发方法的认识一样，许多开发人员也会质疑XP，保持系统的扩展性很重要，如果都保持简单，那么如何使得系统能够有良好的扩展性呢？其实不然，保持简单的理由有两个：

####### XP方法论提倡在工作中秉承“够用就好”的思路，也就是尽量地简单化，只要今天够用就行，不考虑明天会发现的新问题。这一点看上去十分容易，但是要真正做到保持简单的工作其实很难的。因为在传统的开发方法中，都要求大家对未来做一些预先规划，以便对今后可能发生的变化预留一些扩展的空间。

####### 开发小组在开发时所做的规划，并无法保证其符合客户需要的，因此做的大部分工作都将落空，使得开发过程中重复的、没有必要的工作增加，导致整体效率降低。

####### 而且简单和沟通之间还有一种相对微妙的相互支持关系。当一个团队之间，沟通的越多，那么就越容易明白哪些工作需要做，哪些工作不需要做。另一方面，系统越简单，需要沟通的内容也就越少，沟通也将更加全面。

###### 3. 反馈

####### 在开发过程中，还应该加强集成工作，做到持续集成，使得每一次增量都是一个可执行的工作版本，也就是逐渐是软件长大，整个过程中，应该通过向客户和管理层演示这些可运行的版本，以便及早地反馈，及早地发现问题。

####### 而且在项目的过程中，这样的现象不仅出现在开发团队与客户、管理层之间，还包括在开发团队内部。这一切问题都需要我们更加注重反馈。，反馈对于任何软件项目的成功都是至关重要的，而在XP方法论中则更进一步，通过持续、明确的反馈来暴露软件状态的问题。具体而言就是：

####### 是什么原因使得我们的客户、管理层这么不理解开发团队？为什么客户、管理层总是喜欢给我们一个死亡之旅？究其症结，就是开发的过程中缺乏必要的反馈。在许许多多项目中，当开发团队经历过了需求分析阶段之后，在相当长的一段时间内，是没有任何反馈信息的。整个开发过程对于客户和管理层而言就像一个黑盒子，进度完全是可见的。

####### 在开发团队内部，通过提前编写单元测试代码，时时反馈代码的问题与进展。

####### 同时，我们也会发现反馈与沟通也有着良好的配合，及时和良好的反馈有助于沟通。而简单的系统更有利于测试盒反馈。

###### 4. 勇气

####### 也就是XP方法论要求开发人员穿上强大、自动测试的盔甲，勇往直前，在重构、编码规范的支持下，有目的地快速开发。

####### 在应用XP方法论时，我们每时每刻都在应对变化：由于沟通良好，因此会有更多需求变更的机会；由于时刻保持系统的简单，因此新的变化会带来一些重新开发的需要；由于反馈及时，因此会有更多中间打断你的思路的新需求。

####### 总之这一切，使得你立刻处于变化之中，因此这时就需要你有勇气来面对快速开发，面对可能的重新开发。也许你会觉得，为什么要让我们的开发变得如此零乱，但是其实这些变化若你不让它早暴露，那么它就会迟一些出现，并不会因此消亡，因此，XP方法论让它们早出现、早解决，是实现“小步快走”开发节奏的好办法。

####### 勇气可以来源于沟通，因为它使得高风险、高回报的试验成为可能；勇气可以来源于简单，因为面对简单的系统，更容易鼓起勇气；勇气可以来源于反馈，因为你可以及时获得每一步前进的状态（自动测试），会使得你更勇于重构代码。

###### 5. 四大价值观之外

###### 在这四大价值观之下，隐藏着一个更深刻的东西，那就是尊重。因为这一切都建立在团队成员之间的相互关心、相互理解的基础之上。

##### 5个原则

###### 1. 快速反馈

####### 及时地、快速地获取反馈，并将所学到的知识尽快地投入到系统中去。也就是指开发人员应该通过较短的反馈循环迅速地了解现在的产品是否满足了客户的需求。这也是对反馈这一价值观的进一步补充。

###### 2. 简单性假设

####### 类似地，简单性假设原则是对简单这一价值观的进一步补充。这一原则要求开发人员将每个问题都看得十分容易解决，也就是说只为本次迭代考虑，不去想未来可能需要什么，相信具有将来必要时增加系统复杂性的能力，也就是号召大家出色地完成今天的任务。

###### 3. 逐步修改

####### 就像开车打方向盘一样，不要一次做出很大的改变，那样将会使得可控性变差，更适合的方法是进行微调。而在软件开发中，这样的道理同样适用，任何问题都应该通过一系列能够带来差异的微小改动来解决。

###### 4. 提倡更改

####### 在软件开发过程中，最好的办法是在解决最重要问题时，保留最多选项的那个。也就是说，尽量为下一次修改做好准备。

###### 5. 优质工作

####### 在实践中，经常看到许多开发人员喜欢将一些细小的问题留待后面解决。例如，界面的按钮有一些不平整，由于不影响使用就先不管；某一两个成员函数暂时没用就不先写等。这就是一种工作拖泥带水的现象，这样的坏习惯一旦养成，必然使得代码质量大打折扣。

####### 而在XP方法论中，贯彻的是“小步快走”的开发原则，因此工作质量决不可打折扣，通常采用测试先行的编码方式来提供支持。

##### 13个最佳实践

###### 在XP中，集成了13个最佳实践，有趣的是，它们没有一个是创新的概念，大多数概念和编程一样老。其主要创新点在于提供一种良好的思路，将这些最佳实践结合在一起，并且确保尽可能彻底地执行它们，使得它们能够在最大程度上相互支持，紧接下来，我们就对每一种最佳实践进行一番了解。

###### 1. 计划游戏

####### 开发人员进行估算：首先客户按优先级将用户故事分成必须要有、希望有、如果有更好三类，然后开发人员对每个用户故事进行估算，先从高优先级开始估算。如果在估算的时候，感到有一些故事太大，不容易进行估算，或者是估算的结果超过2人/周，那么就应该对其进行分解，拆成2个或者多个小故事。

####### 好了，明白这些就可以进行计划游戏了。首先客户和开发人员坐在同一间屋子里，每个人都准备一支笔、一些用于记录用户故事的纸片，最好再准备一个白板，就可以开始了。

####### 计划游戏的主要思想就是先快速地制定一份概要的计划，然后随着项目细节的不断清晰，再逐步完善这份计划。计划游戏产生的结果是一套用户故事及后续的一两次迭代的概要计划。

####### “客户负责业务决策，开发团队负责技术决策”是计划游戏获得成功的前提条件。也就是说，系统的范围、下一次迭代的发布时间、用户故事的优先级应该由客户决定；而每个用户故事所需的开发时间、不同技术的成本、如何组建团队、每个用户故事的风险，以及具体的开发顺序应该有开发团队决定。

####### 客户编写故事：由客户谈论系统应该完成什么功能，然后用通俗的自然语言，使用自己的语汇，将其写在卡片上，这也就是用户故事。

####### 确定迭代的周期：接下来就是确定本次迭代的时间周期，这可以根据实际的情况进行确定，不过最佳的迭代周期是2~3周。有了迭代的时间之后，再结合参与的开发人数，算出可以完成的工作量总数。然后根据估算的结果，与客户协商，挑出时间上够、优先级合适的用户故事组合，形成计划。

###### 2. 小型发布

####### XP方法论秉承的是“持续集成，小步快走”的哲学，也就是说每一次发布的版本应该尽可能的小，当然前提条件是每个版本有足够的商业价值，值得发布。

####### 由于小型发布可以使得集成更频繁，客户获得的中间结果也越频繁，反馈也就越频繁，客户就能够实时地了解项目的进展情况，从而提出更多的意见，以便在下一次迭代中计划进去。以实现更高的客户满意度。

###### 3. 隐喻

####### 描述体系结构：体系结构是比较抽象的，引入隐喻能够大大减轻理解的复杂度。例如管道体系结构就是指两个构件之间通过一条传递消息的“管道”进行通信。

####### 发明共享词汇：通过隐喻，有助于提出一个用来表示对象、对象间的关系通用名称。例如，策略模式（用来表示可以实现多种不同策略的设计模式）、工厂模式（用来表示可以按需“生产”出所需类得设计模式）等。

####### 相对而言，隐喻这一个最佳实践是最令人费解的。什么是隐喻呢？根据词典中的解释是：“一种语言的表达手段，它用来暗示字面意义不相似的事物之间的相似之处”。那么这在软件开发中又有什么用呢？总结而言，常常用于四个方面。

####### 寻求共识：也就是鼓励开发人员在寻求问题共识时，可以借用一些沟通双方都比较熟悉的事物来做类比，从而帮助大家更好地理解解决方案的关键结构，也就是更好地理解系统是什么、能做什么。

####### 创新的武器：有的时候，可以借助其他东西来找到解决问题的新途径。例如：“我们可以将工作流看做一个生产线”。

####### 当然，如果能够找到合适的隐喻是十分快乐的，但并不是每种情况都可以找到恰当的隐喻，你也没有必要强求

###### 4. 简单设计

####### 使用Demeter（迪米特）法则：迪米特法则，也称为LoD法则、最少知识原则。也就是指一个对象应当对其他对象尽可能少地了解。用隐喻的方法来解释的话就是“只与你直接的朋友通信”、“不要和陌生人说话”。

####### 首先写测试代码：具体将在后面详细描述。

####### 他认为要想保持设计简单的系统，需要具备简单思考的能力，拥有理解代码和修改的勇气，以及为了消除代码的“坏味道”而定期重构的习惯。

####### 清楚地表现了程序员赋予的所有意图。

####### 能够通过所有的测试程序。

####### 强调简单设计的价值观，引出了简单性假设原则，落到实处就是“简单设计”实践。这个实践看上去似乎很容易理解，但却又经常被误解，许多批评者就指责XP忽略设计是不正确的。其实，XP的简单设计实践并不是要忽略设计，而且认为设计不应该在编码之前一次性完成，因为那样只能建立在“情况不会发生变化”或者“我们可以预见所有的变化”之类的谎言的基础上的。

####### Kent Beck概念中简单设计是这样的：

####### 没有包括任何重复的代码。

####### 包括尽可能少的类和方法

####### 那么如何开始进行简单的设计呢？XP实践者们也总结也一些具体的、可操作的思考方法。

####### 保持每个类只负责一件事：SRP（单一职责原则）是面向对象设计的基础原则之一。

####### 使用CRC卡片进行探索。

###### 5. 测试先行

####### 工匠一：先拉上一根水平线，砌每一块砖时，都与这跟水平线进行比较，使得每一块砖都保持水平。

####### 你会选择哪种工作方法呢？你一定会骂工匠二笨吧！这样多浪费时间呀！然而你自己想想，你平时在编写程序的时候又是怎么做的呢？我们就是按工匠二的方法在工作呀！甚至有时候比工匠二还笨，是整面墙都砌完了，直接进行“集成测试”，经常让整面的墙倒塌。看到这里，你还会觉得自己的方法高明吗？这个连工匠都明白的道理，自己却画地为牢呀。

####### 为了鼓励程序员原意甚至喜欢在编写程序之前编写测试代码，XP方法论还提供了许多有说服力的理由。

####### 如果你在结对编程，那么如果你想出一个好的测试代码，那么你的伙伴一定行。

####### 当你的客户看到所有的测试都通过的时候，会对程序充满前所未有的信心。

####### 测试先行是XP方法论中一个十分重要的最佳实践，并且其中所蕴含的知识与方法也十分丰富。

####### 当你需要进行重构时，测试代码会给你带来更大的勇气，因为你要测试是否重构成功只需要一个按钮。

####### 当所有的测试都通过的时候，你再也不会担心所写的代码今后会“暗箭伤人”，那种感觉是相当棒的。

####### 如果你已经保持了简单的设计，那么编写测试代码根本不难。

####### 不仅我们没有采用工匠一的工作方法，甚至有的时候程序员会以“开发工作太紧张”为理由，而忽略测试工作。但这样却导致了一个恶性循环，越是没有空编写测试程序，代码的效率与质量越差，花在找Bug、解决Bug的时间也越来越多，实际产能大打降低。由于产能降低了，因此时间更紧张，压力更大。你想想，为什么不拉上一根水平线呢？难道，我们不能够将后面浪费的时间花在单元测试上，使得我们的程序一开始就更健壮，更加易于修改吗？不过，编写测试程序当然要比拉一条水平线难道多，所以我们需要引入“自动化测试工具”，免费的xUnit测试框架就是你最佳的选择。

####### 工匠二：先将一排砖都砌完，然后再拉上一根水平线，看看哪些砖有问题，对有问题的砖进行适当的调整。

####### 当我第一次看到“测试先行”这个概念的时候，我的第一感觉就是不解，陷入了“程序都还没有写出来，测试什么呀？”的迷思。我开始天马行空地寻求相关的隐喻，终于找到了能够启发我的工匠，首先，我们来看看两个不同的工匠是如何工作的吧。

###### 6. 重构

####### 实现某个特性之前：尝试改变现有的代码结构，以使得实现新的特性更加容易。

####### 在《重构》一书中，作者Martin Fowler提示我们：在考虑重构时，应该要养成编写并经常运行测试代码的习惯；要先编写代码，再进行重构；把每一次增加功能都当做一次重构的好时机；将每一个纠正错误当做一次重构的重要时机。同时，该书中也列出大量需要重构的情况和重构方法。

####### XP提倡集体代码所有制，因此你可以大胆地在任何需要修改的地方做改动。

####### 在重构中遇到困难，和你结对编程的伙伴能够为你提供有效的帮助。

####### 测试先行让你拥有了一个有效的检验器，随时运行一下就知道你重构的工作是否带来了影响。

####### 重构技术是对简单性设计的一个良好的补充，也是XP中重视“优质工作”的体现，这也是优秀的程序员必备的一项技能。

####### 由于XP在持续集成，因此你重构所带来的破坏很快就能够暴露，并且得以解决。

####### 简单的设计，会给重构带来很大的帮助。

####### 由于在XP项目组中有完整的编码标准，因此在重构前无须重新定义格式。

####### 最后类似地，给还没有足够勇气进行重构的程序员打几剂强心针：

####### 实现某个特性之后：检查刚刚写完的代码后，认真检查一下，看是否能够进行简化。

####### 重构时一种对代码进行改进而不影响功能实现的技术，XP需要开发人员在闻到代码的坏味道时，有重构代码的勇气。重构的目的是降低变化引发的风险，使得代码优化更加容易。通常重构发生在两种情况之下。

###### 7. 结对编程

####### 不过，自从20世纪60年代，就有类似的实践在进行，长期以来的研究结果却给出了另外一番景象，那就是结对编程的效率反而比单独编程更高。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐渐加快，究其原因，主要是结对编程大打降低了沟通的成本，提供了工作的质量，具体表现在：

####### 系统的任何一个部分都肯定至少有2个人以上熟悉。

####### 结对组合的动态性，是一个企业知识管理的好途径。

####### 而且XP方法论集成的其他最佳实践也能够使得结对编程更加容易进行：

####### 隐喻可以帮助结对伙伴更好地沟通。

####### 结对编程技术被誉为XP保持工作质量、强调人文主义的一个典型的实践，应用得当还能够使得开发团队之前的协作更加流畅、知识交流与共享更加频繁，团队的稳定性也会更加稳固。

####### 简单设计可以使得结对伙伴更了解他们所从事的工作。

####### 编码标准可以消除一些无谓的分歧。

####### 代码总是能够保证被评审过。

####### 几乎不可能有2个人都忽略的测试项或者其他任务

####### 所有的设计决策确保不是由一个人做出的。

####### “什么！两个人坐在一起写程序？那岂不是对人力的巨大浪费吗？而且我在工作时可不喜欢有一个人坐在边上当检察官。”是的，正如这里列举出来的问题一样，结对编程技术还是被很多人质疑的。

###### 8. 集体代码所有制

####### 也就是说，团队中的每个成员都拥有对代码进行改进的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时，XP强调代码是谁破坏的（也就是修改后发生问题），就应该由谁来修复。

####### 由于在XP项目中，集成工作是一件经常性得工作，因此当有人修改代码而带来了集成的问题，会在很快的时间内被发现。

####### 由于每一个代码的修改就是通过了结对的两个程序员共同思考，因此通常做出的修改都是对系统有益的。

####### 集成代码所有制是XP与其他敏捷方法的一个较大不同，也是从另一个侧面体现了XP中蕴含的很深厚的编码情节。

####### 由于大家都坚持了相同的编码标准，因此代码的可读性、可修改性都会比较好，而且还能够避免由于命名法、缩进等小问题引发经常性得代码修改。

####### 由于每一个类都会有一个测试代码，因此不论谁修改了代码，都需要运行这个测试代码，这样偶然性的破坏发生的概率将很小。

####### 由于在XP中，有一些与之匹配的最佳实践，因此你并无须担心采用集体代码所有制会让你的代码变得越来越乱：

####### 由于XP方法论鼓励团队进行结对编程，而且认为结对编程的组合应该动态地搭配，根据任务的不同、专业技能的不同进行最优组合。由于每个人都肯定会遇到不同的代码，所以代码的所有制就不再适合于私有，因为那样会给修改工作带来巨大的不便。

###### 9. 持续集成

####### 这样，就可以及早地暴露、消除由于重构、集体代码所有制所引入的错误，从而减少解决问题的痛苦

####### 在前面谈到小型发布、重构、结对编程、集体代码所有制等最佳实践的时候，我们多次看到“持续集成”的身影，可以说持续集成是对这些最佳实践的基本支撑条件。

####### 可能大家会对持续集成与小型发布代表的意思混淆不清，其实小型发布是指在开发周期经常发布中间版本，而持续集成的含义则是要求XP团队每天尽可能多次地做代码集成，每次都在确保系统运行的单元测试通过之后进行。

####### 要在开发过程中做到持续集成并不容易，首先需要养成这个习惯。而且集成工作往往是十分枯燥、烦琐的，因此适当地引入每日集成工具是十分必要的。XP建议大家首先使用配置管理服务器将代码管理起来，然后使用Ant或Nant等XP工具，编写集成脚本，调用xUint等测试框架，这样就可以实现每当程序员将代码Check in到配置服务器上时，Ant就会自动完成编译和集成，并调用测试代码完成相应的测试工作。

###### 10. 每周工作40小时

####### Kent Beck认为开发人员即使能够工作更长的时间，他们也不该这样做，因为这样做会使他们更容易厌倦编程工作，从而产生一些影响他们效能的其他问题。因此，每周工作40小时是一种顺势行为，是一种规律。其实对于开发人员和管理者来说，违反这种规律是不值得的。

####### 管理者：也许这可以称得上“第二种人月神话”，那就是你不得不通过延长每天的工作时间来获得更多的人月。这是因为，每个开发人员的工作精力是有限的，不可能无限增长，在精力不足的时候，不仅写出来的代码质量没有保障，而且还可能为项目带来退步的效果。因此采用加班的方式并不是一个理性的方式，是得不偿失的。

####### 不过有一点是需要解释的，“每周工作40小时”中的40不是一个绝对数，它所代表的意思是团队应该保证按照“正常的时间”进行工作。那么如何做到这一点呢？

   * 其次，逐步将工作时间调整到“正常工作时间”。

   * 最后，鼓起勇气，制定一个合情合理的时间表。

   * 正如米卢说过的“享受足球”一样，同样地，每一个开发人员应该做到“享受编程”，那么“每周工作40小时”就是你的起点。

   * 再次，除非你的时间计划一团糟，否则不应该在时间妥协。

   * 首先，定义符合你团队情况的“正常工作时间”。

####### 开发人员：如果不懂得休息，那么就无法将自己的节奏调整到最佳状态，那么就会带来很大的负面影响。而且在精神不集中的状态下，开发质量也得不到保证。

####### 这是最让开发人员开心的、管理者反对的一个最佳实践了，加班、再加班早已成为开发人员的家常便饭，也是管理者最常使用的一种策略，而XP方法论认为，加班最终会扼杀团队的积极性，最终导致项目失败，这也充分体现了XP方法关注人的因素比关注过程的因素更多一些。

###### 11. 现场客户

####### 也许有人会问，客户提交了用户故事之后不就完成工作了吗？其实很多尝试过用户故事的团队都会发现其太过简单，包含的信息量极少，XP方法论不会不了解，因此，不会把用户故事当做开发人员交付代码的唯一指示。用户故事只是一个起点，后面的细节还需要开发人员与客户之间建立起来的良好沟通来补充。

####### 其实现场客户在具体实施时，也不是一定需要客户一直和开发团队在一起，而是在开发团队应该和客户能够随时沟通，可以是面谈，可以是在线聊天，可以是电话，当然面谈是必不可少的。其中的关键是当开发人员需要客户做出业务决策是，需要进一步了解业务细节时能够随时找到相应的客户。

####### 当开发组织中已经有相关的领域专家时。

####### 去尝试吧，现场客户不仅可以争取得到，而且还能使得团队焕然一新，与客户建立起良好的合作与信任。

####### 当做一些探索性工作，而且客户也不知道他想要什么时（例如新产品、新解决方案的研究与开发）。

####### 不过，也有一些项目是可以不要现场客户参与的：

####### 作为一名有经验的开发人员，绝对不会对现场客户的价值产生任何怀疑，但是都会觉得想要实现现场客户十分困难。要实现这一点，需要对客户进行沟通，让其明白，想对于开发团队，项目成功对于客户而言更为重要。而现场客户则是保障项目成功的一个重要措施，想想在你装修房子的时候，你是不是常常在充当现场客户的角色呢？其实这隐喻就是让客户理解现场客户重要性最好的突破口。

####### 为了保证开发出来的结果与客户的预想接近，XP方法论认为最重要的需要将客户请到开发现场。就像计划游戏中提到过的，在XP项目中，应该时刻保证客户负责业务决策，开发团队负责技术决策。因此，在项目中有客户在现场明确用户故事，并做出相应的业务决策，对于XP项目而言有着十分重要的意义。

###### 12. 编码标准

####### 不过，XP方法论的编码标准的目的不是创建一个事无巨细的规则表，而是只要能够提供一个确保代码清晰，便于交流的指导方针。

####### 如果你的团队已经拥有编码标准，就可以直接使用它，并在过程中进行完善。如果还没有，那么大家可以先进行编码，然后在过程中逐步总结出编码规则，边做边形成。当然除了这种文字规范以外，还可以采用一些如自动格式化代码工具之类的方法进行代码规范。，事实上，你只需要很好地贯彻执行其他的实践并且进行沟通，编码标准会很容易地浮现出来。

####### 编码标准是一个“雅俗共享”的最佳实践，不管是代表重型方法论的RUP，PSP，还是代表敏捷方法论的XP，都认为开发团队应该拥有一个编码标准。XP方法论认为拥有编码标准可以避免团队在一些与开发进度无关的细节问题上发生争论，而且会给重构、结对编程带来很大麻烦。试想如果有人将你上次写的代码的变量命名法做了修改，下次你需要再改这部分代码时，会是一种什么感觉呢？

###### 13. 配合是关键

###### 有句经典名言“1+1>2”最适合表达XP的观点，Kent Beck认为XP方法论的最大价值在于在项目中融会贯通地运用12个最佳实践，而非单独地使用。你当然可以使用其中的一些实践，但这并不意味着你就运用了XP方法论。XP方法论真正能够发挥其效能，就必须完整地运用12个实践。

#### 水晶方法

##### 水晶方法，Crystal ，
是由 Alistair Cockburn 和 Jim Highsmith 建立的敏捷方法系列，
其目的是发展一种提倡“机动性的”方法，
包含具有共性的核心元素，每个都含有独特的角色、过程模式、工作产品和实践。
Crystal 家族实际上是一组经过证明、对不同类型项目非常有效的敏捷过程，
它的发明使得敏捷团队可以根据其项目和环境选择最合适的 Crystal 家族成员。
水晶系列与XP一样，都有以人为中心的理念，但在实践上有所不同。

##### 七大特征

###### 体系特征一：经常交付

###### 体系特征二：反思改进

###### 体系特征三：渗透式交流

###### 体系特征四：个人安全

###### 体系特征五：焦点

###### 体系特征六：与专家用户建立方便的联系

###### 体系特征七：配有自动测试、配置管理和经常集成功能的技术环境

#### DSDM-动态系统开发方法

##### Dynamic System Development Management，
它倡导以业务为核心，快速而有效地进行系统开发。
实践证明DSDM是成功的敏捷开发 方法之一。
在英国，由于其在各种规模的软件组织中的成功，
它已成为应用最为广泛的快速应用开发方法。
主要内容：DSDM如何加快产品的 交付，
为什么像DSDM这样的敏捷开发方法能够快速体现所开发系统给业务带来的好处，
如何组织用户参与项目以开发出可用的系统，
如何将不同知识背景的人组 成一个团队，
如何应对常规的业务约束以进行项目管理。

##### 基本原则

###### 原则1：用户必须持续参与 active user involvement is imperative

###### 原则2：必须授予DSDM团队制定决策的权利 DSDM teams are empowered to make decisions including refining or changing requirements without the direct involvement of higher management

###### 原则3：注重产品的经常交付 The focus is on frequent product delivery

###### 原则4：满足业务用户用途是接受交付品的主要依据 Fitness for purpose is the key criterion

####### 开发人员不必沉溺于完美的 解决方案之中，耽误项目时间。在受限的时间内，实现业务利益最大化的交付品才是最重要的。

###### 原则5：迭代和增量式开发对得到正确的业务解决方案是必不可少的 Iterative and incremental development is necessary to converge on an accurate business solution

####### 采用迭代开发的方法，能够使业务流程逐步进化，使系统不断朝着满足业务需求的方向前进。

###### 原则6：开发过程的所有变化可逆 All changes during development are reversible

####### 采用迭代和增量式开发过程中，很可能会碰到走错的情况，此时需要回退到一个已知的可靠的点上。

###### 原则7：在高层次上制定需求的基线 Requirements are initially agreed at a high level

####### 在业务研究中所得出的需求必须在高层次上达成一致。接下来在迭代过程中再得到详细的需求。

###### 原则8：测试自始至终贯穿于开发周期之中 Testing is integrated throughout the life cycle — this is essential with an incremental approach

####### 开发人员完成一个模块的开发后，自己会进行单元测试。当模块集成到现有系统后，测试人员需要执行集成测试。另外，回归测试在DSDM中占有很重 要的地位。

###### 原则9：所有项目涉众间的通力合作是不可获缺的 A collaborative and co-operative approach between all stakeholders is essential 

#### 测试驱动开发

##### 测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码，然后只编写使测试通过的功能代码，从而以测试来驱动整个开发过程的进行。这有助于编写简洁可用和高质量的代码，有很高的灵活性和健壮性，能快速响应变化，并加速开发过程。

##### 测试驱动开发的基本过程如下：

###### ①　快速新增一个测试

###### ②　运行所有的测试（有时候只需要运行一个或一部分），发现新增的测试不能通过

###### ③　做一些小小的改动，尽快地让测试程序可运行，为此可以在程序中使用一些不合情理的方法

###### ④　运行所有的测试，并且全部通过

###### ⑤　重构代码，以消除重复设计，优化设计结构

##### 简单来说，就是不可运行/可运行/重构——这正是测试驱动开发的口号。
测试驱动开发不是一种测试技术，它是一种分析技术、设计技术，更是一种组织所有开发活动的技术。
相对于传统的结构化开发过程方法优势:

###### 1) TDD根据客户需求编写测试用例，对功能的过程和接口都进行了设计，而且这种从使用者角度对代码进行的设计通常更符合后期开发的需求。因为关注用户反馈，可以及时响应需求变更，同时因为从使用者角度出发的简单设计，也可以更快地适应变化。

###### 2) 出于易测试和测试独立性的要求，将促使我们实现松耦合的设计，并更多地依赖于接口而非具体的类，提高系统的可扩展性和抗变性。而且TDD明显地缩短了设计决策的反馈循环，使我们几秒或几分钟之内就能获得反馈。

###### 3) 将测试工作提到编码之前，并频繁地运行所有测试，可以尽量地避免和尽早地发现错误，极大地降低了后续测试及修复的成本，提高了代码的质量。在测试的保护下，不断重构代码，以消除重复设计，优化设计结构，提高了代码的重用性，从而提高了软件产品的质量。

###### 4) TDD提供了持续的回归测试，使我们拥有重构的勇气，因为代码的改动导致系统其他部分产生任何异常，测试都会立刻通知我们。完整的测试会帮助我们持续地跟踪整个系统的状态，因此我们就不需要担心会产生什么不可预知的副作用了。

###### 5) TDD所产生的单元测试代码就是最完美的开发者文档，它们展示了所有的API该如何使用以及是如何运作的，而且它们与工作代码保持同步，永远是最新的。

###### 6) TDD可以减轻压力、降低忧虑、提高我们对代码的信心、使我们拥有重构的勇气，这些都是快乐工作的重要前提。

###### 7)快速的提高了开发效率。

##### ，

#### Lean软件开发（精益软件开发）

##### 面对开发团队以及最终的产品大小的额外挑战，可以说软件开发是个持续学习的过程。最佳的改善软件开发环境的做法就是增强学习。在代码完成后马上进行测试可以避免缺陷的累积。不是去做成更多的文档或详细设计，而是对各种各样的想法进行实际的编码尝试。用户需求的收集过程可以简单地通过给最终客户演示，并听取他们的反馈来完成。

##### 使用短周期的迭代（每个迭代都应包括重构和集成测试）可以加速学习过程。在决定当前阶段的开发内容并对未来改善的努力方向进行调整时，在客户端帮助下通过简短的反馈会议来增强反馈。通过这些简短的反馈会议，客户代表和开发团队会更多地发现在进一步开发时会遇到的主要问题及可能的解决方案。从而，基于已开发出的原型，客户可以更好地理解自己的需求，开发者也能了解到如何才能更好地满足客户的需求。另一个关于和客户沟通、学习的想法是“基于组的开发”，这种方法聚焦于未来解决方案的约束限定而不是各种可能的解决方案，因此通过和客户的对话加速了解决方案的产生。

##### 原则

###### 消除浪费

###### 增强学习

###### 尽量延迟决定

###### 尽快发布

###### 下放权力

###### 嵌入质量

###### 全局优化

#### 轻量型RUP

#####   RUP其实是个过程的框架，它可以包容许多不同类型的过程， Craig Larman 极力主张以敏捷型方式来使用RUP。
他的观点是:目前如此众多的努力以推进敏捷型方法，只不过是在接受能被视为RUP 的主流OO开发方法而已。

##### RUP 是一种以架构为中心的开发过程，而这正是大、中型项目成功的关键。

##### RUP（Rational Unified Process）是一个风险驱动的基于UML 和构件式架构的迭代递增型开发过程（框架）。RUP 定义了4 个阶段（起始、细化、构造、移交）和9 个科目（业务建模、需求、分析和设计、实现、测试、部署、配置和变更管理、项目管理、环境）。这些阶段对应着关键里程碑的划分，而不同科目的工作流和活动 在生命周期的迭代中可以并发进行，具体执行的程度则可以调节。RUP 对于角色、流程、工件和活动的要求是灵活的、可配置的，所以它广泛地适用于各种类型和规模的项目。RUP 集中体现了6 个软件开发的最佳实践方法：迭代式开发、需求管理、构件式架构、基于UML 的可视化建模、持续校验质量、变更管理。

##### RUP认为下面这些最佳实践可以改善软件的开发状况：

###### 在早期迭代中解决高风险和高价值的问题

###### 不断的让用户参与评估、反馈和需求

###### 在早期迭代中建立内聚的核心架构

###### 不断地验证质量：提早、经常和实际的测试

###### 可视化软件建模（使用UML）

###### 仔细的管理需求

###### 实行变更请求和配置管理

##### 四个阶段

###### 初始阶段（Inception)：
预见项目的范围、构想和业务案例 （Lifecycle Objective）

####### 初始阶段不是一个需求阶段，而是类似与可行性阶段，项目相关人员是否就项目的构想达成基本的一致，项目是否值得继续进行认真的研究

####### 时间不应超过一周，只需要确定这个项目是否值得认真研究，而不是真正去深入研究项目（这个工作留待细化阶段进行）如果预选就决定项目必须进行，而且项目明显是可行的，那么初始阶段会很短，可能只包含一次需求研讨会，并为第一次迭代执行计划，然后就快速的进入细化阶段

####### 主要实践活动－用例建模

####### 对于迭代开发的一个关键理解在于：过程中的工件在初始阶段只是部分完成，在之后的迭代中在逐步精化提炼。例如，用例模型可以列举大多数所需的用例和参与者，但其中可能只有10％的用例会被详细描述，这样就足以建立起有关系统的范围、目标和风险的高层的大致构想。

####### 主要工件：是否意味着大量的文档？工件是可选的，只需要从下面选择对项目确实有价值的工件，放弃哪些不必要的工件，工件的关键不是文档或图表本身，而是其中蕴含的思想、分析和前期准备。

   * 构想和业务案例：描述高层的目标和约束、业务案例，并提供一个执行摘要

   * 用例模型：描述功能需求和相关的非功能需求

   * 补充规范：描述其他需求

   * 术语表：关键的领域术语

   * 风险列表和风险管理计划：描述业务、技术、资源和进度的风险，以及如何减轻这些风险或该如何应对

   * 原型和概念验证：阐明构想，验证技术问题。

   * 迭代计划：描述在第一次细化迭代中该作什么

   * 阶段计划和软件开发计划：对细化阶段的持续时间和工作量进行低精度的猜测。开发涉及的工具、人员、培训和其他资源

   * 开发案例：描述为本项目定制的统一过程的步骤和工件。在统一过程中，总需要为项目定制一些步骤或工件

###### 细化阶段（Elaboration）：
已精化的构想，核心架构的迭代实现，高风险的解决，大多数需求和范围的识别，更为现实的评估。 （Lifecycle Architecture）

####### 细化阶段不是一个需求或设计阶段，而是一个迭代实现核心架构并降低高风险的阶段

####### 在细化前不需要定义大多数需求，10％的详细用例书写出来即可

####### 先处理具有风险的元素，开始实际产品代码的编写，产生可执行架构

####### 除了极少数理解良好的问题外需要多次迭代

###### 构造阶段（Construction）：
迭代实现遗留下来的风险较低和比较容易的元素，准备部署 （Initial Operational Capability）

###### 移交阶段（Transition）：
beta测试，部署 （Product Release）

##### 多个流程

###### 业务建模：在开发单独的应用时，业务建模包括领域对象建模。在从事大规模业务分析或业务过程再工程时，业务建模包括跨越整个企业的业务过程的动态建模。

###### 需求：对应用的需求分析，如写出用例和识别非功能性需求

###### 分析和设计：设计的所有方面，包括总体架构、对象、数据库、网络连接等。分析强调的是对问题和需求的调查研究，而不是解决方案。设计强调的是满足需求的概念上的解决方案，而不是其实现。分析和设计可以被概括为：作正确的事（分析）和正确的做事（设计）。

###### 实现：编程和构建系统，而不是部署系统

###### 测试

###### 配置和变更管理

###### 项目管理

###### 环境：指建立工具并为项目定制过程，也就是说，设置工具和过程环境。

###### 1－5为核心工作流程，6－8为支持工作流程

###### The way of controlling

####### 如何计划和管理迭代：需要多少迭代？每次迭代多长时间？每次迭代的目的是什么？如何跟踪每次迭代情况？

   * The Phase Plan (Project Plan)：一个粗略的计划，每个开发项目只有一份项目计划。包括了一个周期（cycle）内所有的环节（有时也可以包含多个周期）。计划包含主要里程碑的时间，要求的资源。如果能够明确分几个iteratio，则需要标识时每个小里程碑的时间和目的。

   * The Iteration Plan：迭代计划，包含当前迭代的详细计划，包括时间、任务和资源分配，在当前迭代后半期还需要包含下一个迭代的计划

####### 风险管理

####### 度量

###### The way of supporting

###### The way of communicating

####### RUP定义了一系列流程和工件，这些工作作为各角色间沟通的主要内容，用例和架构是RUP的两个重要内容。

####### 用例驱动开发：使用用例表达需求，对业务进行描述。用例作为整个开发流程的基础。

####### 架构为中心流程：架构使用多个、协调一致的视图来表达系统，作为概念、构建、管理和演进系统的主要工件

##### 模型和流程对应

###### 角色: the who

###### 活动: the how

###### 工件：the what

###### 工作流: the when

###### 规程（Disciplines）: 组合前面四种元素

##### 六大经验

###### 迭代式开发。在软件开发的早期阶段就想完全、准确的捕获用户的需求几乎是不可能的。实际上，我们经常遇到的问题是需求在整个软件开发工程中经常会改变。迭代式开发允许在每次迭代过程中需求可能有变化，通过不断细化来加深对问题的理解。迭代式开发不仅可以降低项目的风险，而且每个迭代过程以可以执行版本结束，可以鼓舞开发人员。

###### 管理需求。确定系统的需求是一个连续的过程，开发人员在开发系统之前不可能完全详细的说明一个系统的真正需求。RUP描述了如何提取、组织系统的功能和约束条件并将其文档化，用例和脚本的使用以被证明是捕获功能性需求的有效方法。

###### 基于组件的体系结构。组件使重用成为可能，系统可以由组件组成。基于独立的、可替换的、模块化组件的体系结构有助于管理复杂性，提高重用率。RUP描述了如何设计一个有弹性的、能适应变化的、易于理解的、有助于重用的软件体系结构。

###### 可视化建模。RUP往往和UML联系在一起，对软件系统建立可视化模型帮助人们提供管理软件复杂性的能力。RUP告诉我们如何可视化的对软件系统建模，获取有关体系结构于组件的结构和行为信息。

###### 验证软件质量。在RUP中软件质量评估不再是事后进行或单独小组进行的分离活动，而是内建于过程中的所有活动，这样可以及早发现软件中的缺陷。

###### 控制软件变更。迭代式开发中如果没有严格的控制和协调，整个软件开发过程很快就陷入混乱之中，RUP描述了如何控制、跟踪、监控、修改以确保成功的迭代开发。RUP通过软件开发过程中的制品，隔离来自其他工作空间的变更，以此为每个开发人员建立安全的工作空间。

##### 核心概念

###### 角色：描述某个人或者一个小组的行为与职责。RUP预先定义了很多角色。

###### 活动：是一个有明确目的的独立工作单元。

###### 工件：是活动生成、创建或修改的一段信息。

##### RUP裁剪

###### RUP是一个通用的过程模板，包含了很多开发指南、制品、开发过程所涉及到的角色说明，由于它非常庞大所以对具体的开发机构和项目，用RUP时还要做裁剪，也就是要对RUP进行配置。RUP就像一个元过程，通过对RUP进行裁剪可以得到很多不同的开发过程，这些软件开发过程可以看作RUP的具体实例。RUP裁剪可以分为以下几步：

###### 1)        确定本项目需要哪些工作流。RUP的9个核心工作流并不总是需要的，可以取舍。

###### 2)        确定每个工作流需要哪些制品。

###### 3)        确定4个阶段之间如何演进。确定阶段间演进要以风险控制为原则，决定每个阶段要那些工作流，每个工作流执行到什么程度，制品有那些，每个制品完成到什么程度。

###### 4)        确定每个阶段内的迭代计划。规划RUP的4个阶段中每次迭代开发的内容。

###### 5)        规划工作流内部结构。工作流涉及角色、活动及制品，他的复杂程度与项目规模即角色多少有关。最后规划工作流的内部结构，通常用活动图的形式给出。

## 面向对象

### 结构化与面向对象方法特点比较

> 1. 从概念方面看，

> > 结构化软件是功能的集合，通过模块以及模块和模块之间的分层调用关系实现；面向对象软件是事物的集合，通过对象以及对象和对象之间的通讯联系实现；

>   2. 从构成方面看

> > 结构化软件＝过程＋数据，以过程为中心；面向对象软件＝（数据＋相应操作）的封装，以数据为中心；

>   3. 从运行控制方面看

> > 结构化软件采用顺序处理方式，由过程驱动控制；面向对象软件采用交互式、并行处理方式，由消息驱动控制；

>   4. 从开发方面看，

> > 结构化方法的工作重点是设计；面向对象方法的工作重点是分析；

> > > 在结构化方法中需要把在分析阶段采用的具有网络特征的数据流图转换为设计阶段采用的具有分层特征的结构图，在面向对象方法中则不存在这一问题。

>   5. 从应用方面看，

> > 相对而言，结构化方法更加适合数据类型比较简单的数值计算和数据统计管理软件的开发；面向对象方法更加适合大型复杂的人机交互式软件和数据统计管理软件的开发；

### OOD(Object Oriented Design)

> 面向对象设计（Object-Oriented Design，OOD）方法是OO方法中一个中间过渡环节。其主要作用是对OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。

> 面向对象设计（OOD）是一种软件设计方法，是一种工程化规范。这是毫无疑问的。按照Bjarne Stroustrup的说法，面向对象的编程范式（paradigm）是[Stroustrup, 97]：

> l 决定你要的类；

> l 给每个类提供完整的一组操作；

> l 明确地使用继承来表现共同点。

> 由这个定义，我们可以看出：OOD就是“根据需求决定所需的类、类的操作以及类之间关联的过程”。

> OOD的目标是管理程序内部各部分的相互依赖。为了达到这个目标，OOD要求将程序分成块，每个块的规模应该小到可以管理的程度，然后分别将各个块隐藏在接口（interface）的后面，让它们只通过接口相互交流。比如说，如果用OOD的方法来设计一个服务器-客户端（client-server）应用，那么服务器和客户端之间不应该有直接的依赖，而是应该让服务器的接口和客户端的接口相互依赖。

> 这种依赖关系的转换使得系统的各部分具有了可复用性。还是拿上面那个例子来说，客户端就不必依赖于特定的服务器，所以就可以复用到其他的环境下。如果要复用某一个程序块，只要实现必须的接口就行了。

> OOD是一种解决软件问题的设计范式（paradigm），一种抽象的范式。使用OOD这种设计范式，我们可以用对象（object）来表现问题领域（problem domain）的实体，每个对象都有相应的状态和行为。我们刚才说到：OOD是一种抽象的范式。抽象可以分成很多层次，从非常概括的到非常特殊的都有，而对象可能处于任何一个抽象层次上。另外，彼此不同但又互有关联的对象可以共同构成抽象：只要这些对象之间有相似性，就可以把它们当成同一类的对象来处理。

> 一、OOD背景知识

> 计算机硬件技术却在飞速发展。从几十年前神秘的庞然大物，到现在随身携带的移动芯片；从每秒数千次运算到每秒上百亿次运算。当软件开发者们还在寻找能让软件开发生产力提高一个数量级的“银弹”[Brooks, 95]时，硬件开发的生产力早已提升了百倍千倍。

> 硬件工程师们能够如此高效，是因为他们都很懒惰。他们永远恪守“不要去重新发明轮子”的古训。Grady Booch把这些黑箱称为类属（class category），现在我们则通常把它们称为“组件（component）”。

> 类属是由被称为类（class）的实体组成的，类与类之间通过关联（relationship）结合在一起。一个类可以把大量的细节隐藏起来，只露出一个简单的接口，这正好符合人们喜欢抽象的心理。所以，这是一个非常伟大的概念，因为它给我们提供了封装和复用的基础，让我们可以从问题的角度来看问题，而不是从机器的角度来看问题。

> 软件的复用最初是从函数库和类库开始的，这两种复用形式实际上都是白箱复用。到90年代，开始有人开发并出售真正的黑箱软件模块：框架（framework）和控件（control）。框架和控件往往还受平台和语言的限制，现在软件技术的新潮流是用SOAP作为传输介质的Web Service，它可以使软件模块脱离平台和语言的束缚，实现更高程度的复用。但是想一想，其实Web Service也是面向对象，只不过是把类与类之间的关联用XML来描述而已[Li, 02]。

> 在过去的十多年里，面向对象技术对软件行业起到了极大的推动作用。在可以预测的将来，它仍将是软件设计的主要技术——至少我看不到有什么技术可以取代它的。

> 二、OOD到底从哪儿来？

> 有很多人都认为：OOD是对结构化设计（Structured Design，SD）的扩展，其实这是不对的。OOD的软件设计观念和SD完全不同。SD注重的是数据结构和处理数据结构的过程。而在OOD中，过程和数据结构都被对象隐藏起来，两者几乎是互不相关的。不过，追根溯源，OOD和SD有着非常深的渊源。

> 1967年前后，OOD和SD 的概念几乎同时诞生，它们分别以不同的方式来表现数据结构和算法。当时，围绕着这两个概念，很多科学家写了大量的论文。其中，由Dijkstra和 Hoare两人所写的一些论文讲到了“恰当的程序控制结构”这个话题，声称goto语句是有害的，应该用顺序、循环、分支这三种控制结构来构成整个程序流程。这些概念发展构成了结构化程序设计方法；而由Ole-Johan Dahl所写的另一些论文则主要讨论编程语言中的单位划分，其中的一种程序单位就是类，它已经拥有了面向对象程序设计的主要特征。

> 这两种概念立刻就分道扬镳了。在结构化这边的历史大家都很熟悉：NATO会议采纳了Dijkstra的思想，整个软件产业都同意goto语句的确是有害的，结构化方法、瀑布模型从70年代开始大行其道。同时，无数的科学家和软件工程师也帮助结构化方法不断发展完善，其中有很多今天足以使我们振聋发聩的名字，例如Constantine、Yourdon、DeMarco和Dijkstra。有很长一段时间，整个世界都相信：结构化方法就是拯救软件工业的 “银弹”。当然，时间最后证明了一切。

> 而此时，面向对象则在研究和教育领域缓慢发展。结构化程序设计几乎可以应用于任何编程语言之上，而面向对象程序设计则需要语言的支持[1]，这也妨碍了面向对象技术的发展。实际上，在60年代后期，支持面向对象特性的语言只有Simula-67这一种。到70年代，施乐帕洛阿尔托研究中心（PARC）的 Alan Key等人又发明了另一种基于面向对象方法的语言，那就是大名鼎鼎的Smalltalk。但是，直到80年代中期，Smalltalk和另外几种面向对象语言仍然只停留在实验室里。

> 到90年代，OOD突然就风靡了整个软件行业，这绝对是软件开发史上的一次革命。不过，登高才能望远，新事物总是站在旧事物的基础之上的。70年代和80年代的设计方法揭示出许多有价值的概念，谁都不能也不敢忽视它们，OOD也一样。

> 三、OOD和传统方法有什么区别？

> 还记得结构化设计方法吗？程序被划分成许多个模块，这些模块被组织成一个树型结构。这棵树的根就是主模块，叶子就是工具模块和最低级的功能模块。同时，这棵树也表示调用结构：每个模块都调用自己的直接下级模块，并被自己的直接上级模块调用。

> 那么，哪个模块负责收集应用程序最重要的那些策略？当然是最顶端的那些。在底下的那些模块只管实现最小的细节，最顶端的模块关心规模最大的问题。所以，在这个体系结构中越靠上，概念的抽象层次就越高，也越接近问题领域；体系结构中位置越低，概念就越接近细节，与问题领域的关系就越少，而与解决方案领域的关系就越多。

> 但是，由于上方的模块需要调用下方的模块，所以这些上方的模块就依赖于下方的细节。换句话说，与问题领域相关的抽象要依赖于与问题领域无关的细节！这也就是说，当实现细节发生变化时，抽象也会受到影响。而且，如果我们想复用某一个抽象的话，就必须把它依赖的细节都一起拖过去。

> 而在OOD中，我们希望倒转这种依赖关系：我们创建的抽象不依赖于任何细节，而细节则高度依赖于上面的抽象。这种依赖关系的倒转正是OOD和传统技术之间根本的差异，也正是OOD思想的精华所在。

> 四、OOD步骤

> 细化重组类

> 细化和实现类间关系,明确其可见性

> 增加属性,指定属性的类型与可见性

> 分配职责,定义执行每个职责的方法

> 对消息驱动的系统,明确消息传递方式

> 利用设计模式进行局部设计

> 画出详细的类图与时序图

> 五、OOD设计过程中要展开的主要几项工作

> （一）对象定义规格的求精过程

> 对于OOA所抽象出来的对象-＆-类以及汇集的分析文档，OOD需要有一个根据设计要求整理和求精的过程，使之更能符合OOP的需要。这个整理和求精过程主要有两个方面：一是要根据面向对象的概念

> 模型整理分析所确定的对象结构、属性、方法等内容，改正错误的内容，删去不必要和重复的内容等。二是进行分类整理，以便于下一步数据库设计和程序处理模块设计的需要。整理的方法主要是进行归

> 类，对类一＆一对象、属性、方法和结构、主题进行归类。

> （二）数据模型和数据库设计

> 数据模型的设计需要确定类-＆-对象属性的内容、消息连接的方式、系统访问、数据模型的方法等。最后每个对象实例的数据都必须落实到面向对象的库结构模型中。

> （三）优化

> OOD的优化设计过程是从另一个角度对分析结果和处理业务过程的整理归纳，优化包括对象和结构的优化、抽象、集成。

> 对象和结构的模块化表示OOD提供了一种范式，这种范式支持对类和结构的模块化。这种模块符合一般模块化所要求的所有特点，如信息隐蔽性好，内部聚合度强和模块之间耦合度弱等。

> 集成化使得单个构件有机地结合在一起，相互支持。

> 六、OO方法的特点和面临的问题

> OO方法以对象为基础，利用特定的软件工具直接完成从对象客体的描述到软件结构之间的转换。这是OO方法最主要的特点和成就。OO方法的应用解决了传统结构化开发方法中客观世界描述工具与软

> 件结构的不一致性问题，缩短了开发周期，解决了从分析和设计到软件模块结构之间多次转换映射的繁杂过程，是一种很有发展前途的系统开发方法。

> 但是同原型方法一样,OO方法需要一定的软件基础支持才可以应用，另外在大型的MIS开发中如果不经自顶向下的整体划分，而是一开始就自底向上的采用OO 方法开发系统，同样也会造成系统结构不合理、各部分关系失调等问题。所以OO方法和结构化方法目前仍是两种在系统开发领域相互依存的、不可替代的方法。

> 七、OOD能给我带来什么？

> 问这个问题的人，脑子里通常是在想“OOD能解决所有的设计问题吗？”没有银弹。OOD也不是解决一切设计问题、避免软件危机、捍卫世界和平……的银弹。OOD只是一种技术。但是，它是一种优秀的技术，它可以很好地解决目前的大多数软件设计问题——当然，这要求设计者有足够的能力。

> OOD可能会让你头疼，因为要学会它、掌握它是很困难的；OOD甚至会让你失望，因为它也并不成熟、并不完美。OOD也会给你带来欣喜，它让你可以专注于设计，而不必操心那些细枝末节；OOD也会使你成为一个更好的设计师，它能提供给你很好的工具，让你能开发出更坚固、更可维护、更可复用的软件。

#### OOD步骤

> 面向对象设计（Object-Oriented Design，OOD）方法是OO方法中一个中间过渡环节。其主要作用是对OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。

> 面向对象设计（OOD）是一种软件设计方法，是一种工程化规范。这是毫无疑问的。按照Bjarne Stroustrup的说法，面向对象的编程范式（paradigm）是[Stroustrup, 97]：

> l 决定你要的类；

> l 给每个类提供完整的一组操作；

> l 明确地使用继承来表现共同点。

> 由这个定义，我们可以看出：OOD就是“根据需求决定所需的类、类的操作以及类之间关联的过程”。

> OOD的目标是管理程序内部各部分的相互依赖。为了达到这个目标，OOD要求将程序分成块，每个块的规模应该小到可以管理的程度，然后分别将各个块隐藏在接口（interface）的后面，让它们只通过接口相互交流。比如说，如果用OOD的方法来设计一个服务器-客户端（client-server）应用，那么服务器和客户端之间不应该有直接的依赖，而是应该让服务器的接口和客户端的接口相互依赖。

> 这种依赖关系的转换使得系统的各部分具有了可复用性。还是拿上面那个例子来说，客户端就不必依赖于特定的服务器，所以就可以复用到其他的环境下。如果要复用某一个程序块，只要实现必须的接口就行了。

> OOD是一种解决软件问题的设计范式（paradigm），一种抽象的范式。使用OOD这种设计范式，我们可以用对象（object）来表现问题领域（problem domain）的实体，每个对象都有相应的状态和行为。我们刚才说到：OOD是一种抽象的范式。抽象可以分成很多层次，从非常概括的到非常特殊的都有，而对象可能处于任何一个抽象层次上。另外，彼此不同但又互有关联的对象可以共同构成抽象：只要这些对象之间有相似性，就可以把它们当成同一类的对象来处理。

> 一、OOD背景知识

> 计算机硬件技术却在飞速发展。从几十年前神秘的庞然大物，到现在随身携带的移动芯片；从每秒数千次运算到每秒上百亿次运算。当软件开发者们还在寻找能让软件开发生产力提高一个数量级的“银弹”[Brooks, 95]时，硬件开发的生产力早已提升了百倍千倍。

> 硬件工程师们能够如此高效，是因为他们都很懒惰。他们永远恪守“不要去重新发明轮子”的古训。Grady Booch把这些黑箱称为类属（class category），现在我们则通常把它们称为“组件（component）”。

> 类属是由被称为类（class）的实体组成的，类与类之间通过关联（relationship）结合在一起。一个类可以把大量的细节隐藏起来，只露出一个简单的接口，这正好符合人们喜欢抽象的心理。所以，这是一个非常伟大的概念，因为它给我们提供了封装和复用的基础，让我们可以从问题的角度来看问题，而不是从机器的角度来看问题。

> 软件的复用最初是从函数库和类库开始的，这两种复用形式实际上都是白箱复用。到90年代，开始有人开发并出售真正的黑箱软件模块：框架（framework）和控件（control）。框架和控件往往还受平台和语言的限制，现在软件技术的新潮流是用SOAP作为传输介质的Web Service，它可以使软件模块脱离平台和语言的束缚，实现更高程度的复用。但是想一想，其实Web Service也是面向对象，只不过是把类与类之间的关联用XML来描述而已[Li, 02]。

> 在过去的十多年里，面向对象技术对软件行业起到了极大的推动作用。在可以预测的将来，它仍将是软件设计的主要技术——至少我看不到有什么技术可以取代它的。

> 二、OOD到底从哪儿来？

> 有很多人都认为：OOD是对结构化设计（Structured Design，SD）的扩展，其实这是不对的。OOD的软件设计观念和SD完全不同。SD注重的是数据结构和处理数据结构的过程。而在OOD中，过程和数据结构都被对象隐藏起来，两者几乎是互不相关的。不过，追根溯源，OOD和SD有着非常深的渊源。

> 1967年前后，OOD和SD 的概念几乎同时诞生，它们分别以不同的方式来表现数据结构和算法。当时，围绕着这两个概念，很多科学家写了大量的论文。其中，由Dijkstra和 Hoare两人所写的一些论文讲到了“恰当的程序控制结构”这个话题，声称goto语句是有害的，应该用顺序、循环、分支这三种控制结构来构成整个程序流程。这些概念发展构成了结构化程序设计方法；而由Ole-Johan Dahl所写的另一些论文则主要讨论编程语言中的单位划分，其中的一种程序单位就是类，它已经拥有了面向对象程序设计的主要特征。

> 这两种概念立刻就分道扬镳了。在结构化这边的历史大家都很熟悉：NATO会议采纳了Dijkstra的思想，整个软件产业都同意goto语句的确是有害的，结构化方法、瀑布模型从70年代开始大行其道。同时，无数的科学家和软件工程师也帮助结构化方法不断发展完善，其中有很多今天足以使我们振聋发聩的名字，例如Constantine、Yourdon、DeMarco和Dijkstra。有很长一段时间，整个世界都相信：结构化方法就是拯救软件工业的 “银弹”。当然，时间最后证明了一切。

> 而此时，面向对象则在研究和教育领域缓慢发展。结构化程序设计几乎可以应用于任何编程语言之上，而面向对象程序设计则需要语言的支持[1]，这也妨碍了面向对象技术的发展。实际上，在60年代后期，支持面向对象特性的语言只有Simula-67这一种。到70年代，施乐帕洛阿尔托研究中心（PARC）的 Alan Key等人又发明了另一种基于面向对象方法的语言，那就是大名鼎鼎的Smalltalk。但是，直到80年代中期，Smalltalk和另外几种面向对象语言仍然只停留在实验室里。

> 到90年代，OOD突然就风靡了整个软件行业，这绝对是软件开发史上的一次革命。不过，登高才能望远，新事物总是站在旧事物的基础之上的。70年代和80年代的设计方法揭示出许多有价值的概念，谁都不能也不敢忽视它们，OOD也一样。

> 三、OOD和传统方法有什么区别？

> 还记得结构化设计方法吗？程序被划分成许多个模块，这些模块被组织成一个树型结构。这棵树的根就是主模块，叶子就是工具模块和最低级的功能模块。同时，这棵树也表示调用结构：每个模块都调用自己的直接下级模块，并被自己的直接上级模块调用。

> 那么，哪个模块负责收集应用程序最重要的那些策略？当然是最顶端的那些。在底下的那些模块只管实现最小的细节，最顶端的模块关心规模最大的问题。所以，在这个体系结构中越靠上，概念的抽象层次就越高，也越接近问题领域；体系结构中位置越低，概念就越接近细节，与问题领域的关系就越少，而与解决方案领域的关系就越多。

> 但是，由于上方的模块需要调用下方的模块，所以这些上方的模块就依赖于下方的细节。换句话说，与问题领域相关的抽象要依赖于与问题领域无关的细节！这也就是说，当实现细节发生变化时，抽象也会受到影响。而且，如果我们想复用某一个抽象的话，就必须把它依赖的细节都一起拖过去。

> 而在OOD中，我们希望倒转这种依赖关系：我们创建的抽象不依赖于任何细节，而细节则高度依赖于上面的抽象。这种依赖关系的倒转正是OOD和传统技术之间根本的差异，也正是OOD思想的精华所在。

> 四、OOD步骤

> 细化重组类

> 细化和实现类间关系,明确其可见性

> 增加属性,指定属性的类型与可见性

> 分配职责,定义执行每个职责的方法

> 对消息驱动的系统,明确消息传递方式

> 利用设计模式进行局部设计

> 画出详细的类图与时序图

> 五、OOD设计过程中要展开的主要几项工作

> （一）对象定义规格的求精过程

> 对于OOA所抽象出来的对象-＆-类以及汇集的分析文档，OOD需要有一个根据设计要求整理和求精的过程，使之更能符合OOP的需要。这个整理和求精过程主要有两个方面：一是要根据面向对象的概念

> 模型整理分析所确定的对象结构、属性、方法等内容，改正错误的内容，删去不必要和重复的内容等。二是进行分类整理，以便于下一步数据库设计和程序处理模块设计的需要。整理的方法主要是进行归

> 类，对类一＆一对象、属性、方法和结构、主题进行归类。

> （二）数据模型和数据库设计

> 数据模型的设计需要确定类-＆-对象属性的内容、消息连接的方式、系统访问、数据模型的方法等。最后每个对象实例的数据都必须落实到面向对象的库结构模型中。

> （三）优化

> OOD的优化设计过程是从另一个角度对分析结果和处理业务过程的整理归纳，优化包括对象和结构的优化、抽象、集成。

> 对象和结构的模块化表示OOD提供了一种范式，这种范式支持对类和结构的模块化。这种模块符合一般模块化所要求的所有特点，如信息隐蔽性好，内部聚合度强和模块之间耦合度弱等。

> 集成化使得单个构件有机地结合在一起，相互支持。

> 六、OO方法的特点和面临的问题

> OO方法以对象为基础，利用特定的软件工具直接完成从对象客体的描述到软件结构之间的转换。这是OO方法最主要的特点和成就。OO方法的应用解决了传统结构化开发方法中客观世界描述工具与软

> 件结构的不一致性问题，缩短了开发周期，解决了从分析和设计到软件模块结构之间多次转换映射的繁杂过程，是一种很有发展前途的系统开发方法。

> 但是同原型方法一样,OO方法需要一定的软件基础支持才可以应用，另外在大型的MIS开发中如果不经自顶向下的整体划分，而是一开始就自底向上的采用OO 方法开发系统，同样也会造成系统结构不合理、各部分关系失调等问题。所以OO方法和结构化方法目前仍是两种在系统开发领域相互依存的、不可替代的方法。

> 七、OOD能给我带来什么？

> 问这个问题的人，脑子里通常是在想“OOD能解决所有的设计问题吗？”没有银弹。OOD也不是解决一切设计问题、避免软件危机、捍卫世界和平……的银弹。OOD只是一种技术。但是，它是一种优秀的技术，它可以很好地解决目前的大多数软件设计问题——当然，这要求设计者有足够的能力。

> OOD可能会让你头疼，因为要学会它、掌握它是很困难的；OOD甚至会让你失望，因为它也并不成熟、并不完美。OOD也会给你带来欣喜，它让你可以专注于设计，而不必操心那些细枝末节；OOD也会使你成为一个更好的设计师，它能提供给你很好的工具，让你能开发出更坚固、更可维护、更可复用的软件。

##### 细化重组类

> 细化和实现类间关系,明确其可见性

> 增加属性,指定属性的类型与可见性

> 分配职责,定义执行每个职责的方法

> 对消息驱动的系统,明确消息传递方式

> 利用设计模式进行局部设计

> 画出详细的类图与时序图

#### OOD设计过程中要展开的主要几项工作

##### （一）对象定义规格的求精过程

> 对于OOA所抽象出来的对象-＆-类以及汇集的分析文档，OOD需要有一个根据设计要求整理和求精的过程，使之更能符合OOP的需要。这个整理和求精过程主要有两个方面：一是要根据面向对象的概念

> 模型整理分析所确定的对象结构、属性、方法等内容，改正错误的内容，删去不必要和重复的内容等。二是进行分类整理，以便于下一步数据库设计和程序处理模块设计的需要。整理的方法主要是进行归

> 类，对类一＆一对象、属性、方法和结构、主题进行归类。

##### （二）数据模型和数据库设计

> 数据模型的设计需要确定类-＆-对象属性的内容、消息连接的方式、系统访问、数据模型的方法等。最后每个对象实例的数据都必须落实到面向对象的库结构模型中。

##### （三）优化

> OOD的优化设计过程是从另一个角度对分析结果和处理业务过程的整理归纳，优化包括对象和结构的优化、抽象、集成。

> 对象和结构的模块化表示OOD提供了一种范式，这种范式支持对类和结构的模块化。这种模块符合一般模块化所要求的所有特点，如信息隐蔽性好，内部聚合度强和模块之间耦合度弱等。

> 集成化使得单个构件有机地结合在一起，相互支持。

##### 六、OO方法的特点和面临的问题

> OO方法以对象为基础，利用特定的软件工具直接完成从对象客体的描述到软件结构之间的转换。这是OO方法最主要的特点和成就。OO方法的应用解决了传统结构化开发方法中客观世界描述工具与软

> 件结构的不一致性问题，缩短了开发周期，解决了从分析和设计到软件模块结构之间多次转换映射的繁杂过程，是一种很有发展前途的系统开发方法。

> 但是同原型方法一样,OO方法需要一定的软件基础支持才可以应用，另外在大型的MIS开发中如果不经自顶向下的整体划分，而是一开始就自底向上的采用OO 方法开发系统，同样也会造成系统结构不合理、各部分关系失调等问题。所以OO方法和结构化方法目前仍是两种在系统开发领域相互依存的、不可替代的方法。

##### 七、OOD能给我带来什么？

> 问这个问题的人，脑子里通常是在想“OOD能解决所有的设计问题吗？”没有银弹。OOD也不是解决一切设计问题、避免软件危机、捍卫世界和平……的银弹。OOD只是一种技术。但是，它是一种优秀的技术，它可以很好地解决目前的大多数软件设计问题——当然，这要求设计者有足够的能力。

> OOD可能会让你头疼，因为要学会它、掌握它是很困难的；OOD甚至会让你失望，因为它也并不成熟、并不完美。OOD也会给你带来欣喜，它让你可以专注于设计，而不必操心那些细枝末节；OOD也会使你成为一个更好的设计师，它能提供给你很好的工具，让你能开发出更坚固、更可维护、更可复用的软件。

#### 实现UML建模

##### (1)  业务对象的提取

##### (2)  根据SRS、CRC等实现用况建模

##### (3)  实现业务顺序图

##### (4)  建立类图，根据用况图建立对象之间的关联

##### (5)  绘制活动图、实现协作图、状态图

### OOP(Object Oriented Programming)

> 　面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。OOP 主要有以下的概念和组件：

> 组件 － 数据和功能一起在运行着的计算机程序中形成的单元，组件在 OOP 计算机程序中是模块和结构化的基础。

> 抽象性 － 程序有能力忽略正在处理中信息的某些方面，即对信息主要方面关注的能力。

> 封装 － 也叫做信息封装：确保组件不会以不可预期的方式改变其它组件的内部状态；只有在那些提供了内部状态改变方法的组件中，才可以访问其内部状态。每类组件都提供了一个与其它组件联系的接口，并规定了其它组件进行调用的方法。

> 多态性 － 组件的引用和类集会涉及到其它许多不同类型的组件，而且引用组件所产生的结果得依据实际调用的类型。

> 继承性 － 允许在现存的组件基础上创建子类组件，这统一并增强了多态性和封装性。典型地来说就是用类来对组件进行分组，而且还可以定义新类为现存的类的扩展，这样就可以将类组织成树形或网状结构，这体现了动作的通用性。

> 由于抽象性、封装性、重用性以及便于使用等方面的原因，以组件为基础的编程在脚本语言中已经变得特别流行。Python 和 Ruby 是最近才出现的语言，在开发时完全采用了 OOP 的思想，而流行的 Perl 脚本语言从版本5开始也慢慢地加入了新的面向对象的功能组件。用组件代替“现实”上的实体成为 JavaScript（ECMAScript） 得以流行的原因，有论证表明对组件进行适当的组合就可以在英特网上代替 HTML 和 XML 的文档对象模型（DOM）。

> 设计模式、技术和直觉构成严峻的挑战。这是选择编程语言之前必须认识到的，尽管不同语言的设计特性可能促进或者阻碍这一转化。

> 在网络应用的增长中，一个很重要的部分是小型移动设备和特殊Internet设备的爆炸性增长。这些设备各有各的操作系统，或者只在某种特定的设备领域内有共同的操作系统。我们现在还可以一一列举出这些设备——家庭接入设备、蜂窝电话、电子报纸、PDA、自动网络设备等等。但是这些设备领域的数量和深入程度将会很快变得难以估量。我们都知道这个市场大得惊人，PC的兴起与之相比不过小菜一碟。因此在这些设备的应用程序市场上，竞争将会相当残酷。获胜的重要手段之一，就是尽快进入市场。开发人员需要优秀的工具，迅速高效地撰写和调试他们的软件。平台无关性也是制胜秘诀之一，它使得程序员能够开发出支持多种设备平台的软件。

> 我预期的另一个变化是，我们对于代码(Java)和数据(XML)协同型应用程序的开发能力将会不断提高。这种协同是开发强大应用程序的核心目标之一。我们从XML的迅速流行和ebXML规范的进展中，已经看到了这个趋势。ebXML是一个针对电子商务和国际贸易的，基于XML的开放式基础构架，由联合国贸易促进和电子商务中心(UN/CEFACT)与结构性信息标准推进组织(OASIS)共同开发。

> 我们能否期望出现一个真正的面向组件(component-oriented)的语言？它的创造者会是谁呢？

> Stroustrup: 我怀疑，这个领域中之所以缺乏成果，正是因为人们——主要是那些非程序员们——对“组件”这个意义含糊的字眼寄予了太多的期望。这些人士梦想，有朝一日，组件会以某种方式把程序员赶出历史舞台。以后那些称职的“设计员”只需利用预先调整好的组件，把鼠标拖一拖放一放，就把系统组合出来。对于软件工具厂商来说，这种想法还有另一层意义，他们认为，到时候只有他们才保留有必要的技术，有能力编写这样的组件。

> 这种想法有一个最基本的谬误：这种组件很难获得广泛欢迎。一个单独的组件或框架(framework)，如果能够满足一个应用程序或者一个产业领域对所提出的大部分要求的话，对于其制造者来说就是划算的产品，而且技术上也不是很困难。可是该产业内的几个竞争者很快就会发现，如果所有人都采用这些组件，那么彼此之间的产品就会变得天下大同，没什么区别，他们将沦为简单的办事员，主要利润都将钻进那些组件/框架供应商的腰包里！

> 小“组件”很有用，不过产生不了预期的杠杆效应。中型的、更通用的组件非常有用，但是构造时需要非同寻常的弹性。

#### 主要目标

##### 重用性、

##### 灵活性

##### 扩展性。


#### 概念和组件：

##### 组件

###### 数据和功能一起在运行着的计算机程序中形成的单元，组件在 OOP 计算机程序中是模块和结构化的基础。

##### 抽象性

###### 程序有能力忽略正在处理中信息的某些方面，即对信息主要方面关注的能力。

##### 封装

###### 也叫做信息封装：确保组件不会以不可预期的方式改变其它组件的内部状态；只有在那些提供了内部状态改变方法的组件中，才可以访问其内部状态。每类组件都提供了一个与其它组件联系的接口，并规定了其它组件进行调用的方法。

##### 多态性

###### 组件的引用和类集会涉及到其它许多不同类型的组件，而且引用组件所产生的结果得依据实际调用的类型。

##### 继承性

###### 允许在现存的组件基础上创建子类组件，这统一并增强了多态性和封装性。典型地来说就是用类来对组件进行分组，而且还可以定义新类为现存的类的扩展，这样就可以将类组织成树形或网状结构，这体现了动作的通用性。

#### 基本特征

##### 封装

###### 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

##### 继承

###### 实现继承是指使用基类的属性和方法而无需额外编码的能力； 

###### Ø         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力； 

###### Ø         可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。 

##### 多态

###### 覆盖，是指子类重新定义父类的虚函数的做法。 

###### 重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。 

#### 模式（GoF）与原则

### OOA(Object Oriented Analyzing)


#### 需要做什么

##### 1)为完成用户要求系统应提供哪些功能?

##### 2)系统应有哪些对象构成?

##### 3)每个对象应有哪些属性和服务?

##### 4)对象间应有怎样的联系?要

#### 怎么做

##### 1)个体特征分析:标识对象及其属性和服务。

有的方法在标识特征时对属性的要求可能弱一些,这是因为对象是属性和操作的封装体,对象的访问可以通过接口--操作来实现。这样在标识对象时对象的内部特征可暂不考虑,仅考察外部行为。每种分析方法在完成这些工作时各具特色,如:Coad&Yourdon方法只给出了一些标识对象及其特征的一般原则和思路;R.Abbott认为,可以通过分析非形式化英语的问题描述,将名词标识为对象,将形容词标识为属性,将动词标识为服务;Bailin等人则采用结构化与面向对象技术相结合的方法。

##### 2)静态分析:分析和描述系统的静态结构。

一般地,对象系统中的类或对象之间存在着两种关系:一般—特殊关系和整体—部分关系。其中,前者更具普遍性,它的一种重要实现形式就是继承机制,也是面向对象程序设计语言所支持的语言设施。同样,大多OOA方法也都为继承提供了相应的表示方法。因此,系统静态分析主要是分析、识别对象或类间的一般—特殊结构,并添加一些必要的类,构造继承关系。

##### 3)动态分析:分析对象及之间的行为及其控制关系,建立系统的动态模型。

多数分析方法要求进行这方面的工作,有的则将它放到设计阶段去完成,这主要是由OOA、OOD阶段划分的不同所造成的。动态模型一般由一组状态转换图构成,从这组状态转换图可以映射到对象模型。系统的动态模型从对象行为的角度刻划了系统功能,方便了从OOA到OOD的过渡。有的方法虽未提供动态模型,但也提供了表示对象行为的类似方法。早期的OOA方法对建立系统动态模型认识不足,这主要是因为当时的许多方法是受数据模型的启发而产生的。现在越来越多的人认识到了系统动态分析工作的重要性,并在分析方法中引入了相应概念。除此之外,许多OOA方法还引入了问题复杂性控制机制。如,Coad&Yourdon在其方法中引入了主题的概念;Wirfs&Brock在其方法中引入了子系统的概念。问题复杂性控制机制主要针对大型复杂系统,它将一组对象或类抽象成新的系统构件,以达到简化问题空间的目的。这样,分析和设计人员就可以从宏观与微观、整体与局部等不同角度来分析问题,便于透彻地认识和理解问题。

#### 主要原则

##### （1）抽象

抽象是形成概念的必须手段。抽象原则有两方面的意义：第一，尽管问题域中的事物是很复杂的，但是分析员并不需要了解和描述它们的一切，只需要分析研究其中与系统目标有关的事物及其本质性特征。第二，通过舍弃个体事物在细节上的差异，抽取其共同特征而得到一批事物的抽象概念。抽象是面向对象方法中使用最为广泛的原则。抽象原则包括过程抽象和数据抽象两个方面。过程抽象是指，任何一个完成确定功能的操作序列，其使用者都可以把它看作一个单一的实体，尽管实际上它可能是由一系列更低级的操作完成的。数据抽象是根据施加于数据之上的操作来定义数据类型，并限定数据的值只能由这些操作来修改和观察。数据抽象是OOA的核心原则。它强调把数据（属性）和操作（服务）结合为一个不可分的系统单位（即对象），对象的外部只需要知道它做什么，而不必知道它如何做。

###### 从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性的特征，就叫作抽象。

##### （2）封装

###### 就是把对象的属性和服务结合为一个不可分的系统单位，并尽可能隐蔽对象的内部细节。

##### （3）继承

　　在OOA中运用继承原则，就是在每个由一般类和特殊类形成的一般—特殊结构中，把一般类的对象实例和所有特殊类的对象实例都共同具有的属性和服务，一次性地在一般类中进行显式的定义。在特殊类中不再重复地定义一般类中已定义的东西，但是在语义上，特殊类却自动地、隐含地拥有它的一般类（以及所有更上层的一般类）中定义的全部属性和服务。继承原则的好处是：使系统模型比较简练也比较清晰。

###### 特殊类的对象拥有的其一般类的全部属性与服务，称作特殊类对一般类的继承。

##### （4）分类

###### 就是把具有相同属性和服务的对象划分为一类，用类作为这些对象的抽象描述。分类原则实际上是抽象原则运用于对象描述时的一种表现形式。

##### （5）聚合

###### 又称组装，其原则是：把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对复杂事物的描述。

##### （6）关联

###### 是人类思考问题时经常运用的思想方法：通过一个事物联想到另外的事物。能使人发生联想的原因是事物之间确实存在着某些联系。

##### （7）消息通信

###### 这一原则要求对象之间只能通过消息进行通信，而不允许在对象之外直接地存取对象内部的属性。通过消息进行通信是由于封装原则而引起的。在OOA中要求用消息连接表示出对象之间的动态联系。

##### （8）粒度控制

###### 一般来讲，人在面对一个复杂的问题域时，不可能在同一时刻既能纵观全局，又能洞察秋毫。因此需要控制自己的视野：考虑全局时，注意其大的组成部分，暂时不详察每一部分的具体的细节；考虑某部分的细节时则暂时撇开其余的部分。这就是粒度控制原则。

##### （9）行为分析

###### 现实世界中事物的行为是复杂的。由大量的事物所构成的问题域中各种行为往往相互依赖、相互交织。

#### 三种分析模型

##### 1、对象模型

> 对用例模型进行分析,把系统分解成互相协作的分析类,通过类图/对象图描述对象/对象的属性/对象间的关系,是系统的静态模型

##### 2、动态模型

> 描述系统的动态行为,通过时序图/协作图描述对象的交互,以揭示对象间如何协作来完成每个具体的用例,单个对象的状态变化/动态行为可以通过状态图来表达

##### 3、功能模型(即用例模型作为输入)。

#### OOA主要优点

> （1）加强了对问题域和系统责任的理解；

> （2）改进与分析有关的各类人员之间的交流；

> （3）对需求的变化具有较强的适应性；

> （4）支持软件复用。

> （5）贯穿软件生命周期全过程的一致性。

> （6）实用性；

> （7）有利于用户参与。

#### 基本步骤

##### 第一步，确定对象和类。

> 这里所说的对象是对数据及其处理方式的抽象，它反映了系统保存和处理现实世界中某些事物的信息的能力。类是多个对象的共同属性和方法集合的描述，它包括如何在一个类中建立一个新对象的描述。

##### 第二步，确定结构（structure）。

> 结构是指问题域的复杂性和连接关系。类成员结构反映了泛化-特化关系，整体-部分结构反映整体和局部之间的关系。

##### 第三步，确定主题（subject）。

> 主题是指事物的总体概貌和总体分析模型。

##### 第四步，确定属性（attribute）。

> 属性就是数据元素，可用来描述对象或分类结构的实例，可在图中给出，并在对象的存储中指定。

##### 第五步，确定方法（method）。

> 方法是在收到消息后必须进行的一些处理方法：方法要在图中定义，并在对象的存储中指定。对于每个对象和结构来说，那些用来增加、修改、删除和选择一个方法本身都是隐含的（虽然它们是要在对象的存储中定义的，但并不在图上给出），而有些则是显示的。



#### 面向对象

##### 第一步是抽取建立领域的概念模型

> 在UML中表现为建立对象类图、活动图和交互图。

> 对象类就是从对象中经过“察同”找出某组对象之间的共同特征而形成类：

> 对象与类的属性：数据结构；

> > 对象与类的服务操作：操作的实现算法；

> > 对象与类的各外部联系的实现结构；

> > 设计策略：充分利用现有的类；

> > 方法：继承、复用、演化；

> > 活动图用于定义工作流，

> > 主要说明工作流的5W（Do What、Who Do、When Do、Where Do、Why Do）等问题，交互图把人员和业务联系在一起是为了理解交互过程，发现业务工作流中相互交互的各种角色。

##### 第二步是构建完善系统结构：

> > 对系统进行分解，将大系统分解为若干子系统，

> > 子系统分解为若干软件组件，

> > 并说明子系统之间的静态和动态接口，

> > 每个子系统可以由用例模型、分析模型、设计模型、测试模型表示。

> > 软件系统结构的两种方式：层次、块状

> > 层次结构：系统、子系统、模块、组件（同一层之间具有独立性）；

> > 块状结构：相互之间弱耦合

> > 系统的组成部分：

> > > 问题论域：业务相关类和对象(OOA的重点)；

> > > 人机界面：窗口、菜单、按钮、命令等等；

> > > 数据管理：数据管理方法、逻辑物理结构、操作对象类；

> > > 任务管理：任务协调和管理进程；

##### 第三步是利用“4＋1”视图描述系统架构

> > 用例视图及剧本；说明体系结构的设计视图；

> >以模块形式组成包和层包含概要实现模型的实现视图；

> >说明进程与线程及其架构、分配和相互交互关系的过程视图；

> >说明系统在操作平台上的物理节点和其上的任务分配的配置视图。在RUP中还有可选的数据视图。

##### 第四步是性能优化

> > （速度、资源、内存）、模型清晰化、简单化（简单就是享受）。


### 基本

#### 类

##### 抽象类

###### 抽象类是提供多个派生类共享基类的公共定义，
它既可以提供抽象方法，也可以提供非抽象方法。
抽象类不能实例化，必须通过继承由派生类实现其抽象方法，
因此对抽象类不能使用new关键字，也不能被密封。
如果派生类没有实现所有的抽象方法，
则该派生类也必须声明为抽象类。
另外，实现抽象方法由override方法来实现。

###### 抽象类的特点：

> (1). 抽象类是一个类，可以包含类的一切东西：属性、字段、委托、方法。

> (2). 抽象方法必须包含在抽象类中，抽象方法没有方法体，但抽象类中还可以包含普通的非抽象方法。

> (3). 抽象类和抽象方法的关键字均为abstract。

> (4). 继承抽象类的子类中，必须显式的覆写(override)其父类中的所有抽象方法。

> (5). 抽象类不能直接被实例化，声明的对象只能使用抽象类中已有的方法，不能使用子类新增的方法。

> (6). 同一个类只能继承唯一一个父类。

###### 对比父类中的虚方法(virtual)和抽象方法(abstract)的区别：

####### (1). 抽象方法没有方法体，其继承子类必须对其进行覆写(override).

####### 　(2). 虚方法有方法体，其继承子类可以对其进行覆写(override)，可以不进行覆写。若进行覆写，调用的则是子类中覆写后的方法；若不进行覆写，则调用的是父类     中的方法。

####### 　(3). 抽象方法的关键字是abstract，且必须存在于抽象类中；虚方法的关键字是virtual，可以存在于任何类中。

##### 属性

##### 方法

#### 对象

#### 接口

##### 接口是包含一组虚方法的抽象类型，
其中每一种方法都有其名称、参数、返回值。接口方法不能包含任何实现，
CLR允许接口可以包含事件、属性、索引器、静态方法、静态字段、静态构造函数以及常数。
但是接口不能包含任何静态成员。
一个类可以实现多个接口，当一个类实现某个接口时，
它不仅要实现该接口定义的所有方法，还要实现该接口从其他接口中继承的所有方法。

###### (1). 接口不是类，里面可以包含属性、方法、事件，但不能包括字段和静态成员。

###### (2). 接口只能包含没有实现的方法。

###### (3). 子类实现接口，必须要实现该接口定义的所有方法，还要实现该接口从其他接口中继承的所有方法。

###### (4). 接口不能被直接实例化，声明的对象只能使用接口中的方法，不能使用子类新增的方法。

###### (5). 同一个类可以实现多个接口。

#### 关系

##### 依赖（Dependency）：

###### 两个事物间的语义关系，其中一个事物发生了变化会影响到另一个事物。

##### 关联（Association）：

###### 是一种结构关系，它描述了一组链，链是对象之间的连接。比如一个人为一家公司工作（WorksFor），这里WorksFor就是一个关联。

##### 链接（link）：

###### 是对象之间物理上或概念上的连接。例如：张三为微软公司工作（WorksFor），这里WorksFor就是一个链接。

##### 聚合（Aggregation）：

###### 其是一种特殊形式的关联。表示整体与部分的关系。比如项目组与其各成员之间的关系就是一种聚合关系。

##### 组合关系（Composition）：

###### 其也是一种特殊形式的关联。表示整体拥有各个部分，部分与整体共存。比如一个窗口是由文本框、列表框、菜单等组成的。关闭窗口，各个组成部分也相继消失，窗口与其各组成部分之间的关系便是组合关系。Ao对象中FeatureClass与Feature之间就是一种组合关系。

##### 泛化（Generalization）：

###### 其是一种特殊/一般关系，特殊元素（子元素）/的对象可替代一般元素（父元素）的对象。也称为“Is a关系”。

##### 实现（Realization）：

###### 是类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。

##### 符号

###### Class1 <|-- ClassA:泛化（子类继承父类）

###### Class2 <-- ClassB:关联（成员变量）

###### Class3 *-- ClassC:组合（是整体与部分的关系，但部分不能离开整体而单独存在）

###### Class4 o-- ClassD:聚合（Aggregation 整体与部分）

###### Class5 <|.. ClassE:实现（类实现接口）

###### Class6 <.. ClassF:依赖（局部变量、方法的参数或者对静态方法的调用）

#### 面向对象的三大特征

##### (1). 封装：将一些行为以类为单位进行包裹起来，
然后通过类进行调用（如People类），
可以利用private、public、protected灵活控制属性的可访问性。

###### 　②：屏蔽细节，只要方法名不变，可以随意扩展。

###### 　①：保证数据安全（灵活使用private、public、protected进行控制）

###### 　③：代码重用

##### (2). 继承：通过继承，子类可以拥有父类的一切动作（如Student类继承People类）

##### (3). 多态：多态有很多种。

###### ①：通过不同子类继承同一个父类，实现多态
（类似的还有子类继承抽象类、或者实现接口）

###### 　②：方法的重载本身就是一种多态

###### 　③：利用默认参数实现方法多态
（利用命名参数实现方法的重载，即方法的多态）

###### 　④：运行时的多态（里氏替换原则，声明父类对象，
调用虚方法，在子类覆写或者不覆写的情况下，
分别调用子类方法或父类方法《只有在运行的时候才知道》）

#### 抽象类和接口的比较

##### 相同点

###### 1. 都不能被直接实例化，都可以通过继承实现其抽象方法。

###### 2. 都是面向抽象编程的技术基础，实现了诸多的设计模式。

##### 不同点

###### 1. 接口支持多继承；抽象类不能实现多继承。

###### 2. 接口只能定义抽象规则；抽象类既可以定义规则，还可能提供已实现的成员。

###### 3. 接口是一组行为规范；抽象类是一个不完全的类，着重族的概念。

###### 4. 接口可以用于支持回调；抽象类不能实现回调，因为继承不支持。

###### 5. 接口只包含方法、属性、索引器、事件的签名，但不能定义字段和包含实现的方法；抽象类可以定义字段、属性、包含有实现的方法。

###### 6. 接口可以作用于值类型和引用类型；抽象类只能作用于引用类型。例如，Struct就可以继承接口，而不能继承类。

##### 规则与场合

###### 1. 请记住，面向对象思想的一个最重要的原则就是：面向接口编程。

###### 2. 借助接口和抽象类，23个设计模式中的很多思想被巧妙的实现了，我认为其精髓简单说来就是：面向抽象编程。

###### 3. 抽象类应主要用于关系密切的对象，而接口最适合为不相关的类提供通用功能。

###### 4. 接口着重于CAN-DO关系类型，而抽象类则偏重于IS-A式的关系；

###### 5. 接口多定义对象的行为；抽象类多定义对象的属性；

###### 6. 接口定义可以使用public、protected、internal 和private修饰符，但是几乎所有的接口都定义为public，原因就不必多说了。

###### 7. 在接口中，所有的方法都默认为public。

###### 8. “接口不变”，是应该考虑的重要因素。所以，在由接口增加扩展时，应该增加新的接口，而不能更改现有接口。

###### 9. 尽量将接口设计成功能单一的功能块，以.NET Framework为例，IDisposable、IDisposable、IComparable、IEquatable、IEnumerable等都只包含一个公共方法。

###### 10. 接口名称前面的大写字母“I”是一个约定，正如字段名以下划线开头一样，请坚持这些原则。

###### 11. 如果预计会出现版本问题，可以创建“抽象类”。例如，创建了狗（Dog）、鸡（Chicken）和鸭（Duck），那么应该考虑抽象出动物（Animal）来应对以后可能出现风马牛的事情。而向接口中添加新成员则会强制要求修改所有派生类，并重新编译，所以版本式的问题最好以抽象类来实现。

###### 12. 从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实实现。

###### 13. 对抽象类不能使用new关键字，也不能被密封，原因是抽象类不能被实例化。

###### 14. 在抽象方法声明中不能使用 static 或 virtual 修饰符。（abstract 不能与static 或virtual一起用）

##### MSDN建议

###### 1. 如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单易行的方法来控制组件版本。通过更新基类，所有继承类都随更改自动更新。另一方面，接口一旦创建就不能更改。如果需要接口的新版本，必须创建一个全新的接口。

###### 2. 如果创建的功能将在大范围的全异对象间使用，则使用接口。抽象类应主要用于关系密切的对象，而接口最适合为不相关的类提供通用功能。

###### 3. 如果要设计小而简练的功能块，则使用接口。如果要设计大的功能单元，则使用抽象类。

###### 4. 如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类。抽象类允许部分实现类，而接口不包含任何成员的实现。

###### .NET Framework中关于接口和抽象类的使用：

####### 集合类使用了基于接口的设计，请关注System.Collections中关于接口的设计实现；

####### 数据流相关类使用了基于抽象类的设计，请关注System.IO.Stream类的抽象类设计机制。

### 其他问题

#### OOA与OOD的区别

上讨论了OOA阶段和OOD阶段所应完成的主要工作,由于这两个阶段的划分没有公认
的标准,有些工作是在OOA阶段完成还是在OOD阶段完成还存在着争议。有人认为OOA和
OOD可以交叉进行;有人认为OOD是对OOA结果的改进和细化,所以只提OOA;有人则更
强调OOD。尽管OOA和OOD存在着某些交叉和联系,但它们之间仍有许多差别,如:
1)OOA将现实世界中的实体抽象为问题对象,并构造问题域中的系统需求模型;OOD将
问题对象转化为解域中的类并在解域中构造出问题的解。
2)OOA侧重于用户需求的分析和对问题域的理解,分析人员关心的是系统结构及对象间
的关系;OOD则侧重于系统的实现,设计人员关心的是对象的行为及其实现。
3)OOA标识了一组对象,并通过其相互作用来刻划系统,该阶段的工作与程序设计语言
无关;OOD定义了一组类,并设计出系统的实现蓝图,概要设计与程序设计语言无关,但详细
设计则与之有比较密切的联系。(
4)OOA识别的对象是对客观世界实体的抽象,标识对象的准则是:该对象的引入是否有助于对问题域的理解;OOD中构造类的准则是:该类的构造是否可行,是否有效地实现了抽象
数据类型,是否有助于系统的实现和提高软件质量。(
5)两个阶段都没有提及系统对象,但原因不同。在OOA阶段,分析与实现无关,分析所涉
及的范围与解域无关,系统对象自然不用考虑。OOD建立的对象模型本身就是要设计的软件
系统,对系统对象的考虑是隐含的。
6)组装结构和分类结构在两个阶段所起的作用不同。在OOA阶段,它们的引入主要是为
了理解问题;而在OOD阶段,它们的引入则主要是针对软件的构造和实现。分类结构通过继
承机制来实现,因而代码得到了有效地复用;组装结构则将一些类组合在一起构成较大的软件
构件。
7)OOA并没有考虑对象的产生问题,当其对应的实体在现实世界中出现时,它也就在问
题域中产生了。OOA也不考虑对象属性的取值和服务算法的实现。而在OOD阶段这些问题
都必须详细考虑。
8)OOD涉及到重载问题;而OOA没有考虑,因为考虑过多的实现细节对理解问题和分
析用户需求没有多大帮助。

#### 面向对象与面向过程区别

##### 5.1、面向对象是将事物高度抽象化。

##### 5.2、面向过程是一种自顶向下的编程

##### 5.3、面向对象必须先建立抽象模型，之后直接使用模型就行了。

##### 5.4、面向过程(OP)和面向对象(OO)本质的区别在于分析方式的不同，最终导致了编码方式的不同。


### 面向对象设计原则

#### 1、单一职责原则 SRP

> （Single Responsibility Principle）

> 一个类，只有一个引起它变化的原因。

> 应该只有一个职责。

> 每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。

> 这会导致脆弱的设计。

> 当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。

#### 2、开闭原则 OCP

> （Open Close Principle）

> 开闭原则就是说对扩展开放，对修改关闭。

> 在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。

> 所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。

> 想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

#### 3、里氏代换原则 LSP

> （Liskov Substitution Principle）

> 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。

> 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。

> LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，

> 而衍生类也能够在基类的基础上增加新的行为。

> 里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。

> 而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

#### 4、依赖倒转原则 DIP

> （Dependence Inversion Principle）

> 所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。

> 实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，

> 如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。

#### 5、接口隔离原则 ISP

> （Interface Segregation Principle）

> 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。

> 还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，

> 从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

#### 6、合成复用原则 CRP

> （Composite Reuse Principle）

> 合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；

> 新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。

#### 7、迪米特法则（最少知道原则）DP

> （Demeter Principle）

> 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

> 也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。

> 这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。



### Gof设计模式

> GoF:（Gang of Four，GOF设计模式）---四人组

> Design Patterns: Elements of Reusable Object-Oriented Software（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John 

> Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为“四人组（Gang of Four）”，而这本书也就被称为“四人组（或 GoF）”书。

#### 行为型

##### Iterator（迭代器模式）

> Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。

##### Interpreter（解析器模式）

> Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。

##### Observer（观察者模式）

> Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。

##### Mediator（中介者模式）

> Mediator（中介者模式）：用一个中介对象来封装一系列的对象交互。

> 中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

##### Visitor（访问者模式）

> Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

##### Memento（备忘录模式）

> Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。

##### State（状态模式）

> State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。

##### Strategy（策略模式）

> Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。

##### Template Method（模板方法模式）

> Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

> Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

##### Command（命令模式）

> Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。

##### Chain of Responsibility（职责链模式）

> Chain of Responsibility（职责链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

#### 创建型

##### Singleton（单例模式）

> Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

##### Prototype（原型模式）

> Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 

##### Builder（建造者模式）

> Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

##### Factory Method(工厂模式)

> Factory Method(工厂模式)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。 Factory Method使一个类的实例化延迟到其子类

#####  Abstract Factory（抽象工厂模式）

> Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

#### 结构型

##### Bridge（桥接模式）

> Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

##### Facade（外观模式）

> Facade（外观模式）：为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

##### Composite(组合模式)

> Composite(组合模式)：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。

##### Decorator(装饰模式)：

> Decorator(装饰模式)：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。

##### Adapter（适配器模式）

> Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

##### Proxy（代理模式）

> Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。

##### Flyweight（享元模式）

> Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。

#### 模式之间关系

#### 其他

#### 参考资料

##### 23种设计模式UML图

## UML

> UML是一种通用的建模语言，其表达能力相当的强，不仅可以用于软件系统的建模，而且可用于业务建模以及其它非软件系统建模。UML综合了各种面向对象方法与表示法的优点，至提出之日起就受到了广泛的重视并得到了工业界的支持。

### 组成

> a) 视图(View)： 是表达系统的某一方面的特征的UML建模元素的子集，由多个图构成，是在某一个抽象层上，对系统的抽象表示。

> b) 图(Diagram)： 是模型元素集的图形表示，通常是由弧（关系）和顶点（其他模型元素）相互连接构成的

> c) 模型元素(Model Element)：代表面向对象中的类、对象、消息和关系等概念，是构成图的最基本的常用概念。

> d) 通用机制(General Mechanism)：用于表示其他信息，比如注释、模型元素的语义等。另外，UML还提供扩展机制，使UML语言能够适应一个特殊的方法（或过程），或扩充至一个组织或用户。本的常用概念。

### 架构视图分类

> (1) 用例视图(Use Case View)，强调从用户的角度看到的或需要的系统功能，是被称为参与者的外部用户所能观察到的系统功能的模型图。

> (2) 逻辑视图(Logical View)，展现系统的静态或结构组成及特征，也称为结构模型视图(Structural Model View)或静态视图(Static View)。

> (3) 并发视图(Concurrent View)，体现了系统的动态或行为特征，也称为行为模型视图(Behavioral Model View)或动态视图(Dynamic View)。

> (4) 组件视图(Component View)，体现了系统实现的结构和行为特征，也称为实现模型视图(Implementation Model View)。

> (5) 配置视图(Deployment View)，体现了系统实现环境的结构和行为特征，也称为环境模型视图(Environment Model View)或物理视图(Physical View)。

### UML视图

#### UML视图

##### (1) 用例图(Use Case Diagram)，描述系统功能；

##### (2) 类图(Class Diagram)，描述系统的静态结构；

###### 基本元素符号：

####### 1. 类（Classes）类（Class）是指具有相同属性、方法和关系的对象的抽象，
它封装了数据和行为，是面向对象程序设计（OOP）的基础，
具有封装性、继承性和多态性等三大特性。
在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。

￿﻿[{"data":{"id":"cf32aswv30w0","created":1634613991376,"text":"类包含3个组成部分。第一个是Java中定义的类名。第二个是属性（attributes）。第三个是该类提供的方法。","richText":{"ops":[{"attributes":{},"insert":"类包含3个组成部分。第一个是Java中定义的类名。第二个是属性（attributes）。第三个是该类提供的方法。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]
￿﻿[{"data":{"id":"cf32aswutog0","created":1634613991376,"text":"属性和操作之前可附加一个可见性修饰符。加号（+）表示具有公共可见性。减号（-）表示私有可见性。#号表示受保护的可见性。省略这些修饰符表示具有package（包）级别的可见性。如果属性或操作具有下划线，表明它是静态的。在操作中，可同时列出它接受的参数，以及返回类型，如下图所示：","richText":{"ops":[{"attributes":{},"insert":"属性和操作之前可附加一个可见性修饰符。加号（+）表示具有公共可见性。减号（-）表示私有可见性。#号表示受保护的可见性。省略这些修饰符表示具有package（包）级别的可见性。如果属性或操作具有下划线，表明它是静态的。在操作中，可同时列出它接受的参数，以及返回类型，如下图所示："},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]

   * 1) 类名（Name）是一个字符串，例如，Student。

   * (2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：

   * [可见性]属性名:类型[=默认值]

   * 例如：-name:String

   * 注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。

   * (3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：

   * [可见性]名称(参数列表)[:返回类型]

   * 例如：+display():void。

####### 2. 包（Package）
包可直接理解为命名空间，文件夹，是用来组织图形的封装，包图可以用来表述功能组命名空间的组织层次。

•在面向对象软件开发的视角中，类显然是构建整个系统的基本构造块。
但是对于庞大的应用系统而言，其包含的类将是成百上千，
再加上其间“阡陌交纵”的关联关系、多重性等，必然是大大超出了人们可以处理的复杂度。
这也就是引入了“包”这种分组事物构造块。

￿﻿[{"data":{"id":"cf32aswvrh40","created":1634613991377,"text":"包是一种常规用途的组合机制。UML中的一个包直接对应于Java中的一个包。在Java中，一个包可能含有其他包、类或者同时含有这两者。进行建模时，你通常拥有逻辑性的包，它主要用于对你的模型进行组织。你还会拥有物理性的包，它直接转换成系统中的Java包。每个包的名称对这个包进行了惟一性的标识。","richText":{"ops":[{"attributes":{},"insert":"包是一种常规用途的组合机制。UML中的一个包直接对应于Java中的一个包。在Java中，一个包可能含有其他包、类或者同时含有这两者。进行建模时，你通常拥有逻辑性的包，它主要用于对你的模型进行组织。你还会拥有物理性的包，它直接转换成系统中的Java包。每个包的名称对这个包进行了惟一性的标识。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]

   * 包的可见性：

   * 用“+”来表示“public”，

   * 用“#”来表示“protected”，

   * 用“-”来表示“private”

####### 3. 接口（Interface）
接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，
只可以被子类实现。它包含抽象操作，但不包含属性。
它描述了类或组件对外可见的动作。
在 UML 中，接口使用一个带有名称的小圆圈来进行表示。

￿﻿[{"data":{"id":"cf32aswvqhc0","created":1634613991377,"text":"接口是一系列操作的集合，它指定了一个类所提供的服务。它直接对应于Java中的一个接口类型。接口既可用下面的那个图标来表示（上面一个圆圈符号，圆圈符号下面是接口名，中间是直线，直线下面是方法名），也可由附加了<<interface>>的一个标准类来表示。通常，根据接口在类图上的样子，就能知道与其他类的关系。\n","richText":{"ops":[{"insert":"接口是一系列操作的集合，它指定了一个类所提供的服务。它直接对应于Java中的一个接口类型。接口既可用下面的那个图标来表示（上面一个圆圈符号，圆圈符号下面是接口名，中间是直线，直线下面是方法名），也可由附加了<<interface>>的一个标准类来表示。通常，根据接口在类图上的样子，就能知道与其他类的关系。\n"}]},"background":"transparent"},"children":[]}]

###### 关　系：

####### 1. 依赖（Dependency）

1.1.1       依赖（Dependency）:虚线箭头表示
1、依赖关系也是类与类之间的联结
2、依赖总是单向的。（#add 注意，要避免双向依赖。一般来说，不应该存在双向依赖。）
3、依赖关系在 Java 或 C++ 语言中体现为局部变量、方法的参数或者对静态方法的调用。

（软件开发中，往往会设计一些公用类，供别的类调用，如果这些公用类出问题了，那调用这些公用类的类都会因此而出问题。
两个元素之间的一种关系，其中一个元素（提供者)的变化将影响另一个元素（客体)，或向它提供所需信息
显示一个类引用另一个类）

方法参数示例：

复制代码
public class Person
{
    void buy(Car car)
   {
       ...
    }
}
复制代码

表示方法：虚线加箭头

特点：当类与类之间有使用关系时就属于依赖关系，不同于关联关系，依赖不具有“拥有关系”，而是一种“相识关系”，只在某个特定地方（比如某个方法体内）才有关系。

依赖关系可以分为以下四类：
1）  使用依赖（Usage）表示客户使用提供者提供的服务以实现它的行为，包括：

使用<<use>>--声明使用一个类时需要用到已存在的另一个类。
调用<<call>>--声明一个类调用其他类的操作的方法。
参数<<parameter>>--声明一个操作和它的参数之间的关系。
发送<<send>>--声明信号发送者和信号接收者之间的关系。
实例化<<instantiate>>--声明用一个类的方法创建了另一个类的实例。
2）  抽象依赖（Abstraction）表示客户与提供者之间用不同的方法表现同一个概念，通常一个概念更抽象，一个概念更具体。包括：

跟踪<<trace>>--声明不同模型中的元素之间存在一些连接但不如映射精确。
精化<<refine>>--声明具有两个不同语义层次上的元素之间的映射。
派生<<derive>>--声明一个实例可以从另一个实例导出。
3）  授权依赖（Permission）表达提供者为客户提供某种权限以访问其内容的情形。包括：

访问<<access>>--允许一个包访问另一个包的内容。
导入<<import>>--允许一个包访问另一个包的内容并为被访问包的组成部分增加别名。
友元<<friend>>--允许一个元素访问另一个元素，不管被访问的元素是否具有可见性。
4）  绑定依赖（Binding）较高级的依赖类型，用于绑定模板以创建新的模型元素，包括：

绑定<<bind>>--为模板参数指定值，以生成一个新的模型元素。

   * 依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，
是临时性的关联。在代码中，某个类的方法通过局部变量、
方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。

####### 2. 关联（Association）

￿﻿[{"data":{"id":"cf32akd93z40","created":1634613972776,"text":"实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。","richText":{"ops":[{"attributes":{},"insert":"实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]

 关联（Association）：实线箭头表示
1、关联关系是类与类之间的联结，它使一个类知道另一个类的属性和方法。
2、关联可以是双向的，也可以是单向的（#add还有自身关联）。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。
3、在 Java 或 c++ 中，关联关系是通过使用成员变量来实现的。

复制代码
public class 徒弟
{  

}

public class 唐僧
{
     protected: list<徒弟> tdlist;
}
复制代码
 

表示方法：实线箭头

特征：表示类与类或类与接口之间的依赖关系，表现为“拥有关系”；具体到代码可以用实例变量来表示。（A类有一个成员变量保存的是B类的一个引用，也就是说由A类可以找到B类）

   * 关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，
如老师和学生、师傅和徒弟、丈夫和妻子等。
关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。

关联可以是双向的，也可以是单向的。在 UML 类图中，
双向的关联可以用带两个箭头或者没有箭头的实线来表示，
单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。
也可以在关联线的两端标注角色名，代表两种不同的角色。

####### 3. 聚合（Aggregation）

￿﻿[{"data":{"id":"cf32akd946w0","created":1634613972776,"text":"聚合是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。","richText":{"ops":[{"attributes":{},"insert":"聚合是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]
￿﻿[{"data":{"id":"cf32akd8tag0","created":1634613972776,"text":"关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。","richText":{"ops":[{"attributes":{},"insert":"关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]

1.1.3       聚合（Aggregation）：带空心菱形头表示
1、聚合关系是关联关系的一种，是强的关联关系。
2、聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成。
3、聚合关系也是通过成员变量来实现的。但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同的层次上，一个代表整体，一个代表部分。
4、关联与聚合仅仅从 Java 或 C++ 语法上是无法分辨的，必须考察所涉及的类之间的逻辑关系。

复制代码
public class 引擎
 {

 }
public class 轮胎
 {

 }
public class 汽车
{
        protected:引擎 engine;
        protected:轮胎 tyre[4];
}
复制代码
 

表示方法：空心菱形头

特征：属于是关联的特殊情况，体现部分-整体关系，是一种弱拥有关系；整体和部分可以有不一样的生命周期；是一种弱关联；

   * 聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，
是 has-a 的关系。聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，
但是成员对象可以脱离整体对象而独立存在。
例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。

####### 4. 合成（Composition）

￿﻿[{"data":{"id":"cf32akd8vlk0","created":1634613972776,"text":"合成是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。","richText":{"ops":[{"attributes":{},"insert":"合成是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]
￿﻿[{"data":{"id":"cf32akd8s680","created":1634613972776,"text":"局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。","richText":{"ops":[{"attributes":{},"insert":"局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]

1.1.4       组合（Composition）：带实心菱形头的实线表示
1、合成关系是关联关系的一种，是比聚合关系还要强的关系。
2、它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。

复制代码
class 肢
 {
 }
 class 人
 {
        protected:  肢   limb[4];
 }
复制代码

表示方法：一般是实心菱形加实线箭头表示

特征：属于是关联的特殊情况，也体现了体现部分-整体关系，是一种强“拥有关系”；整体与部分有相同的生命周期，是一种强关联；

   * 组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，
但它是一种更强烈的聚合关系，是 cxmtains-a 关系。
在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，
部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。

####### 5. 泛化（Generalization）

￿﻿[{"data":{"id":"cf32akd9luo0","created":1634613972777,"text":"泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。","richText":{"ops":[{"attributes":{},"insert":"泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]

1.1.5       泛化（Generalization）：
带空心箭头的实线线表示
泛化（下图）表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。

泛化关系表示类与类之间的继承关系，接口与接口之间的继承关系。如下图：

 

   * 泛化（Generalization）关系是对象之间耦合度最大的一种关系，
表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。

####### 6. 实现（Realization）

￿﻿[{"data":{"id":"cf32akd9t1k0","created":1634613972777,"text":"实例关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。","richText":{"ops":[{"attributes":{},"insert":"实例关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]

1.1.6       实现（Realization）：空心箭头和虚线表示
实例（图I）关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。表达一种说明元素与实现元素之间的关系；

   * 实现（Realization）关系是接口与实现类之间的关系。
在这种关系中，类实现了接口，
类中的操作实现了接口中所声明的所有的抽象操作。

####### 关系之间关联与区别

1.聚合与组合

（1）聚合与组合都是一种结合关系，只是额外具有整体-部分的意涵。

（2）部件的生命周期不同

聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。 
组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时间共享同一个部件。

（3）聚合关系是“has-a”关系，组合关系是“contains-a”关系。

“弱”包含表示如果部门没有了，员工也可以继续存在；
“强”包含表示如果部门没有了，员工也不再存在；
在做软件需求时，往往会将所有的包含关系画成“弱”包含，后面发现某些关系可以表示为“强”包含是，才转为实心菱形。

2.关联和聚合

（1）表现在代码层面，和关联关系是一致的，只能从语义级别来区分。

（2）关联和聚合的区别主要在语义上，关联的两个对象之间一般是平等的，例如你是我的朋友，聚合则一般不是平等的。

（3）关联是一种结构化的关系，指一种对象和另一种对象有联系。

（4）关联和聚合是视问题域而定的，例如在关心汽车的领域里，轮胎是一定要组合在汽车类中的，因为它离开了汽车就没有意义了。但是在卖轮胎的店铺业务里，就算轮胎离开了汽车，它也是有意义的，这就可以用聚合了。

3.关联和依赖

（1）关联关系中，体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。

（2）依赖关系中，可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A。

4.泛化和实现

实现表示类对接口的实现关系，表示方式：用一条带有空心三角箭头的虚线指向接口。

泛化表示类与类之间的继承关系、接口与接口之间的继承关系，表示方式一条带有空心三角箭头的实线指向基类（父接口）。

5.综合比较

　　这几种关系都是语义级别的，所以从代码层面并不能完全区分各种关系；但总的来说，后几种关系所表现的强弱程度依次为：

　　　　　　　　　　组合>聚合>关联>依赖

　　其中依赖（Dependency）的关系最弱，而关联（Association），聚合（Aggregation），组合（Composition）表示的关系依次增强。换言之关联，聚合，组合都是依赖关系的一种，聚合是表明对象之间的整体与部分关系的关联，而组合是表明整体与部分之间有相同生命周期关系的聚合。

而关联与依赖的关系用一句话概括下来就是，依赖描述了对象之间的调用关系，而关联描述了对象之间的结构关系。

##### (3) 对象图(Object Diagram)，描述系统在某个时刻的静态结构；

##### (4) 组件图(Component Diagram)，描述了实现系统的元素的组织；

##### (5) 配置图(Deployment Diagram)，描述了环境元素的配置，并把实现系统的元素映射到配置上；

##### (6) 状态图(State Diagram)，描述了系统元素的状态条件和响应；

##### (7) 时序图(Sequence Diagram)，按时间顺序描述系统元素间的交互；

##### (8) 协作图(Collaboration Diagram)，按照时间和空间顺序描述系统元素间的交互和它们之间的关系；

##### (9) 活动图(Activity Diagram)，描述了系统元素的活动；

##### Other

###### 包图

####### 包图是 UML 一種用以显示包和包之间的依赖关系的结构性图表。模型图能显示系统的不同视图，例如，多层应用程序。

###### 组合结构图

####### 组合结构图是添加到 UML 2.0 中的新的图表之一。复合结构图与类图相似，是一种用于微观视角的系统建模组件图，而不是整个类的组成部分。它是一种静态结构图，显示了一个类的内部结构和这个结构所实现的协作。

###### 轮廓图

####### 轮廓图 使您能够创建特定于域和平台的原型，并定义它们之间的关系。

###### 序列图

####### 序列图根据时间序列展示对象如何进行协作。它展示了在用例的特定场景中，对象如何与其他对象交互。凭借先进的可视化建模功能，您只需点击几下即可创建复杂的顺序图。另外，Visual Paradigm 可以根据用例描述中定义的事件流生成序列图。

###### 通訊圖

####### 与序列图类似，通訊圖也用于模拟用例的动态行为。与序列图相比，通訊圖更侧重于显示对象的协作而不是时间顺序。它们实际上在语义上是等价的，因此一些建模工具（如 Visual Paradigm）允许您从一个模型生成一个到另一个。

###### 交互概览图

####### 交互概述图侧重于交互控制流程的概述，它是活动图的变体，其中节点是交互 (Interactions) 或交互发生 (Interaction Occurrences)。交互概述图描述了隐藏於消息 (Message) 和生命线 (Lifeline) 間的交互。

###### 时序图

####### 时序图显示了既定时间内对象的行为。时序图是序列图的一种特殊形式，它俩之间的差异是轴反转，时间从左到右增加，生命线显示在垂直排列的独立隔间中。

###### 内部结构图

####### 内部结构图(Internal structure diagram):显示分类器的内部结构 – 将分类器分解为其属性，部件和关系。

   * 结构化类(structured class)，

   * 属性类(part)，

   * 端口(port)，

   * 连接器(connector)，

   * 作用关系(usage)。

###### 协作使用图

####### 协作使用图(Collaboration use diagram)显示系统中的对象彼此合作以产生系统的某些行为。

   * 协作(collaboration)，

   * 连接器(connector)，

   * 属性类(part)，

   * 依赖(dependency)。

###### 表现图

表现图(Manifestation diagram):用于显示工件的组件的显化（实现）和工件的内部结构。可以把它作为组件图和部署图的补充，组件图显示组件和分类器之间的组件关系，部署图表达把工件部署到部署环境。
 

由于表现图不是由UML 2.5规范定义的，因此可以使用组件图或部署图来显示通过构件显示的组件。

####### 表现形式(manifestation)，

####### 组件(component)，

####### 工件(artifact)。

###### 网络体系结构图

####### 网络体系结构图(Network architecture diagram):用来显示系统的逻辑或物理网络架构的部署图 。在UML 2.5中没有正式定义。

   * 节点(node)，

   * 交换机(switch)，

   * 路由器(router)，

   * 负载均衡器(load-balancer)，

   * 防火墙(firewall)，

   * 通信路径(communication-path)，

   * 网段(network-segment)，

   * 主干网(backbone)。

###### 配置文件图

配置文件图(Profile diagram):作为UML标准的轻量级扩展机制的辅助图，它允许定义定制的原型、标记值和约束。概要文件允许对不同的UML元模型进行调整
 

 

平台（比如J2EE或.NET）或者
域（如实时或业务流程建模）。
配置图首次在UML 2.0中引入。

####### 配置(profile)，

####### 配置类(profile-metaclass)，

####### 模板(stereotype)，

####### 配置扩展(profile-extension)，

####### 配置参考(profile-reference)，

####### 配置应用程序(profile-application)。

###### 信息流程图	

####### 信息流图(information-flow-diagrams):显示一些高度抽象的系统实体之间的信息交换。信息流在尚未完全明确或缺少细节的情况下，显示系统信息的流转过程。

   * 信息流(information-flow)，

   * 信息项目(information-item)，

   * 参与者(actor)，

   * 类(class)。

###### 行为状态机图

####### 行为状态机图(behavioral-state-machine)通过有限状态转换显示设计系统的一部分的离散行为。

   * 行为状态(behavioral state)，

   * 行为转换(behavioral transition)，

   * 伪状态(pseudostate)。

###### 协议状态机图

####### 协议状态机图(protocol state machine diagrams)：显示使用协议或某个分类器的生命周期，例如可以在分类器的每个状态下调用分类器的哪些操作，在哪些特定条件下以及在分类器转换到目标状态之后满足某些可选的后置条件。

   * 协议状态(protocol state)，

   * 协议转换(protocol transition)，

   * 伪状态(pseudostate)。

###### 交互图

交互图(Interaction diagram)包括几种不同类型的图：
 

序列图(sequence diagrams)，
通信图(communication-diagrams)（在UML 1.x中称为协作图），
时序图(timing diagrams)，
交互概览图(interaction overview diagrams)。

####### 序列图(sequence diagrams)，

   * 生命线(lifeline)，

   * 执行申明(execution specification)，

   * 消息(message)，

   * 复合片段(Combined Fragment)，

   * 交互使用(interaction use)，

   * 状态不变式(state invariant)，

   * 销毁(Destruction Occurrence)。

####### 通信图(communication-diagrams)（在UML 1.x中称为协作图），

   * 生命线(lifeline)，

   * 消息(message)。

####### 时序图(timing diagrams)，

   * 生命线(lifeline)，

   * 状态或状况时间表(state or condition timeline)，

   * 销毁事件(destruction event)，

   * 持续约束(duration constraint)，

   * 时间限制(duration constraint)。

####### 交互概览图(interaction overview diagrams)。

   * 交互概览图(interaction overview diagrams)通过一种活动图的变体定义交互，以促进控制流的概述。交互概述图侧重于交互或交互使用的控制流节点的概述 。生命线和消息不会出现在此概述中。

      * 初始节点(initial node)，

      * 流最终节点(flow final node)，

      * 活动最终节点(activity final node)，

      * 决策节点(decision node)，

      * 合并节点(merge node)，

      * 分叉节点(fork node)，

      * 连接节点(join node)，

      * 交互(interaction)，

      * 交互使用(interaction use)，

      * 持续约束(duration constraint)，

      * 时间限制(duration constraint)。

#### 分类

##### 不同架构视图的应用

###### (1) 用户模型视图

####### (1) 用例图(Use Case Diagram)

###### (2) 结构模型视图

####### (2) 类图(Class Diagram)；

####### (3) 对象图(Object Diagram)

###### (3) 行为模型视图

####### (6) 状态图(State Diagram)

####### (7) 时序图(Sequence Diagram)

####### (8) 协作图(Collaboration Diagram)

####### (9) 活动图(Activity Diagram)

###### (4) 实现模型视图

####### (4) 组件图(Component Diagram)

###### (5) 环境模型视图

####### (5) 配置图(Deployment Diagram)

##### 静态结构还是动态行为

###### 静态结构

####### (2) 类图(Class Diagram)；

####### (3) 对象图(Object Diagram)

####### (4) 组件图(Component Diagram)

####### (5) 配置图(Deployment Diagram)

###### 动态行为

####### (1) 用例图(Use Case Diagram)

####### (6) 状态图(State Diagram)

####### (7) 时序图(Sequence Diagram)

####### (8) 协作图(Collaboration Diagram)

####### (9) 活动图(Activity Diagram)

#### 4+1视图与UML视图对应

##### 场景视图 use case

##### 逻辑视图 类图

##### 开发视图 类图，组件图

##### 进程视图 无完全对应

##### 部署视图 部署图

### 词汇表和术语

#### 抽象类：一个永远不会被实例化的类。这个类的一个实例永远不会存在。

#### Actor（演员）：发起系统参与的事件的对象或人物。

#### 活动：活动图中的步骤或行动。表示系统或演员采取的行动。

#### 活动图：一个美化的流程图，显示了流程中的步骤和决定以及并行操作，如算法或业务流程。

#### 聚合：是另一类的一部分。图中的包含类旁边有一个空心钻石。

#### 工件：描述设计过程中某个步骤输出的文档。描述是图形，文字或其他组合。

#### 关联：一个模型的两个元素之间的联系。这可能代表代码中的成员变量，或者人员记录与其所代表的人之间的关联，或者两类工作人员之间的关系，或者任何类似的关系。默认情况下，一个关联中的两个元素是相等的，并且通过该关联知道对方。一个协会也可以是一个可导航的协会，这意味着协会的来源端知道目标端，但反之亦然。

#### 关联类：表示两个其他类之间的关联信息的类。

#### 属性：可用于引用其他对象或保存对象状态信息的对象的特征。

#### 基类：定义由子类通过泛化关系继承的属性和操作的类。

#### 分支：活动图中的决策点。分支出现多个转变，每个都有一个保护条件。当控制到达分支时，恰好一个保护条件必须为真; 并且控制遵循相应的转换。

#### 类：类似对象的类别，全部由相同的属性和操作描述，并且所有的赋值兼容。

#### 类图：显示系统类和它们之间的关系。

#### 分类器 ：具有属性和操作的UML元素。具体来说，Actor，Classes和Interfaces。

#### 协作：通信图中两个对象之间的关系，指示消息可以在对象之间来回传递。

#### 通信图：显示如何在强调对象角色的同时完成操作的图表。

#### 组件：系统中可部署的代码单元。

#### 组件图：显示各种组件和接口之间关系的图表。

#### 概念：要包含在域模型中的名词或抽象概念。

#### 构建阶段：Rational统一过程的第三阶段，在这个阶段中，正在构建的系统中内置了多个功能迭代。这是主要工作完成的地方。

#### 依赖关系：指示一个分类器的关系知道另一个分类器的属性和操作，但不直接连接到第二个分类器的任何实例。

#### 部署图：显示各种处理器之间关系的图表。

#### 域：系统所涉及的宇宙的一部分。

#### 精化阶段：Rational统一过程的第二阶段，允许额外的项目计划，包括构建阶段的迭代。

#### 元素：出现在模型中的任何项目。

#### 封装：对象中的数据是私有的。

#### 泛化：指示一个类是另一个类（超类）的子类。一个空心箭头指向超类。

#### 事件：在状态图中，这表示导致系统采取行动或切换状态的信号或事件或输入。

#### 最终状态 ：在状态图或活动图中，这表示图完成的点。

#### 叉：活动图中的一个点，多个并行控制线程开始。

#### 泛化：继承关系，其中一个子类继承并添加到基类的属性和操作。

#### 高凝聚力：GRASP评估模式，确保课程不是太复杂，做不相关的功能。

#### 低耦合：GRASP评估模式，衡量一个类别依赖于另一个类别或与另一个类别相关联。

#### 启动阶段：Rational统一过程的第一阶段，处理原始概念化和项目开始阶段。

#### 继承：子类继承父类（超类）类的属性或特性。这些属性可以在子类中重写。

#### 初始状态：在状态图或活动图中，这表示图开始的点。

#### 实例：一个类像模板一样用来创建一个对象。这个对象被称为类的一个实例。可以创建任何数量的该类的实例。

#### 接口：定义形成行为契约的属性和操作的分类器。提供者类或组件可以选择实现接口（即实现其属性和操作）。客户端类或组件可以依赖于接口，并因此使用提供者而不提供提供者的真实类别的任何细节。

#### 迭代：一个小项目部分，在这个小项目中，一小部分功能被添加到项目中。包括分析，设计和编码的开发循环。

#### 加入：活动图中的一个点，多个并行控制线程同步并重新加入。

#### 成员：分类器中的属性或操作。

#### 合并：活动图中的一个点，不同的控制路径汇集在一起​​。

#### 消息：从一个对象到另一个对象的请求，要求接收消息的对象执行某些操作。这基本上是对接收对象中的方法的调用。

#### 方法：对象中的函数或过程。

#### 模型：中央UML神器。由各个元素组成的层次结构，以及元素之间的关系。

#### 多重性：显示在领域模型中，表示外部概念框，表示与其他对象的分位数的对象数量关系。

#### 可导航性：指示关系的哪一端知道另一端。关系可以具有双向可导航性（每一端意识到另一端）或单向导航（一端意识到另一端，但反之亦然）。

#### 符号：创建分析和设计方法的图形化文档。

#### 注意：文字注释已添加到图表中以更详细地解释图表。

#### 对象：对象：在活动图中，从活动接收信息或向活动提供信息的对象。在“协作图”或“序列图”中，参与图中所示场景的对象。通常：给定分类器（Actor，Class或Interface）的一个实例或示例。

#### 包：逻辑上应该组合在一起的一组UML元素。

#### 包图：所有元素都是包和依赖关系的类图。

#### 模式：用于确定交互对象责任分配的解决方案。这是一个成功解决众所周知的常见问题的名称。

#### 参数：一个操作的参数。

#### 多态性：相同的消息，不同的方法。也用作模式。

#### 私有：应用于属性或操作的可见性级别，指示只有包含该成员的分类器的代码才可以访问该成员。

#### 处理器：在部署图中，代表可以部署代码的计算机或其他可编程设备。

#### 受保护：应用于属性或操作的可见性级别，指示只有包含该成员或其子类的分类器的代码才能访问该成员。

#### 公开：应用于属性或操作的可见性级别，指示任何代码都可以访问该成员。

#### 读取方向箭头：指示领域模型中关系的方向。

#### 实现：表示组件或类提供给定的接口。

#### 角色：用于域模型，是关于角色角色的可选描述。

#### 顺序图：一个图表，显示随着时间的推移对象的存在，以及随着时间的推移在这些对象之间传递的消息来执行一些行为。状态图图 - 显示所有可能的对象状态的图。

#### 状态：在状态图中，这表示系统或子系统的一种状态：它在某个时间点所做的事情，以及其数据的值。

#### 状态图：显示系统或子系统的状态，状态之间的转换以及导致转换的事件的图表。

#### 静态：一个属性的修饰符，用于指示分类器的所有实例之间共享的属性只有一个副本。“操作”的修饰符，用于指示“操作”独立运行并且不在分类器的一个特定实例上操作。

#### 刻板印象（Stereotype）：一个应用于Model元素的修饰符，用于指示它通常不能用UML表示的东西。从本质上讲，定型允许你定义你自己的UML“方言”。

#### 子类：继承由子类通过泛化关系定义的属性和操作的类。

#### 互動區：活动图的一个元素，指示系统或域的哪些部分执行特定的活动。泳道内的所有活动都由泳道所代表的对象，组件或者演员负责。

#### 时间拳击：每次迭代都会有特定目标的时间限制。

#### 过渡：在活动图中，表示从一个活动或分支或合并或分叉或连接到另一个的控制流程。在国家图中，代表着一个国家向另一个国家的转变。

#### 过渡阶段 - Rational 统一过程的最后一个阶段，在这个阶段，用户接受使用新系统和系统的培训，用户可以使用这个阶段。

#### 统一建模语言（ UML）：统一建模语言（ UML）利用文本和图形文档，通过在对象之间建立更紧密的关系，来增强软件项目的分析和设计

#### 用例：在用例图中，表示系统响应来自Actor的某个请求所采取的操作。

#### 用例图：显示参与者和用例之间关系的图表。

#### 可见性：对属性或操作的修饰符，指示哪些代码可以访问成员。可见性级别包括公共，受保护和私有。

#### 工作流程：一组产生特定结果的活动。



## 低代码平台

> 低代码开发平台（LCDP）是无需编码（0代码）或通过少量代码就可以快速生成应用程序的开发平台。通过可视化进行应用程序开发的方法，使具有不同经验水平的开发人员可以通过图形化的用户界面，使用拖拽组件和模型驱动的逻辑来创建网页和移动应用程序。低代码开发平台（LCDP）的正式名称直到2014年6月才正式确定，整个低代码开发领域却可以追溯到更早前第四代编程语言和快速应用开发工具。

### Microsoft Platform 

> 其包括 Power Apps, Power Apps Sutdio ,Power Apps Mobile, Power Platform Admin Center。

> Power BI 商业表格 Power Apps 创建app Power Pages 网页 Power Automate 自动化流程 Power Virtual Agents。 聊天机器人

> PCF（Power Apps Component Framework） 为程序员提供利用代码开发自定义组件。

> Microsoft Dataverse 存储和管理业务应用程序使用的数据

> 流程自动化。

## 工业自动化

### 工业自动化厂商

#### 国产

###### 汇川novance

####### 软件

######### InoProShop

######### AutoShop

####### 硬件

######### PLC

######### 伺服

######### 变频器

######### HMI

#### 日系

###### 欧姆龙Omron

###### 三菱

###### 日立

#### 欧系

###### 西门子

####### 软件

######### TIAPortal

######### WinCC

> > (SCADA(Supervisory Control And Data Acquisition)系统)

######### STEP7

####### 硬件

######### 工业自动化系统 SIMATIC（控制器以及相关解决方案）

> SIMATIC S7-1500

######### 运动控制系统 SIMOTION(驱动伺服等)

######### 数控系统INUMERIK

###### 施耐德

###### 贝福BackOff

#### 美系

###### 通用电气GE

####### 软件

######### Proficy HMI / SCADA

####### 硬件

######### PLC

######### 运动控制系统 

######### 数控系统

###### AB

###### 罗克韦尔Rockwell

####### 软件

######### Integrated Architecture Builder (IAB) 

来布局和验证控制系统，并生成提供控制系统详细信息的方案和材料单。

######### Studio 5000

环境可将各种设计元素整合于一个标准设计环境，优化生产率，缩短设计和试运转时间。这个直观的集成式设计环境以快速设计、重复利用、协作和虚拟设计为重点。更新后的用户界面可在所有 Studio 5000 应用程序中提供通用的现代用户体验。

####### 硬件

> PLC

> 运动控制系统 

> 数控系统

### 工业阶段

> 工业1.0

> > 机械化，以蒸汽机为标志，用蒸汽动力驱动机器取代人力，从此手工业从农业分离出来，正式进化为工业。

> 工业2.0

> > 电气化，以电力的广泛应用为标志，用电力驱动机器取代蒸汽动力，从此零部件生产与产品装配实现分工，工业进入大规模生产时代。

> 工业3.0

> > 自动化，以PLC（可编程逻辑控制器）和PC的应用为标志，从此机器不但接管了人的大部分体力劳动，同时也接管了一部分脑力劳动，工业生产能力也自此超越了人类的消费能力，人类进入了产能过剩时代。

> 工业4.0

> > 智能化机器人，最主要的就是万物互联。

### 自动化软件

#### TIA Portal

> 用于集成自动化项目的主要组件和功能的工程组态系统。

#### 控制器软件

> STEP 7产品系列用于SIMATIC S7控制器系统的组态、编程、测试和诊断。

#### 人机界面软件

> HMI 软件包括面板组态软件、基于 PC 的可视化软件以及 SCADA 系统。

#### SCADA软件

> 从过程可视化到工厂智能或基础设施项目的开放式系统的软件解决方案。

#### 用于能源管理的软件

> 能源管理软件包括现场层的能量数据记录到管理层的公司范围能量分析。

COMOS 工厂工程软件
COMOS 工厂工程软件

制造运营管理软件

产品生命周期管理软件

SIMIT 仿真软件
适用于 SIRIUS 开关装置的软件
适用于 SIRIUS 开关装置的软件
XHQ 运营智能软件
XHQ 运营智能软件

面向过程工业的西门子工业套件
PlantSight 
PlantSight 

### 常用工业软件分类

> CAD CAX

> 工艺系统

> 电气

> 仪表

> 结构

> 估算

> 项目管理

### 工业自动化设备

#### 变频器

#### 伺服

#### 可编程逻辑控制器

#### 人机交互 HMI

#### 传感器

#### 电机

#### PAC智能控制器

#### CNC控制器

#### 仪表

#### 基于PC的控制器

#### 识别

#### 工业机器人机械臂系统

#### PLC(可编程逻辑控制器)

###### CPU

###### 扩展模块

####### 数字输入模块

####### 数字输出模块

####### 模拟输入模块

####### 模拟输出模块

####### 脉冲定位模块

####### 温度模块

####### 电源模块

####### CAN通信模块

####### EtherCAT模块

######### EtherCAT通信接口模块

######### EtherCAT通信接口模块

######### EtherCAT数字量模块

######### EtherCAT高速计数模块

######### EtherCAT脉冲定位模块

######### EtherCAT温度检测模块

######### EtherCAT探针模块

######### EtherCAT从站分支器模块

####### 温度控制模块

####### 扩展板卡

####### 混合扩展模块

###### 分类

####### 按结构形式分类

######### 整体式PLC 

整体式PLC是将电源、CPU、I/O接口等部件都集中装在一个机箱内， 具有结构紧凑、体积小、价格低的特点。小型PLC一般采用这种整体式结构。整体式PLC由不同I/O点数的基本单元（又称主机）和扩展单元组成。基本单元内有CPU、I/O接口、与I/O扩展单元相连的扩展口，以及与编程器或EPROM写入器相连的接口等。扩展单元内只有I/O和电源等，没有CPU。基本单元和扩展单元之间一般用扁平电缆连接。整体式PLC一般还可配备特殊功能单元，如模拟量单元、位置控制单元等，使其功能得以扩展。

######### 模块式PLC

模块式PLC是将PLC各组成部分，分别作成若干个单独的模块，如CPU模块、I/O模块、电源模块（有的含在CPU模块中）以及各种功能模块。模块式PLC由框架或基板和各种模块组成。模块装在框架或基板的插座上。这种模块式PLC的特点是配置灵活，可根据需要选配不同规模的系统，而且装配方便，便于扩展和维修。大、中型PLC一般采用模块式结构。

    还有一些PLC将整体式和模块式的特点结合起来，构成所谓叠装式PLC。叠装式PLC其CPU、电源、I/O接口等也是各自独立的模块，但它们之间是靠电缆进行联接，并且各模块可以一层层地叠装。这样，不但系统可以灵活配置，还可做得体积小巧。

####### 按功能分类

######### 低档PLC

具有逻辑运算、定时、计数、移位以及自诊断、监控等基本功能，还可有少量模拟量输入／输出、算术运算、数据传送和比较、通信等功能。主要用于逻辑控制、顺序控制或少量模拟量控制的单机控制系统。

######### 中档PLC

除具有低档PLC的功能外，还具有较强的模拟量输入／输出、算术运算、数据传送和比较、数制转换、远程I/O、子程序、通信联网等功能。有些还可增设中断控制、PID控制等功能，适用于复杂控制系统。

######### 高档PLC 

除具有中档机的功能外，还增加了带符号算术运算、矩阵运算、位逻辑运算、平方根运算及其它特殊功能函数的运算、制表及表格传送功能等。高档PLC机具有更强的通信联网功能，可用于大规模过程控制或构成分布式网络控制系统，实现工厂自动化。

####### 按I/O点数分类

######### 小型PLC

I/O点数< 256点；单CPU、8位或16位处理器、用户存储器容量4K字以下。

如：GE-I型     美国通用电气（GE）公司

    TI100      美国德洲仪器公司

    F、F1、F2  日本三菱电气公司

    C20 C40    日本立石公司（欧姆龙）

    S7-200     德国西门子公司

    EX20 EX40  日本东芝公司

    SR-20/21   中外合资无锡华光电子工业有限公司

######### 中型PLC

I/O点数256～2048点；双CPU，用户存储器容量2～8K

如：S7-300     德国西门子公司

SR-400     中外合资无锡华光电子工业有限公司

SU-5、SU-6   德国西门子公司

C-500        日本立石公司

GE-Ⅲ        GE公司

######### 大型PLC

I/O点数> 2048点；多CPU，16位、32位处理器，用户存储器容量8～16K

    如：S7-400  德国西门子公司

GE-Ⅳ   GE公司

C-2000  立石公司

K3      三菱公司等

####### 程序执行方式

######### 解释型

具有逻辑运算、定时、计数、移位以及自诊断、监控等基本功能，还可有少量模拟量输入／输出、算术运算、数据传送和比较、通信等功能。主要用于逻辑控制、顺序控制或少量模拟量控制的单机控制系统。

######### 编译型

除具有低档PLC的功能外，还具有较强的模拟量输入／输出、算术运算、数据传送和比较、数制转换、远程I/O、子程序、通信联网等功能。有些还可增设中断控制、PID控制等功能，适用于复杂控制系统。

###### 其他

###### 程序员语言

####### IEC61131-3

######### 指令表（Instruction List Diagram，ILD）

######### 阶梯图（Ladder Diagram，LD）

######### 功能区块图（Function Block Diagram，FBD）

######### 结构化文字（Structured Text Language，STL）

######### 顺序功能流程图（Sequential Function Chart，SFC）

#### 其他

###### 机器人

###### HMI

###### 工业总线

###### IPC

#### 驱动类

###### 伺服系统：
是使物体的位置、方位、状态等输出，
能够跟随输入量（或给定值）的任意变化而变化的自动控制系统。
能够以一定的准确度响应控制信号的系统称为随动系统，亦称伺服系统。
伺服的主要任务是按控制命令的要求，对功率进行放大、变换与调控等处理，
使驱动装置输出的力矩、速度和位置控制得非常灵活方便。

####### 伺服

####### 伺服电机

####### 编码器

####### 伺服三种控制方式

####### 按结构分类

######### 开环伺服系统

######### 闭环伺服系统

########## 组成

   * 位置检测部分

   * 偏差放大部分

   * 执行部分

   * 被控对象

######### 半闭环系统、

######### 复合控制系统

####### 按驱动及种分类

######### 有电气式

######### 油压式

######### 电气—油压

####### 按功能分类

######### 计量伺服和功率伺服系统；

######### 模拟伺服和功率伺服系统；

######### 位置伺服和加速度伺服系统

####### 电气式伺服系统根据电气信号可分为

######### DC直流伺服系统

######### AC交流伺服系统

########## 异步电机伺服系统

########## 同步电机伺服系统

###### 子主题4

###### 子主题3

###### 变频器

#### DCS（Distributed Control System）

###### 硬件

####### 现场控制单元

现场控制单元一般远离控制中心，安装在靠近现场的地方，其高度模块化结构可以根据过程监测和控制的需要配置成由几个监控点到数百个监控点的规模不等的过程控制单元。
现场控制单元的结构是由许多功能分散的插板（或称卡件）按照一定的逻辑或物理顺序安装在插板箱中，各现场控制单元及其与控制管理级之间采用总线连接，以实现信息交互。
现场控制单元的硬件配置需要完成以下内容：
插件的配置 根据系统的要求和控制规模配置主机插件（CPU插件）、电源插件、I/O插件、通信插件等硬件设备；
硬件冗余配置 对关键设备进行冗余配置是提高DCS可靠性的一个重要手段，DCS通常可以对主机插件、电源插件、通信插件和网络、关键I/O插件都可以实现冗余配置。
硬件安装 不同的DCS，对于各种插件在插件箱中的安装，会在逻辑顺序或物理顺序上有相应的规定。另外，现场控制单元通常分为基本型和扩展型两种，所谓基本型就是各种插件安装在一个插件箱中，但更多的时候时需要可扩展的结构形式，即一个现场控制单元还包括若干数字输入/输出扩展单元，相互间采用总线连成一体。
就本质而言，现场控制单元的结构形式和配置要求与模块化PLC的硬件配置是一致的。

####### 操作站

操作站用来显示并记录来自各控制单元的过程数据，是人与生产过程信息交互的操作接口。典型的操作站包括主机系统、显示设备、键盘输入设备、信息存储设备和打印输出设备等，主要实现强大的显示功能（如模拟参数显示、系统状态显示、多种画面显示等等）、报警功能、操作功能、报表打印功能、组态和编程功能等等。
另外，DCS操作站还分为操作员站和工程师站。从系统功能上看，前者主要实现一般的生产操作和监控任务，具有数据采集和处理、监控画面显示、故障诊断和报警等功能。后者除了具有操作员站的一般功能以外，还应具备系统的组态、控制目标的修改等功能。从硬件设备上看，多数系统的工程师站和操作员站合在一起，仅用一个工程师键盘加以区分。

###### 软件

DCS的软件体系通常可以为用户提供相当丰富的功能软件模块和功能软件包，控制工程师利用DCS提供的组态软件，将各种功能软件进行适当的“组装连接”（即组态），生成满足控制系统的要求各种应用软件。
软件系统
现场控制单元的软件主要包括以实时数据库为中心的数据巡检、控制算法、控制输出和网络通信等软件模块组成。
实时数据库起到了中心环节的作用，在这里进行数据共享，各执行代码都与它交换数据，用来存储现场采集的数据、控制输出以及某些计算的中间结果和控制算法结构等方面的信息。数据巡检模块用以实现现场数据、故障信号的采集，并实现必要的数字滤波、单位变换、补偿运算等辅助功能。DCS的控制功能通过组态生成，不同的系统，需要的控制算法模块各不相同，通常会涉及以下一些模块：算术运算模块、逻辑运算模块、PID控制模块、变型PID模块、手自动切换模块、非线性处理模块、执行器控制模块等等。控制输出模块主要实现控制信号以故障处理的输出。
软件系统
DCS中的操作站用以完成系统的开发、生成、测试和运行等任务，这就需要相应的系统软件支持，这些软件包括操作系统、编程语言及各种工具软件等。一套完善的DCS，在操作站上运行的应用软件应能实现如下功能：实时数据库、网络管理、历史数据库管理、图形管理、历史数据趋势管理、数据库详细显示与修改、记录报表生成与打印、人机接口控制、控制回路调节、参数列表、串行通信和各种组态等。

####### 组态

DCS的开发过程主要是采用系统组态软件依据控制系统的实际需要生成各类应用软件的过程。组态软件功能包括基本配置组态和应用软件组态。基本配置组态是给系统一个配置信息，如系统的各种站的个数、它们的索引标志、每个控制站的最大点数、最短执行周期和内存容量等。应用软件的组态则包括比较丰富的内容，主要包括以下几个方面。

######### 控制回路的组态

控制回路的组态在本质上就是利用系统提供的各种基本的功能模块，来构成各种各样的实际控制系统。目前各种不同的DCS提供的组态方法各不相同，归纳起来有指定运算模块连接方式、判定表方式、步骤记录方式等等。
指定运算模块连接方式是通过调用各种独立的标准运算模块，用线条连接成多种多样的控制回路，最终自动生成控制软件，这是一种信息流和控制功能都很直观的组态方法。判定表方式是一种纯粹的填表形式，只要按照组态表格的要求，逐项填入内容或回答问题即可，这种方式很利于用户的组态操作。步骤记入方式是一种基于语言指令的编写方式，编程自由度大，各种复杂功能都可通过一些技巧实现，但组态效率较低。另外，由于这种组态方法不够直观，往往对组态工程师在技术水平和组态经验有较高的要求。

######### 实时数据库生成

实时数据库是DCS最基本的信息资源，这些实时数据由实时数据库存储和管理。在DCS中，建立和修改实时数据库记录的方法有多种，常用的方法是用通用数据库工具软件生成数据库文件，系统直接利用这种数据格式进行管理或采用某种方法将生成的数据文件转换为DCS所要求的格式。

######### 工业流程画面的生成

DCS是一种综合控制系统，它必须具有丰富的控制系统和检测系统画面显示功能。显然，不同的控制系统，需要显示的画面是不一样的。总的来说，结合总貌、分组、控制回路、流程图、报警等画面，以字符、棒图、曲线等适当的形式表示出各种测控参数、系统状态，是DCS组态的一项基本要求。此外，根据需要还可显示各类变量目录画面、操作指导画面、故障诊断画面、工程师维护画面和系统组态画面。

######### 历史数据库的生成

所有DCS都支持历史数据存储和趋势显示功能，历史数据库通常由用户在不需要编程的条件下，通过屏幕编辑编译技术生成一个数据文件，该文件定义了各历史数据记录的结构和范围。历史数据库中数据一般按组划分，每组内数据类型、采样时间一样。在生成时对各数据点的有关信息进行定义。

######### 控制回报表生成

DCS的操作员站的报表打印功能也是通过组态软件中的报表生成部分进行组态，不同的DCS在报表打印功能方面存在较大的差异。一般来说，DCS支持如下两类报表打印功能：一是周期性报表打印，二是触发性报表打印，用户根据需要和喜好生成不同的报表形式。

###### 先进控制技术

DCS在控制上的最大特点是依靠各种控制、运算模块的灵活组态，可实现多样化的控制策略以满足不同情况下的需要，使得在单元组合仪表实现起来相当繁琐与复杂的命题变得简单。随着企业提出的高柔性、高效益的要求，以经典控制理论为基础的控制方案已经不能适应，以多变量预测控制为代表的先进控制策略的提出和成功应用之后，先进过程控制受到了过程工业界的普遍关注。需要强调的是，广泛应用各种先进控制与优化技术是挖掘并提升DCS综合性能最有效、最直接、也是最具价值的发展方向。
在实际过程控制系统中，基于PID控制技术的系统占80%以上，PID回路运用优劣在实现装置平稳、高效、优质运行中起到举足轻重的作用，各DCS厂商都以此作为抢占市场的有力竞争砝码，开发出各自的PID自整定软件。另外，根据DCS的控制功能，在基本的PID算法基础上，可以开发各种改进算法，以满足实际工业控制现场的各种需要，诸如带死区的PID控制、积分分离的PID控制、微分先行的PID控制、不完全微分的PID控制、具有逻辑选择功能的PID控制等等。
与传统的PID控制不同，基于非参数模型的预测控制算法是通过预测模型预估系统的未来输出的状态，采用滚动优化策略计算当前控制器的输出。根据实施方案的不同，有各种算法，例如，内模控制、模型算法控制、动态矩阵控制等。目前，实用预测控制算法已引入DCS，例如IDCOM控制算法软件包已广泛应用于加氢裂化、催化裂化、常压蒸馏、石脑油催化重整等实际工业过程。此外，还有霍尼韦尔公司的HPC，横河公司的PREDICTROL，山武霍尼韦尔公司在TDC-3000LCN系统中开发的基于卡尔曼滤波器的预测控制器等等。这类预测控制器不是单纯把卡尔曼滤波器置于以往预测控制之前进行噪声滤波，而是把卡尔曼滤波器作为最优状态推测器，同时进行最优状态推测和噪声滤波。
PID回路显示控制器
PID回路显示控制器
先进控制算法还有很多。目前，国内、外许多控制软件公司和DCS厂商都在竞相开发先进控制和优化控制的工程软件包，希望在组态软件中嵌入先进控制和优化控制策略。
DCS在控制上的最大特点是依靠各种控制、运算模块的灵活组态，可实现多样化的控制策略以满足不同情况下的需要，使得在单元组合仪表实现起来相当繁琐与复杂的命题变得简单。随着企业提出的高柔性、高效益的要求，以经典控制理论为基础的控制方案已经不能适应，以多变量预测控制为代表的先进控制策略的提出和成功应用之后，先进过程控制受到了过程工业界的普遍关注。需要强调的是，广泛应用各种先进控制与优化技术是挖掘并提升DCS综合性能最有效、最直接、也是最具价值的发展方向。

####### PID回路

就是说先由控制器将收集到的数据与一个参考值进行比较，然后把这个差别用于计算新的输入值，这个新的输入值的目的是可以让系统的数据达到或者保持在一定的数值状态。和其他简单的控制运算不同，PID控制器可以根据历史数据和差别的出现率来调整输入值，这样可以使系统更加准确，更加稳定。
可以通过数学的方法证明，在其他控制方法导致系统有稳定误差或过程反复的情况下，一个PID反馈回路却可以保持系统的稳定。

在实际过程控制系统中，基于PID控制技术的系统占80%以上，PID回路运用优劣在实现装置平稳、高效、优质运行中起到举足轻重的作用，各DCS厂商都以此作为抢占市场的有力竞争砝码，开发出各自的PID自整定软件。另外，根据DCS的控制功能，在基本的PID算法基础上，可以开发各种改进算法，以满足实际工业控制现场的各种需要，诸如带死区的PID控制、积分分离的PID控制、微分先行的PID控制、不完全微分的PID控制、具有逻辑选择功能的PID控制等等。

######### 开环控制系统（open-loop control system）

开环控制系统（open-loop control system）是指被控对象的输出（被控制量 PID调节器）对控制器(controller)的输出没有影响。在这种控制系统中，不依赖将被控量反送回来以形成任何闭环回路。 

######### 闭环控制系统（closed-loop control system）

闭环控制系统（closed-loop control system）的特点是系统被控对象的输出（被控制量）会反送回来影响控制器的输出，形成一个或多个闭环。闭环控制系统有正反馈和负反馈，若反馈信号与系 统给定值信号相反，则称为负反馈（Negative Feedback），若极性相同，则称为正反馈，一般闭环控制系统均采用负反馈，又称负反馈控制系统。闭环控制系统的例子很多。比如人就是一个具有负反馈的闭环控制系统，眼睛便是传感器，充当反馈，人体系统能通过不断的修正最后作出各种正确的动作。如果没有眼睛，就没有了反馈回路，也就成了一个开环控制系 统。另例，当一台真正的全自动洗衣机具有能连续检查衣物是否洗净，并在洗净之后能自动切断电源，它就是一个闭环控制系统。 

####### 非参数模型的预测控制算法

与传统的PID控制不同，基于非参数模型的预测控制算法是通过预测模型预估系统的未来输出的状态，采用滚动优化策略计算当前控制器的输出。根据实施方案的不同，有各种算法，例如，内模控制、模型算法控制、动态矩阵控制等。目前，实用预测控制算法已引入DCS，例如IDCOM控制算法软件包已广泛应用于加氢裂化、催化裂化、常压蒸馏、石脑油催化重整等实际工业过程。此外，还有霍尼韦尔公司的HPC，横河公司的PREDICTROL，山武霍尼韦尔公司在TDC-3000LCN系统中开发的基于卡尔曼滤波器的预测控制器等等。这类预测控制器不是单纯把卡尔曼滤波器置于以往预测控制之前进行噪声滤波，而是把卡尔曼滤波器作为最优状态推测器，同时进行最优状态推测和噪声滤波。

######### 非参数模型的预测控制算法

与传统的PID控制不同，基于非参数模型的预测控制算法是通过预测模型预估系统的未来输出的状态，采用滚动优化策略计算当前控制器的输出。根据实施方案的不同，有各种算法，例如，内模控制、模型算法控制、动态矩阵控制等。目前，实用预测控制算法已引入DCS，例如IDCOM控制算法软件包已广泛应用于加氢裂化、催化裂化、常压蒸馏、石脑油催化重整等实际工业过程。此外，还有霍尼韦尔公司的HPC，横河公司的PREDICTROL，山武霍尼韦尔公司在TDC-3000LCN系统中开发的基于卡尔曼滤波器的预测控制器等等。这类预测控制器不是单纯把卡尔曼滤波器置于以往预测控制之前进行噪声滤波，而是把卡尔曼滤波器作为最优状态推测器，同时进行最优状态推测和噪声滤波。

####### 其他

先进控制算法还有很多。目前，国内、外许多控制软件公司和DCS厂商都在竞相开发先进控制和优化控制的工程软件包，希望在组态软件中嵌入先进控制和优化控制策略。

#### CNC

与普通机床相比，数控机床有如下特点：

●加工精度高，具有稳定的加工质量；
●可进行多坐标的联动，能加工形状复杂的零件；
●加工零件改变时，一般只需要更改数控程序，可节省生产准备时间；
●机床本身的精度高、刚性大，可选择有利的加工用量，生产率高（一般为普通机床的3~5倍）；
●机床自动化程度高，可以减轻劳动强度；
●对操作人员的素质要求较高，对维修人员的技术要求更高。

###### 组成

####### 主机

它是数控机床的主体，包括机床身、立柱、主轴、进给机构等机械部件。它是用于完成各种切削加工的机械部件。

####### 数控装置

是数控机床的核心，包括硬件（印刷电路板、CRT显示器、键盒、纸带阅读机等）以及相应的软件，用于输入数字化的零件程序，并完成输入信息的存储、数据的变换、插补运算以及实现各种控制功能。

####### 驱动装置

它是数控机床执行机构的驱动部件，包括主轴驱动单元、进给单元、主轴电机及进给电机等。它在数控装置的控制下通过电气或电液伺服系统实现主轴和进给驱动。当几个进给联动时，可以完成定位、直线、平面曲线和空间曲线的加工。

####### 辅助装置

指数控机床的一些必要的配套部件，用以保证数控机床的运行，如冷却、排屑、润滑、照明、监测等。它包括液压和气动装置、排屑装置、交换工作台、数控转台和数控分度头，还包括刀具及监控检测装置等。

####### 编程及其他附属设备

可用来在机外进行零件的程序编制、存储等。

#### SCADA

SCADA(Supervisory Control And Data Acquisition)系统，即数据采集与监视控制系统。SCADA系统是以计算机为基础的DCS与电力自动化监控系统；它应用领域很广，可以应用于电力、冶金、石油、化工、燃气、铁路等领域的数据采集与监视控制以及过程控制等诸多领域。
在电力系统中，SCADA系统应用最为广泛，技术发展也最为成熟。它在远动系统中占重要地位,可以对现场的运行设备进行监视和控制，以实现数据采集、设备控制、测量、参数调节以及各类信号报警等各项功能,即我们所知的"四遥"功能.RTU(远程终端单元),FTU(馈线终端单元)是它的重要组成部分．在现今的变电站综合自动化建设中起了相当重要的作用．
SCADA(Supervisory Control And Data Acquisition)系统，即数据采集与监视控制系统，涉及到组态软件、数据传输链路（如：数传电台、GPRS等）

###### 硬件

通常SCADA系统分为两个层面，即客户/服务器体系结构。服务器与硬件设备通信，进行数据处理和运算。而客户用于人机交互，如用文字、动画显示现场的状态，并可以对现场的开关、阀门进行操作。还有一种“超远程客户”，它可以通过Web发布在Internet上进行监控。硬件设备(如PLC)一般既可以通过点到点方式连接，也可以以总线方式连接到服务器上。点到点连接一般通过串口(RS232)，总线方式可以是RS485，以太网等连接方式。

###### 软件

SCADA由很多任务组成，每个任务完成特定的功能。位于一个或多个机器上的服务器负责数据采集，数据处理（如量程转换、滤波、报警检查、计算、事件记录、历史存储、执行用户脚本等）。服务器间可以相互通讯。有些系统将服务器进一步单独划分成若干专门服务器，如报警服务器，记录服务器，历史服务器，登录服务器等。各服务器逻辑上作为统一整体，但物理上可能放置在不同的机器上。分类划分的好处是可以将多个服务器的各种数据统一管理、分工协作，缺点是效率低，局部故障可能影响整个系统  。

###### 通信

SCADA系统中的通信分为内部通信、与I/O设备通信、和外界通信。客户与服务器间以及服务器与服务器间一般有三种通信形式，请求式，订阅式与广播式。设备驱动程序与I/O设备通讯一般采用请求式，大多数设备都支持这种通讯方式，当然也有的设备支持主动发送方式。SCADA通过多种方式与外界通信。如OPC，一般都会提供OPC客户端，用来与设备厂家提供的OPC服务器进行通讯。因为OPC有微软内定的标准，所以OPC客户端无需修改就可以与各家提供的OPC服务器进行通讯。

###### 系统构成

SCADA系统主要有以下部分组成：监控计算机、远程终端单元（RTU）、可编程逻辑控制器（PLC）、通信基础设施、人机界面（HMI）。
使用SCADA概念可以构建大型和小型系统。这些系统的范围可以从几十到几千个控制回路，具体取决于应用。示例流程包括工业，基础设施和基于设施的流程，如下所述：
工业过程包括制造，过程控制，发电，制造和精炼，并可以连续，间歇，重复或离散模式运行。
基础设施过程可以是公共的或私人的，包括水处理和分配，污水收集和处理，油气管道，电力输送和配电以及风力发电场。
设施流程，包括建筑物，机场，船舶和空间站。他们监视和控制暖气，通风和空调系统（HVAC），通道和能源消耗。
但是，SCADA系统可能存在安全漏洞，因此应对系统进行评估，以识别风险和解决方案，以减轻这些风险。

####### 监控计算机

远程终端单元，也称为（RTU），连接到过程中的传感器和执行器，并与监控计算机系统联网。 RTU是“智能I / O”，并且通常具有嵌入式控制功能，例如梯形逻辑，以实现布尔逻辑操作。

####### 可编程逻辑控制器

也称为PLC，它们连接到过程中的传感器和执行器，并以与RTU相同的方式联网到监控系统。 与RTU相比，PLC具有更复杂的嵌入式控制功能，并且采用一种或多种IEC 61131-3编程语言进行编程。 PLC经常被用来代替RTU作为现场设备，因为它们更经济，多功能，灵活和可配置。

####### 通信基础设施

这将监控计算机系统连接到远程终端单元（RTU）和PLC，并且可以使用行业标准或制造商专有协议。 RTU和PLC都使用监控系统提供的最后一个命令，在过程的近实时控制下自主运行。 通信网络的故障并不一定会停止工厂的过程控制，而且在恢复通信时，操作员可以继续进行监视和控制。 一些关键系统将具有双冗余数据高速公路，通常通过不同的路线进行连接。

####### 人机界面

人机界面（HMI）是监控系统的操作员窗口。它以模拟图的形式向操作人员提供工厂信息，模拟图是控制工厂的示意图，以及报警和事件记录页面。 HMI连接到SCADA监控计算机，提供实时数据以驱动模拟图，警报显示和趋势图。在许多安装中，HMI是操作员的图形用户界面，收集来自外部设备的所有数据，创建报告，执行报警，发送通知等。
模拟图由用来表示过程元素的线图和示意符号组成，或者可以由工艺设备的数字照片覆盖动画符号组成。
工厂的监督操作是通过HMI进行的，操作员使用鼠标指针，键盘和触摸屏发出命令。例如，泵的符号可以向操作员显示泵正在运行，并且流量计符号可以显示通过管道泵送了多少流体。操作员可以通过鼠标点击或屏幕触摸从模拟器切换泵。 HMI将显示管道中流体的流量实时减少。
SCADA系统的HMI包通常包含一个绘图程序，操作员或系统维护人员用来改变这些点在接口中的表示方式。这些表示可以像在屏幕上的交通灯一样简单，其代表现场中实际交通灯的状态，或者像代表摩天大楼中所有电梯的位置的多投影仪显示器一样复杂，或者全部火车上的火车。
“历史记录”是HMI中的一项软件服务，它在数据库中存储带时间戳的数据，事件和报警，可以查询或用于填充HMI中的图形趋势。历史学家是从数据采集服务器请求数据的客户端  。

#### FCS（Fieldbus Control System）现场总线

由于3C（Computer、Control、Communication）技术的发展，过程控制系统将由DCS发展到FCS（Fieldbus Control System）。FCS可以将PID控制彻底分散到现场设备（Field Device）中。基于现场总线的FCS又是全分散、全数字化、全开放和可互操作的新一代生产过程自动化系统，它将取代现场一对一的4~20mA模拟信号线，给传统的工业自动化控制系统体系结构带来革命性的变化。
根据IEC61158的定义，现场总线是安装在制造或过程区域的现场装置与控制室内的自动控制装置之间的数字式、双向传输、多分支结构的通信网络。现场总线使测控设备具备了数字计算和数字通信能力，提高了信号的测量、传输和控制精度，提高了系统与设备的功能、性能。IEC/TC65的SC65C/WG6工作组于1984年开始致力于推出世界上单一的现场总线标准工作，走过了16年的艰难历程，于1993年推出了IEC61158-2，之后的标准制定就陷于混乱。
计算机控制系统的发展在经历了基地式气动仪表控制系统、电动单元组合式模拟仪表控制系统、集中式数字控制系统以及集散控制系统（DCS）后，将朝着现场总线控制系统（FCS）的方向发展。虽然以现场总线为基础的FCS发展很快，但FCS发展还有很多工作要做，如统一标准、仪表智能化等。另外，传统控制系统的维护和改造还需要DCS，因此FCS完全取代传统的DCS还需要一个较长的过程，同时DCS本身也在不断的发展与完善。可以肯定的是，结合DCS、工业以太网、先进控制等新技术的FCS将具有强大的生命力。工业以太网以及现场总线技术作为一种灵活、方便、可靠的数据传输方式，在工业现场得到了越来越多的应用，并将在控制领域中占有更加重要的地位。

### 工业现场总线

> 现场总线（Field bus）是近年来迅速发展起来的一种工业数据总线，它主要解决工业现场的智能化仪器仪表、控制器、执行机构等现场设备间的数字通信以及这些现场控制设备和高级控制系统之间的信息传递问题。由于现场总线简单、可靠、经济实用等一系列突出的优点，因而受到了许多标准团体和计算机厂商的高度重视。

#### 国产

###### EPA

###### G-link,

###### Symotion

###### NCUC-BUS

#### IEC61158 Ed.3

###### Type 1 TS61158现场总线

###### Type 2 ControlNet和Ethernet/IP现场总线

###### Type 3 Profibus现场总线

###### Type 4 P-NET现场总线

###### Type 5 FF HSE现场总线

###### Type 6 SwiftNet现场总线

###### Type 7 World FIP现场总线

###### Type 8 Interbus现场总线

###### Type 9 FF H1现场总线

###### Type 10 PROFInet现场总线

#### 其他

###### 1、PROFIBUS

     

Profibus 作为一种快速总线，被广泛应用于分布式外围组件(PROFIBUS-DP)。除了 PROFIBUS-DP 和 FMS 以外，Beckhoff 还支持驱动器通讯标准 PROFIBUS MC。过程现场总线。  

###### 2、EtherCAT

EtherCAT(Ethernet for Control Automation Technology，用于控制和自动化技术的以太网)是一种用于工业自动化的实时以太网解决方案，性能优越，使用简便。     

###### 3、Lightbus

这种经过验证的 Beckhoff 光纤总线系统具有极为优秀的抗 EMI 性能，易于安装，数据流快速、循环且具有确定性。

###### 4、Interbus

Interbus 易于配置，通讯快速而可靠。主/从系统的移位寄存器协议可提供高效循环通讯。

###### 5、CANopen

通过有效利用总线带宽，CANopen 可在即使相对较低的数据传输速率时也能实现较短的系统响应时间。秉承了 CAN 的传统优点，例如数据安全性高且具备多主站能力。

###### 6、ControlNet 

ControlNet 是一种开放式标准现场总线系统。该总线协议允许循环数据和非循环数据通过总线同时进行交换，而两者之间互不影响。     

###### 7、SERCOS interface

SERCOS 最初作为用于驱动器的快速光纤总线系统研发。采用 Beckhoff SERCOS 总线耦合器，I/O 设备可以实现高速率数据传输和较短的循环时间。      

###### 8、Ethernet

以太网是办公环境中的主流标准。在Beckhoff 以太网产品中，也秉承并发扬了以太网的优点，例如数据传输速率高，与现有网络的简便集成以及广泛的服务和接口等。

###### 9、PROFINET

PROFINET 是一种由 PNO(PROFIBUS 用户组织)针对开放式工业以太网制定的标准：国际上订立的一种针对通讯的 IT 标准(如 TCP/IP 协议)。 

###### 10、USB

USB 已成为 PC 技术的标准接口，具有传输速率高，拓扑结构灵活(通过集成集线器)等特点，加上 Beckhoff USB 总线耦合器，在距离较短时，该系统可替代现场总线。 

###### 11、Modbus

Modbus 是一种基于主/从结构的开放式串行通讯协议。可非常轻松地在所有类型的串行接口上实现，已被广泛接受。

###### 12、RS232/RS485

RS232 和 RS485 是经典的串行接口，一直被广泛使用。Beckhoff RS485/RS232 I/O模块采用的是易于实现的简单串行通讯协议

###### 13、CC-Link

CC-Link(Control & Communication Link，控制与通信链路)是一种开放式总线系统，用于控制级和现场总线级之间的通讯。应用方面主要以亚洲地区为主。

###### 14、AS-Interface

AS interface 通过简单、经济的布线方法，连接传感器、执行器与上位控制层。AS interface 已通过 EN 50295 和IEC 62026-2 标准，在国际上实现了标准化。

###### 15、LON

LON(Local Operating Network，局部操作网络)是一种能够进行多网络连接的通讯系统，用于分布式应用。

###### 16、EIB

EIB(European Installation Bus，欧洲安装总线)是一种用于楼宇布线的总线系统，主要在欧洲得到广泛应用。

###### 17、SNMP

简单网络管理协议。

###### 18、QOS

服务质量，解决延时和阻塞的一种技术。 

###### 19、CAN

控制器局域网络

###### 20、MECHATROLINK

MECHATROLINK是一个用在工业自动化的开放式通讯协定 

#### 总线本质

不同的机构和不同的人可能对现场总线有着不同的定义，不过通常情况下，大家公认在以下六个方面：

从以上内容我们可以看到，现场总线体现了分布、开放、互联、高可靠性的特点，而这些正是DCS系统的缺点。DCS通常是一对一单独传送信号，其所采用的模拟信号精度低，易受干扰，位于操作室的操作员对模拟仪表往往难以调整参数和预测故障，处于“失控”状态，很多的仪表厂商自定标准，互换性差，仪表的功能也较单一，难以满足现代的要求，而且几乎所有的控制功能都位于控制站中。FCS则采取一对多双向传输信号，采用的数字信号精度高、可靠性强，设备也始终处于操作员的远程监控和可控状态，用户可以自由按需选择不同品牌种类的设备互联，智能仪表具有通信、控制和运算等丰富的功能，而且控制功能分散到各个智能仪表中去。由此我们可以看到FCS相对于DCS的巨大进步。
也正是由于FCS的以上特点使得其在设计、安装、投运到正常生产都具有很大的优越性：首先由于分散在前端的智能设备能执行较为复杂的任务，不再需要单独的控制器、计算单元等，节省了硬件投资和使用面积；FCS的接线较为简单，而且一条传输线可以挂接多个设备，大大节约了安装费用；由于现场控制设备往往具有自诊断功能，并能将故障信息发送至控制室，减轻了维护工作；同时，由于用户拥有高度的系统集成自主权，可以通过比较灵活选择合适的厂家产品；整体系统的可靠性和准确性也大为提高。这一切都帮助用户实现了减低安装、使用、维护的成本，最终达到增加利润的目的  。

###### 通信网络

用于过程自动化和制造自动化的现场设备或现场仪表互连的现场通信网络。

###### 设备互联

依据实际需要使用不同的传输介质把不同的现场设备或者现场仪表相互关联。

###### 互操作性

用户可以根据自身的需求选择不同厂家或不同型号的产品构成所需的控制回路，从而可以自由地集成FCS。

###### 分散功能块

FCS 废弃了DCS 的输入/输出单元和控制站, 把DCS 控制站的功能块分散地分配给现场仪表, 从而构成虚拟控制站，彻底地实现了分散控制。

###### 通信线供电

通信线供电方式允许现场仪表直接从通信线上摄取能量, 这种方式提供用于本质安全环境的低功耗现场仪表, 与其配套的还有安全栅。

###### 开放式互联网

现场总线为开放式互联网络，既可以与同层网络互联，也可与不同层网络互联，还可以实现网络数据库的共享。

#### 发展趋势

从现场总线技术本身来分析，它有两个明显的发展趋势：
一是寻求统一的现场总线国际标准
二是Industrial Ethernet走向工业控制网络
统一、开放的TCP/IP Ethernet是20多年来发展最成功的网络技术 ，过去一直认为，Ethernet是为IT领域应用而开发的，它与工业网络在实时性、环境适应性、总线馈电等许多方面的要求存在差距，在工业自动化领域只能得到有限应用。事实上，这些问题正在迅速得到解决，国内对EPA技术（Ethernet for Process Automation）也取得了很大的进展。随着FF HSE的成功开发以及PROFInet的推广应用，可以预见Ethernet技术将会十分迅速地进入工业控制系统的各级网络。
国际上形成的工业以太网技术的四大阵营：
主要用于离散制造控制系统的是：
Modbus-IDA工业以太网
Ethernet/IP工业以太网
PROFInet工业以太网
主要用于过程控制系统的是：
Foundation Fieldbus HSE工业以太网
随着科学技术的快速发展，过程控制领域在过去的两个世纪里发生了巨大的变革。150多年前出现的基于5－13psi的气动信号标准（PCS，Pneumatic Control System气动控制系统），标志着控制理论初步形成，但此时尚未有控制室的概念；20世纪50年代，随着基于0－5V或4－20mA的电流模拟信号的模拟过程控制体系被提出并得到广泛的应用，标志了电气自动控制时代的到来，三大控制论的确立奠定了现代控制的基础，设立控制室、控制功能分离的模式也一直沿用；20世纪70年代，随着数字计算机的介入，产生了“集中控制”的中央控制计算机系统，而信号传输系统大部分是依然沿用4－20mA的模拟信号，不久人们也发现了伴随着“集中控制”，该系统存在着易失控、可靠性低的缺点，并很快将其发展为分布式控制系统（DCS，Distributed Control System分布式控制系统）；微处理器的普遍应用和计算机可靠性的提高，使分布式控制系统得到了广泛的应用，由多台计算机和一些智能仪表以及智能部件实现的分布式控制是其最主要的特征，而数字传输信号也在逐步取代模拟传输信号。随着微处理器的快速发展和广泛的应用，数字通信网络延伸到工业过程现场成为可能，产生了以微处理器为核心，使用集成电路代替常规电子线路，实施信息采集、显示、处理、传输以及优化控制等功能的智能设备。设备之间彼此通信、控制，在精度、可操作性以及可靠性、可维护性等都有更高的要求。由此，导致了现场总线的产生。
由于各个国家各个公司的利益之争，虽然早在1984年国际电工技术委员会/国际标准协会（IEC/ISA）就着手开始制定现场总线的标准，统一的标准仍未完成。很多公司也推出其各自的现场总线技术，但彼此的开放性和互操作性还难以统一 。

###### 概要

世界上存在着大约四十余种现场总线，如法国的FIP，英国的ERA，德国西门子公司Siemens的ProfiBus，挪威的FINT，Echelon公司的LONWorks，PhenixContact公司的InterBus，RoberBosch公司的CAN，Rosemount公司的HART，CarloGavazzi公司的Dupline，丹麦ProcessData公司的P-net，PeterHans公司的F-Mux，以及ASI（ActraturSensorInterface），MODBus，SDS，Arcnet，国际标准组织-基金会现场总线FF：FieldBusFoundation，WorldFIP，BitBus，美国的DeviceNet与ControlNet等等。这些现场总线大都用于过程自动化、医药领域、加工制造、交通运输、国防、航天、农业和楼宇等领域，大概不到十种的总线占有80%左右的市场。
工业总线网络可归为三类：485网络、HART网络、FieldBus现场总线网络。
485网络：RS485/MODBUS是流行的一种工业组网方式，其特点是实施简单方便，而且支持RS485的仪表又特别多。仪表商也纷纷转而支持RS485/MODBUS，原因很简单， RS485的转换接口不仅便宜而且种类繁多。至少在低端市场上，RS485/MODBUS仍将是最主要的工业组网方式。
HART网络：HART是由艾默生提出的一个过渡性总线标准，主要特征是在4-20毫安电流信号上面叠加数字信号，但该协议并未真正开放，要加入他的基金会才能拿到协议，而加入基金会要一定的费用。HART技术主要被国外几家大公司垄断，近些年国内也有公司在做，但还没有达到国外公司的水平。有很多智能仪表带有[HART圆卡]，支持HART通讯功能。但从国内情况来看，还没有真正用到这部分功能来进行设备联网监控，最多只是利用手操器对其进行参数设定。从长远来看，由于HART通信速率低、组网困难等原因，HART仪表的应用将呈下滑趋势。
FieldBus现场总线网络：现场总线是当今自动化领域的热点技术之一，被誉为自动化领域的计算机局域网。它的出现标志着自动化控制技术又一个新时代的开始。现场总线是连接控制现场的仪表与控制室内的控制装置的数字化、串行、多站通信的网络。其关键标志是能支持双向、多节点、总线式的全数字化通信。现场总线技术成为国际上自动化和仪器仪表发展的热点，它的出现使传统的控制系统结构产生了革命性的变化，使自控系统朝着“智能化、数字化、信息化、网络化、分散化”的方向进一步迈进，形成新型的网络通信的全分布式控制系统——现场总线控制系统FCS(Fieldbus Control System)。然而，现场总线还没有形成真正统一的标准，ProfiBus、CANbus、CC-Link等多种标准并行存在，并且都有自己的生存空间。何时统一，遥遥无期。支持现场总线的仪表种类还比较少，可供选择的余地小，价格又偏高，用量也较小。

#### 主流

###### 1、基金会现场总线（FoundationFieldbus 简称FF）

这是以美国Fisher-Rousemount公司为首的联合了横河、ABB、西门子、英维斯等80家公司制定的ISP协议和以Honeywell公司为首的联合欧洲等地150余家公司制定的WorldFIP协议于1994年9月合并的。该总线在过程自动化领域得到了广泛的应用，具有良好的发展前景。
基金会现场总线采用国际标准化组织ISO的开放化系统互联OSI的简化模型（1，2，7层），即物理层、数据链路层、应用层，另外增加了用户层。FF分低速H1和高速H2两种通信速率，前者传输速率为31.25Kbit/秒，通信距离可达1900m，可支持总线供电和本质安全防爆环境。后者传输速率为1Mbit/秒和2.5Mbit/秒，通信距离为750m和500m，支持双绞线、光缆和无线发射，协议符号IEC1158-2标准。FF的物理媒介的传输信号采用曼切斯特编码。

###### 2、CAN（ControllerAreaNetwork控制器局域网）

最早由德国BOSCH公司推出，它广泛用于离散控制领域，其总线规范已被ISO国际标准组织制定为国际标准，得到了Intel、Motorola、NEC等公司的支持。CAN协议分为二层：物理层和数据链路层。CAN的信号传输采用短帧结构，传输时间短，具有自动关闭功能，具有较强的抗干扰能力。CAN支持多主工作方式，并采用了非破坏性总线仲裁技术，通过设置优先级来避免冲突，通讯距离最远可达10KM/5Kbps/s，通讯速率最高可达40M /1Mbp/s，网络节点数实际可达110个。已有多家公司开发了符合CAN协议的通信芯片。

###### 3、Lonworks

它由美国Echelon公司推出，并由Motorola、Toshiba公司共同倡导。它采用ISO/OSI模型的全部7层通讯协议，采用面向对象的设计方法，通过网络变量把网络通信设计简化为参数设置。支持双绞线、同轴电缆、光缆和红外线等多种通信介质，通讯速率从300bit/s至1.5M/s不等，直接通信距离可达2700m（78Kbit/s），被誉为通用控制网络。Lonworks技术采用的LonTalk协议被封装到Neuron（神经元）的芯片中，并得以实现。采用Lonworks技术和神经元芯片的产品，被广泛应用在楼宇自动化、家庭自动化、保安系统、办公设备、交通运输、工业过程控制等行业。

###### 4、DeviceNet

DeviceNet是一种低成本的通信连接也是一种简单的网络解决方案，有着开放的网络标准。DeviceNet具有的直接互联性不仅改善了设备间的通信而且提供了相当重要的设备级阵地功能。DeviceNet基于CAN技术，传输率为125Kbit/s至500Kbit/s,每个网络的最大节点为64个，其通信模式为：生产者/客户（Producer/Consumer），采用多信道广播信息发送方式。位于DeviceNet网络上的设备可以自由连接或断开，不影响网上的其他设备，而且其设备的安装布线成本也较低。DeviceNet总线的组织结构是Open DeviceNet Vendor Association（开放式设备网络供应商协会，简称“ODVA”）。

###### 5、PROFIBUS

PROFIBUS是德国标准（DIN19245）和欧洲标准（EN50170）的现场总线标准。由PROFIBUS--DP、PROFIBUS－FMS、PROFIBUS－PA系列组成。DP用于分散外设间高速数据传输，适用于加工自动化领域。FMS适用于纺织、楼宇自动化、可编程控制器、低压开关等。PA用于过程自动化的总线类型，服从IEC1158－2标准。PROFIBUS支持主-从系统、纯主站系统、多主多从混合系统等几种传输方式。PROFIBUS的传输速率为9.6Kbit/s至12Mbit/s，最大传输距离在9.6Kbit/s下为1200m，在12Mbit/s小为200m，可采用中继器延长至10km，传输介质为双绞线或者光缆，最多可挂接127个站点。

###### 6、HART 

HART是Highway Addressable Remote Transducer的缩写，最早由Rosemount公司开发。其特点是在现有模拟信号传输线上实现数字信号通信，属于模拟系统向数字系统转变的过渡产品。其通信模型采用物理层、数据链路层和应用层三层，支持点对点主从应答方式和多点广播方式。由于它采用模拟数字信号混和，难以开发通用的通信接口芯片。HART能利用总线供电，可满足本质安全防爆的要求，并可用于由手持编程器与管理系统主机作为主设备的双主设备系统。

###### 7、CC-Link

CC-Link是Control&Communication Link（控制与通信链路系统）的缩写，在1996年11月，由三菱电机为主导的多家公司推出，其增长势头迅猛，在亚洲占有较大份额。在其系统中，可以将控制和信息数据同是以10Mbit/s高速传送至现场网络，具有性能卓越、使用简单、应用广泛、节省成本等优点。其不仅解决了工业现场配线复杂的问题，同时具有优异的抗噪性能和兼容性。CC-Link是一个以设备层为主的网络，同时也可覆盖较高层次的控制层和较低层次的传感层。2005年7月CC-Link被中国国家标准委员会批准为中国国家标准指导性技术文件。

###### 8、WorldFIP

WorldFIP的北美部分与ISP合并为FF以后，WorldFIP的欧洲部分仍保持独立，总部设在法国。其在欧洲市场占有重要地位，特别是在法国占有率大约为60%。WorldFIP的特点是具有单一的总线结构来适用不同的应用领域的需求，而且没有任何网关或网桥，用软件的办法来解决高速和低速的衔接。WorldFIP与FFHSE可以实现“透明联接”，并对FF的H1进行了技术拓展，如速率等。在与IEC61158第一类型的连接方面，WorldFIP做得最好，走在世界前列。

###### 9、INTERBUS

INTERBUS是德国Phoenix公司推出的较早的现场总线，2000年2月成为国际标准IEC61158。INTERBUS采用国际标准化组织ISO的开放化系统互联OSI的简化模型（1，2，7层），即物理层、数据链路层、应用层，具有强大的可靠性、可诊断性和易维护性。其采用集总帧型的数据环通信，具有低速度、高效率的特点，并严格保证了数据传输的同步性和周期性；该总线的实时性、抗干扰性和可维护性也非常出色。INTERBUS广泛地应用到汽车、烟草、仓储、造纸、包装、食品等工业，成为国际现场总线的领先者。

###### 其他

此外较有影响的现场总线还有丹麦公司Process-Data A/S 提出的P-Net，该总线主要应用于农业、林业、水利、食品等行业；SwiftNet现场总线主要使用在航空航天等领域，还有一些其他的现场总线这里就不再赘述了。

#### 控制组成

###### 1、现场总线控制系统：

它的软件是系统的重要组成部分，控制系统的软件有组态软件、维护软件、仿真软件、设备软件和监控软件等。首先选择开发组态软件、控制操作人机接口软件。通过组态软件，完成功能块之间的连接，选定功能块参数，进行网络组态。在网络运行过程中对系统实时采集数据、进行数据处理、计算。优化控制及逻辑控制报警、监视、显示、报表等。

###### 2、现场总线的测量系统：

其特点为多变量高性能的测量，使测量仪表具有计算能力等更多功能，由于采用数字信号，具有高分辨率，准确性高、抗干扰、抗畸变能力强，同时还具有仪表设备的状态信息，可以对处理过程进行调整。

###### 3、设备管理系统：

可以提供设备自身及过程的诊断信息、管理信息、设备运行状态信息（包括智能仪表）、厂商提供的设备制造信息。例如Fisher—Rosemoune公司，推出AMS管理系统，它安装在主计算机内，由它完成管理功能，可以构成一个现场设备的综合管理系统信息库，在此基础上实现设备的可靠性分析以及预测性维护。将被动的管理模式改变为可预测性的管理维护模式AMS软件是以现场服务器为平台的T型结构，在现场服务器上支撑模块化，功能丰富的应用软件为用户提供一个图形化界面。

###### 4、总线系统计算机服务模式：

以客户机/服务器模式是较为流行的网络计算机服务模式。服务器表示数据源（提供者），应用客户机则表示数据使用者，它从数据源获取数据，并进一步进行处理。客房机运行在PC机或工作站上。服务器运行在小型机或大型机上，它使用双方的智能、资源、数据来完成任务。

###### 5、数据库：

它能有组织的、动态的存储大量有关数据与应用程序，实现数据的充分共享、交叉访问，具有高度独立性。工业设备在运行过程中参数连续变化，数据量大，操作与控制的实时性要求很高。因此就形成了一个可以互访操作的分布关系及实时性的数据库系统，市面上成熟的供选用的如关系数据库中的Oracle，sybas，Informix，SQL Server；实时数据库中的Infoplus，PI，ONSPEC等。

###### 6、网络系统的硬件与软件：

网络系统硬件有：系统管理主机、服务器、网关、协议变换器、集线器，用户计算机等及底层智能化仪表。网络系统软件有网络操作软件如：NetWarc，LAN Mangger，Vines，服务器操作软件如Lunix，os/2，Window NT。应用软件数据库、通信协议、网络管理协议等。

#### I/O接口

I/O接口是一电子电路(以IC芯片或接口板形式出现 ),其内有若干专用寄存器和相应的控制逻辑电路构成。它是CPU和I/O设备之间交换信息的媒介和桥梁。CPU与外部设备、存储器的连接和数据交换都需要通过接口设备来实现，前者被称为I/O接口，而后者则被称为存储器接口。存储器通常在CPU的同步控制下工作，接口电路比较简单；而I/O设备品种繁多，其相应的接口电路也各不相同，因此，习惯上说到接口只是指I/O接口。

###### 基本功能

####### （1）进行端口地址译码设备选择。

####### （2）向CPU提供I/O设备的状态信息和进行命令译码。

####### （3）进行定时和相应时序控制。

####### （4）对传送数据提供缓冲，以消除计算机与外设在“定时”或数据处理速度上的差异。

####### （5）提供计算机与外设间有关信息格式的相容性变换。提供有关电气的适配

####### （6）还可以中断方式实现CPU与外设之间信息的交换。

###### 控制方式

####### （1）程序查询方式

这种方式下，CPU通过I/O指令询问指定外设当前的状态，如果外设准备就绪，则进行数据的输入或输出，否则CPU等待，循环查询。

这种方式的优点是结构简单，只需要少量的硬件电路即可，缺点是由于CPU的速度远远高于外设，因此通常处于等待状态，工作效率很低

####### （2）中断处理方式

在这种方式下，CPU不再被动等待，而是可以执行其他程序，一旦外设为数据交换准备就绪，可以向CPU提出服务请求，CPU如果响应该请求，便暂时停止当前程序的执行，转去执行与该请求对应的服务程序，完成后，再继续执行原来被中断的程序。

中断处理方式的优点是显而易见的，它不但为CPU省去了查询外设状态和等待外设就绪所花费的时间，提高了CPU的工作效率，还满足了外设的实时要求。但需要为每个I/O设备分配一个中断请求号和相应的中断服务程序，此外还需要一个中断控制器（I/O接口芯片）管理I/O设备提出的中断请求，例如设置中断屏蔽、中断请求优先级等。

此外，中断处理方式的缺点是每传送一个字符都要进行中断，启动中断控制器，还要保留和恢复现场以便能继续原程序的执行，花费的工作量很大，这样如果需要大量数据交换，系统的性能会很低。

####### （3）DMA（直接存储器存取）传送方式

DMA最明显的一个特点是它不是用软件而是采用一个专门的控制器来控制内存与外设之间的数据交流，无须CPU介入，大大提高CPU的工作效率。

在进行DMA数据传送之前，DMA控制器会向CPU申请总线控制 权，CPU如果允许，则将控制权交出，因此，在数据交换时，总线控制权由DMA控制器掌握，在传输结束后，DMA控制器将总线控制权交还给CPU。

####### （4）无条件传送方式

####### （5）I/O通道方式

####### （6）I/O处理机方式

###### 现场接口分类

基于控制网络的这些特点，其中的各种接口必须保证满足控制网络的要求。目前工业现场的接口种类有以下四类

####### （1）平台相关性通用协议：OPC/ DDE

OPC 是为了不同供应厂商的设备和应用程序之间的软件接口标准化，使其间的数据交换更加简单化的目的而提出的。作为结果，从而可以向用户提供不依靠于特定开发语言和开发环境的可以自由组合使用的过程控制软件组件产品。

####### （2）平台无关性通讯协议：ModBus、ProfiBus

Modbus 协议是应用于电子控制器上的一种通用语言。 通过此协议，控制器相互之间、控制器经由网络（例如以太网）和其它设备之间可以通信。它已经成为一通用工业标准。有了它，不同厂商生产的控制设备可以连成工业网络，进行集中监控。Profibus，是一种国际化、开放式、不依赖于设备生产商的现场总线标准。 Profibus 传送速度可在 9．6kbaud～12Mbaud 范围内选择且当总线系统启动时， 所有连接到总线上的装置应该被设成相同的速度。广泛适用于制造业自动化、流程工业自动化和楼宇、交通电力等其他领域自动化。Profibus是一种用于工厂自动化车间级监控和现场设备层数据通信与控制的现场总线技术。

####### （3）平台无关专有协议：大部分DCS协议、工业以太网协议

####### （4）特殊协议：编程口、打印口等特殊方式取得的协议

工业传输通讯的协议种类较多主要有历史遗留和人为垄断两方面的原因。虽然目前还有大量的现场总线标准，但没有任何一种标准比工业以太网更具生命力[2]。

各种现场总线/协议/接口总结[3]

工业自动化总线/协议/接口的名称 标识 特点简介 说明

ASI 用于下位控制级的传感器/执行器总线 AS-interface 用于将传感器和执行器连接 至上位控制层，布线简单、经济。AS interface 符合国际标准EN 50295 和IEC 62026-2 标准。 AS-Interface（AS-i = 执行器/传感器接口） 是用于连接执行器和传感器的现场总线通讯方案。 【整理】ASI接口/协议/规范

BACnet==楼宇自动控制网络数据通讯协议 Building Automation Control Network 【整理】工业自动化之楼宇自动化之通讯协议：BACnet

CANopen 用于执行器/传感器领域的多主站总线 对总线带宽的有效利用使得CANopen能 够在数据传输速率相对较低的情况下实 现较短的系统响应时间。CAN 总线的主 要优点有：数据安全性高，能够保留多 主站能力。

CC-Link 主要针对亚洲市场的现场总线CC-Link（Control & Communication Link， 控制与通信链路）是一种开放式总线系统，用于控制级和现场总线级之间的通讯，应用范围主要为亚洲地区。

ControlNet 标准化现场总线ControlNet 是一种开放式标准现场总线系统。该总线协议允许循环数据和非循环数据同时通过总线进行交换，而两者之间互不影响。

DALI 楼宇自动化领域的通讯标准 DALI 标准（IEC60929）是一种跨越厂商的协议，其目的是在照明应用中确保电子镇流器的互用性。这个新标准用于替代1-10V调光器接口。 数字可寻址照明接口（DALI，Digital Addressable Lighting Interface）是一种楼宇自动 化标准，用于电子镇流器的数字控制。 DALI 作为一种子系统使用，例如照明、百叶帘或温度控制，可直接与楼宇管理 系统进行通讯。 【整理】工业自动化总线之楼宇自动化之照明接口：DALI

DeviceNet 采用CAN技术的设备总线DeviceNet 是一种传感器/执行器总线系统， 起源于美国，但现在在欧洲和亚洲地区也得到越来越多的应用。DeviceNet 基于CAN（Controller Area Net，控制器局域网）总线。

DMX EIB 楼宇自动化领域的通讯标准EIB（European Installation Bus，欧洲安装 总线） 是一种用于楼宇布线的总线系统，主要在欧洲地区广泛应用。

EnOcean 免维护、无需电池、无需接线是一种无线技术。主要用于楼宇自动化：不同的设备模块（比如一个灯的开关）内嵌了EnOcean支持。则就可以通过控制器控制该设备。 【整理】工业自动化之楼宇自动化之无线协议：EnOcean

EtherCAT==高速实时以太网现场总线 EtherCAT（Ethernet Control Automation Technology，用于控制和自动化技术的以太网）是用于工业自动化的以太网解决方 ，具有性能优异和操作简单等特点。

EtherNet/IP 来自ODVA 的工业以太网解决方案Ethernet/IP 是由ODVA（Open DeviceNet Vendor Association，开放式设备网络供货商协会）制定的工业以太网标准，它以Ethernet TCP/IP 和UDP/IP 标准为基础。

Ethernet TCP/IP 网络总线以太网是办公领域的一项重要标准，以太网所具备的很多优点，如传输速率高、与现有网络的集成简单、服务范围广以及接口种类多等，在Beckhoff 的以太网产品中也得到充分体现。

FIAS FIAS==Fidelio接口和应用规范==（估计是）**F**idelio **I**nterface **A**pplication **S**pecification FIAS（Fidelio接口和应用规范）是世界领先的酒店管理软件的接口。 【整理】工业自动化之楼宇自动化之酒店管理软件的接口：FIAS和Fidelio

Fipio 符合WorldFIP 标准的现场总线FIP 符合欧洲标准EN 50170，并受到来 自WorldFIP 现场总线组织的独立制造商支持。通过周期性和非周期性的变量和信息交换，能够根据具体的应用调整总线性能

IEEE 1588 InterBus Interbus，于1987年进入市场interbus 现场总线具有组态方便、速度快、 可靠性高特点。这种主/从站系统的移位寄存器通信协议可提高循环通信的效率。

【整理】现场总线：InterBus

IO-Link IO-Link完美地将控制系统和工具加工所需的不同接口实现了标准化。IO-Link 可使用经济的点对点连接方法将 传感器和执行器连接至控制层。作为一种开放式接口，IO-Link 可集成于所有常用的现场总线系统中。IO-Link 系统由IO-Link 设备组成，如传感器、执行器或两者的结合。它们采用的是传统的三线制连接技术。 【整理】IO-Link

LightBus==高速光纤现场总线 无干扰现场总线通讯，用于高速机械控制这是由Beckhoff 公司开发的一种光纤总线系统，具有很高的成熟度，主要特点包括：抗电磁干扰性强、安装简便，数据传输速度非常快并具循环性和高度确定性。

LON 楼宇自动化领域的通讯标准LON（Local Operating Network，局域操作 网络）是一种能够进行多网络连接的通 讯系统，用于分布式应用，主要用于商 业楼宇的自动化应用领域。

Modbus 开放式现场总线Modbus 是一种基于主/从站结构的开放 式串行通讯协议。由于该协议可以非常轻松地在所有类型的串行接口上执行，因此得到了广泛认可。

MP-Bus 【整理】MP-Bus

Profibus PROFIBUS DP/FMS 符合欧洲标准EN50170PROFIBUS 作为一种高速总线，被广泛应 用于分布式外围设备（PROFIBUS DP）。除了PROFIBUS DP 和FMS 之外，Beckhoff还支持用于驱动器通讯的PROFIBUS MC协议

PROFINET 来自PNO 的工业以太网解决方案PROFINET 是由PNO（PROFIBUS 用户组 织）制定的开放式工业以太网标准，诸如TCP/IP这些国际公认的IT 标准则用于实现通讯。

RS232/RS485 最经济的解决方案，网络RS232 和RS485 是‘传统的’串行接口， 一直都被广泛应用。Beckhoff 的RS485/RS232 I/O 模块采用的是一种简单、易于实现的串行通讯协议。

SERCOS III 来自驱动工程领域的总线，SERCOS 最初是针对驱动器开发的一种高 速光纤总线系统。由于Beckhoff 开发了SERCOS 总线耦合器，使得SERCOS 总线的一些优点（如数据传输速率高，周期时间短）现在也可以用于I/O 外围设备。

USB 实验室用高速接口USB 已成为PC 技术领域中应用的标准接 口。由于USB 具有传输速率高、拓扑结构灵活（通过集成集线器）等特点，加上Beckhoff 的USB 总线耦合器，在距离较短的应用场合，该系统可替代现场总线。

比如：

Beckhoff的CX9000通过总线耦合器可以接出去多种总线：

EtherCAT可以集成很多现场总线：

类似的扩展其他总线的实物图是：

可以看到上面扩展出来的几个总线是：

ProfibusProfinetCANopenDeviceNet

### DCS

> > （Distributed Control System）

#### 硬件

> 现场控制单元

> > 现场控制单元一般远离控制中心，安装在靠近现场的地方，其高度模块化结构可以根据过程监测和控制的需要配置成由几个监控点到数百个监控点的规模不等的过程控制单元。

> > 现场控制单元的结构是由许多功能分散的插板（或称卡件）按照一定的逻辑或物理顺序安装在插板箱中，各现场控制单元及其与控制管理级之间采用总线连接，以实现信息交互。

> > 现场控制单元的硬件配置需要完成以下内容：

> > 插件的配置 根据系统的要求和控制规模配置主机插件（CPU插件）、电源插件、I/O插件、通信插件等硬件设备；

> > 硬件冗余配置 对关键设备进行冗余配置是提高DCS可靠性的一个重要手段，DCS通常可以对主机插件、电源插件、通信插件和网络、关键I/O插件都可以实现冗余配置。

> > 硬件安装 不同的DCS，对于各种插件在插件箱中的安装，会在逻辑顺序或物理顺序上有相应的规定。另外，现场控制单元通常分为基本型和扩展型两种，所谓基本型就是各种插件安装在一个插件箱中，但更多的时候时需要可扩展的结构形式，即一个现场控制单元还包括若干数字输入/输出扩展单元，相互间采用总线连成一体。

> > 就本质而言，现场控制单元的结构形式和配置要求与模块化PLC的硬件配置是一致的。

> 操作站

> > 操作站用来显示并记录来自各控制单元的过程数据，是人与生产过程信息交互的操作接口。典型的操作站包括主机系统、显示设备、键盘输入设备、信息存储设备和打印输出设备等，主要实现强大的显示功能（如模拟参数显示、系统状态显示、多种画面显示等等）、报警功能、操作功能、报表打印功能、组态和编程功能等等。

> > 另外，DCS操作站还分为操作员站和工程师站。从系统功能上看，前者主要实现一般的生产操作和监控任务，具有数据采集和处理、监控画面显示、故障诊断和报警等功能。后者除了具有操作员站的一般功能以外，还应具备系统的组态、控制目标的修改等功能。从硬件设备上看，多数系统的工程师站和操作员站合在一起，仅用一个工程师键盘加以区分。

> 软件

> > DCS的软件体系通常可以为用户提供相当丰富的功能软件模块和功能软件包，控制工程师利用DCS提供的组态软件，将各种功能软件进行适当的“组装连接”（即组态），生成满足控制系统的要求各种应用软件。

> > 现场控制单元的软件主要包括以实时数据库为中心的数据巡检、控制算法、控制输出和网络通信等软件模块组成。

> > 实时数据库起到了中心环节的作用，在这里进行数据共享，各执行代码都与它交换数据，用来存储现场采集的数据、控制输出以及某些计算的中间结果和控制算法结构等方面的信息。数据巡检模块用以实现现场数据、故障信号的采集，并实现必要的数字滤波、单位变换、补偿运算等辅助功能。DCS的控制功能通过组态生成，不同的系统，需要的控制算法模块各不相同，通常会涉及以下一些模块：算术运算模块、逻辑运算模块、PID控制模块、变型PID模块、手自动切换模块、非线性处理模块、执行器控制模块等等。控制输出模块主要实现控制信号以故障处理的输出。

> > DCS中的操作站用以完成系统的开发、生成、测试和运行等任务，这就需要相应的系统软件支持，这些软件包括操作系统、编程语言及各种工具软件等。一套完善的DCS，在操作站上运行的应用软件应能实现如下功能：实时数据库、网络管理、历史数据库管理、图形管理、历史数据趋势管理、数据库详细显示与修改、记录报表生成与打印、人机接口控制、控制回路调节、参数列表、串行通信和各种组态等。

> 组态

> > DCS的开发过程主要是采用系统组态软件依据控制系统的实际需要生成各类应用软件的过程。组态软件功能包括基本配置组态和应用软件组态。基本配置组态是给系统一个配置信息，如系统的各种站的个数、它们的索引标志、每个控制站的最大点数、最短执行周期和内存容量等。应用软件的组态则包括比较丰富的内容，主要包括以下几个方面。

> > 控制回路的组态

控制回路的组态在本质上就是利用系统提供的各种基本的功能模块，来构成各种各样的实际控制系统。目前各种不同的DCS提供的组态方法各不相同，归纳起来有指定运算模块连接方式、判定表方式、步骤记录方式等等。
指定运算模块连接方式是通过调用各种独立的标准运算模块，用线条连接成多种多样的控制回路，最终自动生成控制软件，这是一种信息流和控制功能都很直观的组态方法。判定表方式是一种纯粹的填表形式，只要按照组态表格的要求，逐项填入内容或回答问题即可，这种方式很利于用户的组态操作。步骤记入方式是一种基于语言指令的编写方式，编程自由度大，各种复杂功能都可通过一些技巧实现，但组态效率较低。另外，由于这种组态方法不够直观，往往对组态工程师在技术水平和组态经验有较高的要求。

> > 实时数据库生成

实时数据库是DCS最基本的信息资源，这些实时数据由实时数据库存储和管理。在DCS中，建立和修改实时数据库记录的方法有多种，常用的方法是用通用数据库工具软件生成数据库文件，系统直接利用这种数据格式进行管理或采用某种方法将生成的数据文件转换为DCS所要求的格式。

> > > 工业流程画面的生成

DCS是一种综合控制系统，它必须具有丰富的控制系统和检测系统画面显示功能。显然，不同的控制系统，需要显示的画面是不一样的。总的来说，结合总貌、分组、控制回路、流程图、报警等画面，以字符、棒图、曲线等适当的形式表示出各种测控参数、系统状态，是DCS组态的一项基本要求。此外，根据需要还可显示各类变量目录画面、操作指导画面、故障诊断画面、工程师维护画面和系统组态画面。

> > > 历史数据库的生成

所有DCS都支持历史数据存储和趋势显示功能，历史数据库通常由用户在不需要编程的条件下，通过屏幕编辑编译技术生成一个数据文件，该文件定义了各历史数据记录的结构和范围。历史数据库中数据一般按组划分，每组内数据类型、采样时间一样。在生成时对各数据点的有关信息进行定义。

> > > 控制回报表生成

DCS的操作员站的报表打印功能也是通过组态软件中的报表生成部分进行组态，不同的DCS在报表打印功能方面存在较大的差异。一般来说，DCS支持如下两类报表打印功能：一是周期性报表打印，二是触发性报表打印，用户根据需要和喜好生成不同的报表形式。

#### 先进控制技术

DCS在控制上的最大特点是依靠各种控制、运算模块的灵活组态，可实现多样化的控制策略以满足不同情况下的需要，使得在单元组合仪表实现起来相当繁琐与复杂的命题变得简单。随着企业提出的高柔性、高效益的要求，以经典控制理论为基础的控制方案已经不能适应，以多变量预测控制为代表的先进控制策略的提出和成功应用之后，先进过程控制受到了过程工业界的普遍关注。需要强调的是，广泛应用各种先进控制与优化技术是挖掘并提升DCS综合性能最有效、最直接、也是最具价值的发展方向。
在实际过程控制系统中，基于PID控制技术的系统占80%以上，PID回路运用优劣在实现装置平稳、高效、优质运行中起到举足轻重的作用，各DCS厂商都以此作为抢占市场的有力竞争砝码，开发出各自的PID自整定软件。另外，根据DCS的控制功能，在基本的PID算法基础上，可以开发各种改进算法，以满足实际工业控制现场的各种需要，诸如带死区的PID控制、积分分离的PID控制、微分先行的PID控制、不完全微分的PID控制、具有逻辑选择功能的PID控制等等。
与传统的PID控制不同，基于非参数模型的预测控制算法是通过预测模型预估系统的未来输出的状态，采用滚动优化策略计算当前控制器的输出。根据实施方案的不同，有各种算法，例如，内模控制、模型算法控制、动态矩阵控制等。目前，实用预测控制算法已引入DCS，例如IDCOM控制算法软件包已广泛应用于加氢裂化、催化裂化、常压蒸馏、石脑油催化重整等实际工业过程。此外，还有霍尼韦尔公司的HPC，横河公司的PREDICTROL，山武霍尼韦尔公司在TDC-3000LCN系统中开发的基于卡尔曼滤波器的预测控制器等等。这类预测控制器不是单纯把卡尔曼滤波器置于以往预测控制之前进行噪声滤波，而是把卡尔曼滤波器作为最优状态推测器，同时进行最优状态推测和噪声滤波。
PID回路显示控制器
PID回路显示控制器
先进控制算法还有很多。目前，国内、外许多控制软件公司和DCS厂商都在竞相开发先进控制和优化控制的工程软件包，希望在组态软件中嵌入先进控制和优化控制策略。
DCS在控制上的最大特点是依靠各种控制、运算模块的灵活组态，可实现多样化的控制策略以满足不同情况下的需要，使得在单元组合仪表实现起来相当繁琐与复杂的命题变得简单。随着企业提出的高柔性、高效益的要求，以经典控制理论为基础的控制方案已经不能适应，以多变量预测控制为代表的先进控制策略的提出和成功应用之后，先进过程控制受到了过程工业界的普遍关注。需要强调的是，广泛应用各种先进控制与优化技术是挖掘并提升DCS综合性能最有效、最直接、也是最具价值的发展方向。

> PID控制

就是说先由控制器将收集到的数据与一个参考值进行比较，然后把这个差别用于计算新的输入值，这个新的输入值的目的是可以让系统的数据达到或者保持在一定的数值状态。和其他简单的控制运算不同，PID控制器可以根据历史数据和差别的出现率来调整输入值，这样可以使系统更加准确，更加稳定。
可以通过数学的方法证明，在其他控制方法导致系统有稳定误差或过程反复的情况下，一个PID反馈回路却可以保持系统的稳定。

在实际过程控制系统中，基于PID控制技术的系统占80%以上，PID回路运用优劣在实现装置平稳、高效、优质运行中起到举足轻重的作用，各DCS厂商都以此作为抢占市场的有力竞争砝码，开发出各自的PID自整定软件。另外，根据DCS的控制功能，在基本的PID算法基础上，可以开发各种改进算法，以满足实际工业控制现场的各种需要，诸如带死区的PID控制、积分分离的PID控制、微分先行的PID控制、不完全微分的PID控制、具有逻辑选择功能的PID控制等等。

> PID回路

就是说先由控制器将收集到的数据与一个参考值进行比较，然后把这个差别用于计算新的输入值，这个新的输入值的目的是可以让系统的数据达到或者保持在一定的数值状态。和其他简单的控制运算不同，PID控制器可以根据历史数据和差别的出现率来调整输入值，这样可以使系统更加准确，更加稳定。
可以通过数学的方法证明，在其他控制方法导致系统有稳定误差或过程反复的情况下，一个PID反馈回路却可以保持系统的稳定。

在实际过程控制系统中，基于PID控制技术的系统占80%以上，PID回路运用优劣在实现装置平稳、高效、优质运行中起到举足轻重的作用，各DCS厂商都以此作为抢占市场的有力竞争砝码，开发出各自的PID自整定软件。另外，根据DCS的控制功能，在基本的PID算法基础上，可以开发各种改进算法，以满足实际工业控制现场的各种需要，诸如带死区的PID控制、积分分离的PID控制、微分先行的PID控制、不完全微分的PID控制、具有逻辑选择功能的PID控制等等。

> 开环控制系统（open-loop control system）

开环控制系统（open-loop control system）是指被控对象的输出（被控制量 PID调节器）对控制器(controller)的输出没有影响。在这种控制系统中，不依赖将被控量反送回来以形成任何闭环回路。 

> 闭环控制系统（closed-loop control system）

闭环控制系统（closed-loop control system）的特点是系统被控对象的输出（被控制量）会反送回来影响控制器的输出，形成一个或多个闭环。闭环控制系统有正反馈和负反馈，若反馈信号与系 统给定值信号相反，则称为负反馈（Negative Feedback），若极性相同，则称为正反馈，一般闭环控制系统均采用负反馈，又称负反馈控制系统。闭环控制系统的例子很多。比如人就是一个具有负反馈的闭环控制系统，眼睛便是传感器，充当反馈，人体系统能通过不断的修正最后作出各种正确的动作。如果没有眼睛，就没有了反馈回路，也就成了一个开环控制系 统。另例，当一台真正的全自动洗衣机具有能连续检查衣物是否洗净，并在洗净之后能自动切断电源，它就是一个闭环控制系统。 

> PID控制

经典控制理论在实际控制系统中的典型应用就是PID控制器。在早期的控制系统中，PID控制也是唯一的自动控制方式。伴随着计算机技术的发展，现代控制理论在实用性方面获得了很大进展，解决了许多经典控制理论不能解决的问题。这一现象使很多人认为，新的理论和技术可以取代PID控制。但后来的发展说明，PID控制并没有让位。PID控制仍然是在工业控制中应用得最为广泛的一种控制方法。其原因是：（1）其结构简单，鲁棒性和适应性较强；（2）其调节整定很少依赖于系统的具体模型；（3）各种高级控制在应用上还不完善；（4）大多数控制对象使用常规PID控制即可以满足实际的需要；（5）高级控制难以被企业技术人员掌握  。
但由于实际对象通常具有非线性、时变不确定性、强干扰等特性，应用常规PID控制器难以达到理想的控制效果；在生产现场，由于参数整定方法繁杂，常规PID控制器参数往往整定不良、性能欠佳。这些因素使得PID控制在复杂系统和高性能要求系统中的应用受到了限制  。
控制原理编辑 语音
图1 PID控制系统原理框图
图1 PID控制系统原理框图
常规PID控制系统原理如图1所示，这是一个典型的单位负反馈控制系统。系统由PID控制器和被控对象组成。

> 非参数模型的预测控制算法

与传统的PID控制不同，基于非参数模型的预测控制算法是通过预测模型预估系统的未来输出的状态，采用滚动优化策略计算当前控制器的输出。根据实施方案的不同，有各种算法，例如，内模控制、模型算法控制、动态矩阵控制等。目前，实用预测控制算法已引入DCS，例如IDCOM控制算法软件包已广泛应用于加氢裂化、催化裂化、常压蒸馏、石脑油催化重整等实际工业过程。此外，还有霍尼韦尔公司的HPC，横河公司的PREDICTROL，山武霍尼韦尔公司在TDC-3000LCN系统中开发的基于卡尔曼滤波器的预测控制器等等。这类预测控制器不是单纯把卡尔曼滤波器置于以往预测控制之前进行噪声滤波，而是把卡尔曼滤波器作为最优状态推测器，同时进行最优状态推测和噪声滤波。

> 非参数模型的预测控制算法

与传统的PID控制不同，基于非参数模型的预测控制算法是通过预测模型预估系统的未来输出的状态，采用滚动优化策略计算当前控制器的输出。根据实施方案的不同，有各种算法，例如，内模控制、模型算法控制、动态矩阵控制等。目前，实用预测控制算法已引入DCS，例如IDCOM控制算法软件包已广泛应用于加氢裂化、催化裂化、常压蒸馏、石脑油催化重整等实际工业过程。此外，还有霍尼韦尔公司的HPC，横河公司的PREDICTROL，山武霍尼韦尔公司在TDC-3000LCN系统中开发的基于卡尔曼滤波器的预测控制器等等。这类预测控制器不是单纯把卡尔曼滤波器置于以往预测控制之前进行噪声滤波，而是把卡尔曼滤波器作为最优状态推测器，同时进行最优状态推测和噪声滤波。

> 其他

先进控制算法还有很多。目前，国内、外许多控制软件公司和DCS厂商都在竞相开发先进控制和优化控制的工程软件包，希望在组态软件中嵌入先进控制和优化控制策略。

### SCADA

SCADA(Supervisory Control And Data Acquisition)系统，即数据采集与监视控制系统。SCADA系统是以计算机为基础的DCS与电力自动化监控系统；它应用领域很广，可以应用于电力、冶金、石油、化工、燃气、铁路等领域的数据采集与监视控制以及过程控制等诸多领域。
在电力系统中，SCADA系统应用最为广泛，技术发展也最为成熟。它在远动系统中占重要地位,可以对现场的运行设备进行监视和控制，以实现数据采集、设备控制、测量、参数调节以及各类信号报警等各项功能,即我们所知的"四遥"功能.RTU(远程终端单元),FTU(馈线终端单元)是它的重要组成部分．在现今的变电站综合自动化建设中起了相当重要的作用．
SCADA(Supervisory Control And Data Acquisition)系统，即数据采集与监视控制系统，涉及到组态软件、数据传输链路（如：数传电台、GPRS等）

> 硬件

通常SCADA系统分为两个层面，即客户/服务器体系结构。服务器与硬件设备通信，进行数据处理和运算。而客户用于人机交互，如用文字、动画显示现场的状态，并可以对现场的开关、阀门进行操作。还有一种“超远程客户”，它可以通过Web发布在Internet上进行监控。硬件设备(如PLC)一般既可以通过点到点方式连接，也可以以总线方式连接到服务器上。点到点连接一般通过串口(RS232)，总线方式可以是RS485，以太网等连接方式。

> 软件

SCADA由很多任务组成，每个任务完成特定的功能。位于一个或多个机器上的服务器负责数据采集，数据处理（如量程转换、滤波、报警检查、计算、事件记录、历史存储、执行用户脚本等）。服务器间可以相互通讯。有些系统将服务器进一步单独划分成若干专门服务器，如报警服务器，记录服务器，历史服务器，登录服务器等。各服务器逻辑上作为统一整体，但物理上可能放置在不同的机器上。分类划分的好处是可以将多个服务器的各种数据统一管理、分工协作，缺点是效率低，局部故障可能影响整个系统  。

> 通信

SCADA系统中的通信分为内部通信、与I/O设备通信、和外界通信。客户与服务器间以及服务器与服务器间一般有三种通信形式，请求式，订阅式与广播式。设备驱动程序与I/O设备通讯一般采用请求式，大多数设备都支持这种通讯方式，当然也有的设备支持主动发送方式。SCADA通过多种方式与外界通信。如OPC，一般都会提供OPC客户端，用来与设备厂家提供的OPC服务器进行通讯。因为OPC有微软内定的标准，所以OPC客户端无需修改就可以与各家提供的OPC服务器进行通讯。

> 系统构成

SCADA系统主要有以下部分组成：监控计算机、远程终端单元（RTU）、可编程逻辑控制器（PLC）、通信基础设施、人机界面（HMI）。
使用SCADA概念可以构建大型和小型系统。这些系统的范围可以从几十到几千个控制回路，具体取决于应用。示例流程包括工业，基础设施和基于设施的流程，如下所述：
工业过程包括制造，过程控制，发电，制造和精炼，并可以连续，间歇，重复或离散模式运行。
基础设施过程可以是公共的或私人的，包括水处理和分配，污水收集和处理，油气管道，电力输送和配电以及风力发电场。
设施流程，包括建筑物，机场，船舶和空间站。他们监视和控制暖气，通风和空调系统（HVAC），通道和能源消耗。
但是，SCADA系统可能存在安全漏洞，因此应对系统进行评估，以识别风险和解决方案，以减轻这些风险。

> > 监控计算机

远程终端单元，也称为（RTU），连接到过程中的传感器和执行器，并与监控计算机系统联网。 RTU是“智能I / O”，并且通常具有嵌入式控制功能，例如梯形逻辑，以实现布尔逻辑操作。

> > 可编程逻辑控制器

也称为PLC，它们连接到过程中的传感器和执行器，并以与RTU相同的方式联网到监控系统。 与RTU相比，PLC具有更复杂的嵌入式控制功能，并且采用一种或多种IEC 61131-3编程语言进行编程。 PLC经常被用来代替RTU作为现场设备，因为它们更经济，多功能，灵活和可配置。

> > 通信基础设施

这将监控计算机系统连接到远程终端单元（RTU）和PLC，并且可以使用行业标准或制造商专有协议。 RTU和PLC都使用监控系统提供的最后一个命令，在过程的近实时控制下自主运行。 通信网络的故障并不一定会停止工厂的过程控制，而且在恢复通信时，操作员可以继续进行监视和控制。 一些关键系统将具有双冗余数据高速公路，通常通过不同的路线进行连接。

> > 人机界面

人机界面（HMI）是监控系统的操作员窗口。它以模拟图的形式向操作人员提供工厂信息，模拟图是控制工厂的示意图，以及报警和事件记录页面。 HMI连接到SCADA监控计算机，提供实时数据以驱动模拟图，警报显示和趋势图。在许多安装中，HMI是操作员的图形用户界面，收集来自外部设备的所有数据，创建报告，执行报警，发送通知等。
模拟图由用来表示过程元素的线图和示意符号组成，或者可以由工艺设备的数字照片覆盖动画符号组成。
工厂的监督操作是通过HMI进行的，操作员使用鼠标指针，键盘和触摸屏发出命令。例如，泵的符号可以向操作员显示泵正在运行，并且流量计符号可以显示通过管道泵送了多少流体。操作员可以通过鼠标点击或屏幕触摸从模拟器切换泵。 HMI将显示管道中流体的流量实时减少。
SCADA系统的HMI包通常包含一个绘图程序，操作员或系统维护人员用来改变这些点在接口中的表示方式。这些表示可以像在屏幕上的交通灯一样简单，其代表现场中实际交通灯的状态，或者像代表摩天大楼中所有电梯的位置的多投影仪显示器一样复杂，或者全部火车上的火车。
“历史记录”是HMI中的一项软件服务，它在数据库中存储带时间戳的数据，事件和报警，可以查询或用于填充HMI中的图形趋势。历史学家是从数据采集服务器请求数据的客户端  。

### OPC软总线

> > （OLE For Process Control）

OPC是一项应用于自动化行业及其他行业的数据安全交换可互操作性标准。它独立于平台，并确保来自多个厂商的设备之间信息的无缝传输，OPC基金会负责该标准的开发和维护。
OPC标准是由行业供应商、终端用户和软件开发者共同制定的一系列规范。这些规范定义了客户端与服务器之间以及服务器与服务器之间的接口，比如访问实时数据、监控报警和事件、访问历史数据和其他应用程序等，都需要OPC标准的协调。
OPC标准于1996年首次发布，其目的是把PLC特定的协议（如Modbus，Profibus等）抽象成为标准化的接口，作为“中间人”的角色把通用的OPC“读写”请求转换成具体的设备协议来与HMI/SCADA系统直接对接，反之亦然。就此出现了一个完整的产品行业，终端用户可以借助其来最优化产品，通过OPC协议来实现系统的无缝交互。
最初，OPC标准仅限于Windows操作系统。因此，OPC是OLE for Process Control的缩写（中文意思：用于过程控制的OLE）。我们所熟知的OPC规范一般是指OPC Classic，被广泛应用于各个行业，包括制造业，楼宇自动化，石油和天然气，可再生能源和公用事业等领域。

OPC（OLE for Process Control）的出现，建立了一套符合工业控制要求的通信接口规范，使控制软件可以高效、稳定地对硬件设备进行数据存取操作，应用软件之间也可以灵活地进行信息交互，极大提高了控制系统的互操作性和适应性
从软件的角度来说，OPC可以看成是一个“软件总线”的标准。首先，它提供了不同应用程序间（甚至可以是通过网络连接起来的不同工作站上的应用程序之间）实现实时数据传输的通道标准；其次，它还针对过程控制的需要定义了在通道中进行传输和交换的格式。OPC标准的体系结构为客户/服务器模式，即将软件分为OPC服务器和OPC 客户。OPC服务器提供必要的OPC数据访问标准接口；OPC客户通过该标准接口来访问OPC数据。
运用OPC标准开发的软件由于都基于共同的数据及接口标准，因此相互之间具有很强的通用性。这在工业控制领域中，具有十分现实的意义。OPC服务器可由不同供应商提供，其代码决定了服务器访问物理设备的方式、数据处理等细节。但这些对OPC客户程序来说都是透明的，只需要遵循相同的规范或方法就能读取服务器中的数据。同样，软件供应商则只需将自己的软件加上OPC接口，即能从OPC服务器中取得数据，而不需关心底层的细节。通过OPC接口，OPC客户程序可以和一个或多个不同的OPC服务器连接。同时一个OPC服务器也可以与多个客户程序相连，形成多对多的关系。任何支持OPC的产品都可以实现与系统的无缝集成。由于OPC技术基于DCOM，所以客户程序和服务器可以分布在不同的主机上，形成网络化的监控系统。
OPC技术的发展和应用，无论供应商还是最终用户都可以从中得到巨大的益处。首先，OPC技术把硬件和应用软件有效地分离开，硬件厂商只需要提供一套软件组件，所有OPC客户程序都可以使用这些组件，无需重复开发驱动程序。一旦硬件升级，只需修改OPC服务器端I/O接口部分，无需改动客户端程序。其次，工控软件只要开发一套OPC接口就可采用统一的方式对不同硬件厂商的设备进行存取操作。这样，软硬件厂商可以专注于各自的核心部分，而不是兼容问题。
对于最终用户而言，由于无需担心互操作性，在选择和更换软硬件时有了更多的余地，使异构计算机系统集成将变得很简单。用户可以将重点放在整个系统的功能及应用上，这也意味着成本的降低。此外，OPC组件的使用也十分方便，用户只需进行简单的组态即可。
OPC服务器在底层控制系统中采用统一的标准，实现了应用程序与现场设备的有效连接，发挥着重要的桥梁作用，同时也促进了企业现场控制层和生产过程管理层、经营决策层的集成。 

> OPC UA(Open Platform Communications – Unified Architecture)

为了应对标准化和跨平台的趋势，为了更好的推广OPC，OPC基金会近些年在之前OPC成功应用的基础上推出了一个新的OPC标准-OPC UA。OPC UA接口协议包含了之前的 A&E, DA,OPC XML DA or HDA，只使用一个地址空间就能访问之前所有的对象，而且不受WINDOWS平台限制，因为它是从传输层Scoket以上来定义的，这点后面会提到，导致了灵活性和安全性比之前的OPC都提升了。

> OPC服务器所兼容的设备分类

> 硬件设备：DCS，PLC，扫描仪，电子设备…

> 应用软件：HMI，历史数据库，震动检测器…

> 通讯协议：DDE，Modbus，ODBC，GenCS…

> 操作系统：Windows，UNIX，VMS，Macintosh，嵌入式OS

> 常用的OPC服务器

> > Matrikon公司的OPCServer Simulator

> > > 简单，单文件注册后，各种数据类型，各种点类型（只读点，只写点，读写点）都有了，

> > > 更好的一点是，如果想做大规模的测试，10万点，那么只需要在它的Random下添加任意名称即可，OPCServer会自动给你建出对应的测点，还是随机数变化。

> > > 配置时的几个关键概念

> > > Alias Group(Group) ——对Items的分类管理，自定义的。类似于Java中的包。

> > > Alias (Item) ——一个Item代表与服务器进行通信的PLC或其它硬件设备上的一个地址。与Kepware中的一样。

> > > 配置顺序如下（在Alias Configuration下）：New AliasGroup/Alias --> Inset Alias

> > Kepware公司的OPCServer

> > > 一个商业软件，需要花费金钱购买License的，但Kepware公司的OPCServer需要花钱的不是OPCServer本身，而是采集驱动。

> > > 不过Kepware公司的OPCServer提供了不花钱的仿真驱动，用来测试上非常好的。

> > > 缺点就是太庞大，不简单，学习成本较高。但为了能满足OPC这类产品的各种测试，它真的是最佳选择。可以去它的官方网站下载。

> > > 配置时的几个关键概念

> > > Chanel——通道是一个从PC到一个或多个外部设备之间的传播媒介。一个通道可以用来代表一个串行端口（一个安装在个人电脑上的卡或是以太网接口）。

> > > Device——设备代表了与服务器进行通信的PLC或其他硬件。它受限于Channel所选择的设备驱动程序（Device driver）。

> > > Group——对tags的分类管理，自定义的。类似于Java中的包。

> > > Tag——一个Tag代表与服务器进行通信的PLC或其它硬件设备上的一个地址。服务器允许动态标签（客户端自定义创建）和用户定义的静态标签（服务端管理人员创建的标签）。动态标签是直接进入了OPC客户端和指定设备存取数据。静态标签在服务器被创建的且支持标签扩展，他们可以从OPC客户浏览,支持标签浏览。

> > > 配置顺序如下：New Channel -->New Device --> New Group/Tag --> New Tag

##### 

#### 常用的OPC客户端

> Matrikon公司的OPCClient

> > 标准，稳定，单文件，通讯过程的信息还比较丰富，我是比较喜欢用它在创建OPC组时定义同步方式或异步方式来验证远程计算机的OPC配置是否正确。缺点就是大了点，2M多。

> > Kepware公司的OPCClient

功能很强大，标准，稳定，日志信息很丰富，最推荐的功能是支持对OPCServer中点名的条件过滤，支持点表的导入导出，支持自动导入OPCServer的所有点，根据点表识别好点坏点，按照列排序，用它可以弥补很多国产组态软件不能在线遍历OPCServer点表的功能、不能过滤OPCServer点的功能、不能识别OPCServer中好点坏点的功能等。缺点就是非单文件。 

#### OPC UA开源库

> open62541 C/C++

> > License：Mozilla Public License v2.0

> UA-.NETStandard C#

> > License：对于OPCFoundation成员使用RCL，对于个人使用GPL-2.0

> python-opcua Python （Python2和Python3都支持）

> > License：LGPL-3.0

> opcua-asyncio Python （Python3.6+）

> > 这个库和python-opcua同出一脉，API接口和python-opcua也基本一致，只是使用python的asyncio进行了重写，可使程序异步运行，提高效率，这也是符合发展趋势，

> > License：LGPL-3.0

> node-opcua JavaScript / TypeScript

> > 基于JavaScript和NodeJS实现的OPC UA协议栈，跨平台是必然的，100%异步

> > License：MIT

> milo Java

> > License：EPL-2.0

##### Openscada

###### ConnectionInformation

> Host——本地主机/网络主机IP （示例：localhost（默认）、127.0.0.1）

> Domain——域（默认为localhost）

> User——用户名

> Password——用户登录密码

> Clsid——应用在注册表中相对应的CLSID值

> Grogid——应用在注册表中对应的程序名称

#### OPC对象

> 服务器（OPC Server）

> 组（OPC Group）

> 项（OPC Item）。

### PLC编程语言标准IEC61131-3

> 指令表（Instruction List Diagram，ILD）

> 阶梯图（Ladder Diagram，LD）

> 功能区块图（Function Block Diagram，FBD）

> 结构化文字（Structured Text Language，STL）

> 顺序功能流程图（Sequential Function Chart，SFC）

## 西门子博图

### PLC编程

#### 设备组态

> 1.电源模块（PS），供电专用

> 2.CPU模块（CPU），负责处理信息

> 3.通信模块（IM）

> 4.数字量输入模块（DI）

> 5.数字量输出模块（DO）

> 6.模拟量输入模块（AI）

> 7.模拟量输出模块（AO）

#### 在线和诊断

#### 程序块

##### 组织块

> Program cycle

> Startup

> Time delay interrupt

> Cyclic interrupt

> Hardware interrupt

> Time error interrupt

> Diagnostic error interrupt

##### 函数块

##### 函数

##### 数据库

#### 程序语言

##### LAD

##### FBD

##### SCL

#### 工艺对象

##### 运动控制

###### 轴（运动控制相关与PLCG关联）

####### TO_Axis_PTO

####### 实例

   * 组态

   * 调试

   * 诊断

###### 轴控制

####### TO_CommandTable_PTO

##### PID

###### PID_Compact

###### PID_3Step

##### SIMATIC Ident

###### TO_Ident

###### TP_TagLayout

##### SINAMICS

###### TO_BasicPos

#### PLC变量

#### 数据类型

#### 监控与强制表

##### 监控表

###### 可以定义多个表

##### 强制表

###### 只有一份

#### 设备代理数据

##### 程序块

##### 工艺对象

##### PLC变量

##### PLC监控和报警

#### 西门子S7Comm协议

> > S7Comm（S7 Communication）是西门子专有的协议，是西门子S7通讯协议簇里的一种。

> > S7协议的TCP/IP实现依赖于面向块的ISO传输服务。S7协议被封装在TPKT和ISO-COTP协议中，这使得PDU（协议数据单元）能够通过TCP传送。

> > 它用于PLC编程，在PLC之间交换数据，从SCADA（监控和数据采集）系统访问PLC数据以及诊断目的。

> > S7Comm以太网协议基于OSI模型：


> 7 Application Layer -S7 communication

> > 第7层，S7 communication，这一层和用户数据相关，对PLC数据的读取报文在这里完成。


> 6 Presentation Layer -S7 communication (COTP)

> > 第6层COTP，按照维基百科的解释，COTP 是 OSI 7层协议定义的位于TCP之上的协议。COTP 以“Packet”为基本单位来传输数据，这样接收方会得到与发送方具有相同边界的数据；在具体的报文中COTP的作用是定义了数据传输的基本单位。


> 5 Session Layer	S7- communication (TPKT)


> > 第5层TPKT，应用程数据传输协议，介于TCP和COTP协议之间。这是一个传输服务协议，主要用来在COTP和TCP之间建立桥梁；TPKT的作用是包含用户协议（5~7层）的数据长度（字节数）；


> 4 Transport Layer- ISO-on-TCP (RFC 1006)

> > 第1-4层会由计算机自己完成（底层驱动程序）

> 3 Network Layer -IP

> 2 Data Link Layer -Ethernet

> 1 Physical Layer -Ethernet

### HMI编程

#### 设备组态

#### 在线和诊断

#### 运行系统配置

#### 画面

#### 画面管理

##### 画面模板

##### 全局画面

#### HMI变量

#### 连接

#### HMI报警

#### 配方

#### 记录

#### 计划任务

#### 文本和图形列表

#### 用户管理

### 伺服

#### 设备组态

#### 在线和诊断

#### 参数

#### 调试

#### 验收测试

#### Traces

### 博途(V16)

> 1、TIA Portal Multiuser Engineering

> > TIA允许多个用户同时工作在同一个项目上，增加协作的能力，另外还可以通过委托减少工作时间。

> 2、TIA Portal Teamcenter Gateway

> > Teamcenter网关让您保存和管理TIA Portal项目在Teamcenter。

> 3、TIA Portal Cloud Connector

> > 允许客户通过工业私有云的形式，借助RDP协议接入远程PC的TIA管理器并可以连接现场硬件。

> 4、TIA User Management Component

> > TIA的用户管理组件(UMC)在TIA Portal V15提供全球用户管理的可选项。可以跨项目定义和管理用户和用户组。用户和用户组也可以从微软活动目录中获取。

> 5、TIA Portal Openness

> > S7-1500标准PLC程序自动加载，在这种情况下，PLC的启动停止是隐形的，可以通过用户权限来控制。

> > SINAMICS G120 and SINAMICS S120 drives可以被V15版本的驱动组件来创建。

> > 系统UDT可以被用户数据类型访问。

> > SCL可以用XML来表示，意味着V15版本的LAD/FBD和SCL都相互导入导出为XML。

> 6、SIMATIC S7-PLCSIM Advanced

> > 可以支持备份和恢复软硬件的配置。

> > 支持RDREC/WRREC功能块和 alarms。

> > 用co-simulation工具同步OB功能块的模拟。

> > 在TIA中配置过程报警可以支持API输出。

> > 允许PLCSIM和PLCSIM Adv安装在同一台PC。

> 7、SIMATIC Visualization Architect

> > TIA V15完美支持虚拟化架构，可以与SiVarc结合在一起。

> 8、SIMATIC OPC UA S7-1500

> > OPC UA S7-1500选项允许任何第三方设备轻松连接到S7-1500通过集成在S7-1500 CPU的OPC UA服务器。

## MBSE

> “MBSE”是“基于模型的系统工程”的英文“Model-Based Systems Engineering”的首字母缩写。从字面意思能看出MBSE这个概念有三个核心的概念“系统”、“系统工程”、“基于模型”。

> “基于模型的系统工程”（MBSE）：“支持以概念设计阶段开始，并持续贯穿于开发和后期的生命周期阶段的系统需求、设计、分析、验证和确认活动的正规化建模应用。”用通俗一点语言解释的话，MBSE就是开发一个产品、平台的时候，把产品、平台研发中涉及到的各个方面用“计算机数据模型”方式建立起来，形成一个统一的“系统模型”。

### “系统”（System）

> “系统”（System）：系统是相互作用的多个部分组成的为完成特定目的的一个整体。从这个基本概念看，这个世界上很多东西都可以称为“系统”。但是工程技术人员的研究领域中，这个“系统”主要是指软、硬件组成的产品、平台等。这个“系统”也包括其中的流程、人员、信息、技术和设施等。至于纯“人”的社会系统则不是这个技术研究的范围。

#### SysML

> SysML，全称Systems Modeling Language，即系统建模语言，它是一种表述（Specifying）、分析、设计以及验证复杂系统的通用图形化建模语言，复杂系统可能包括软件、硬件、信息、人员、过程和设备等其他系统元素。

> SysML是一种图形化的系统建模语言。

#### SysML与UML的关系

> UML，即“Unified Modeling Language”，又称为统一建模语言，是一种图形化的建模语言，主要用于对软件系统进行建模。同时，用户可以利用UML提供的扩展机制对UML进行扩展，以满足特定领域的建模需求。

> 系统工程比软件领域覆盖范围更广，除了可能包含的软件组件，可能还包括硬件、人员、设施、过程等更多的系统元素。系统工程师基于UML进行建模工作，并不能很好的描述系统。也就是说在系统工程领域，UML存在“盲点”，基于当前已有的UML元素不足以对复杂系统进行充分的、有效的表达。因此，系统工程领域在寻求一种更为广泛的建模语言。

> “UML for Systems Engineering RFP”有OMG和INCOSE联合开发，并由OMG于2003年3月发布。该RFP文档中描述了扩展UML以支持系统工程的需求。SysML规范正是为了满足这些需求，由不同的工具供应商、终端用户、学术界及政府代表联合开发制定，2006年7月6日被OMG采纳，并于2007年发布了OMG SysML V1.0版。

> SysML和UML间存在交集，即SysML语言中的部分图是和UML中的相应图是一致的，例如用例图。同时，SysML也有基于UML扩展而来的图，例如活动图。另外，还有一部分图是SysML所特有的，这些图与UML间没有关系，例如需求图。

> SysML建模语言中的图模型如下图所示，可以概括为“3类9种”。SysML可以分为行为图、需求图和结构图。三类图又具体化为共计9种模型图。同时，SysML模型图与UML图存在交互。SysML和UML共有的图，包括序列图、用例图、状态机图、包图，SysML基于UML扩展而来的图，包括活动图、模块定义图、内部模块图。SysML语言所特有的图，包括需求图和参数图。

##### 用例图

> 一种黑盒视图，是系统功能的高层描述，用于表达系统执行的用例以及引起系统执行行为的参与者。

##### 模块定义图

> 一种结构图，与内部模块图及参数图互补，用于描述系统的层次以及系统/组件的分类。

##### 内部模块图

> 一种结构图，与模块定义图及参数图互补，通过组件（Parts）、端口、连接器来用于描述系统模块的内部结构。

##### 包图

> 一种结构图，以包的形式组织模型间的层级关系。

##### 参数图

> SysML特有的图，与模块定义图及参数图互补，用于说明系统的约束。

##### 活动图

> 一种行为图，主要关注控制流程，以及输入转化为输出的过程。

##### 序列图

> 一种行为图，主要关注并精确描述系统内部不同模块间的交互，

##### 状态机图

> 一种行为图，主要关注系统内部模块的一系列状态以及在事件触发下的不同状态间的转换。

##### 需求图

> 用于表述文字化的需求、需求间的关系，以及与之存在满足、验证等关系的其他模型元素。

> > SysML还包含了分配关系的表述，包括功能到组件的分配、软件到硬件的分配以及逻辑到物理的分配

#### SysML的通用图形化表述

> SysML的通用图形表述如下图所示，每个SysML图都有图外框、头部以及内容区域三部分组成。图外框是指图的外部黑色实线，在SysML中外框不能省略。内容区域是存放SysML模型元素的地方。头部位于图的左上角，对模型图的类型、名称、模型元素类型及名称进行概要性描述。

> 图的头部是最为重要的图概念，一般包括四个信息：图类型、模型元素类型、模型元素名称、图名称。

> > 图的类型

> > > 图类型的命名只能在SysML定义的图类型缩写集合中选择，用户不能随意命名。SysML中定义的图类型的缩写集合简称如下所示：

> > 模型元素类型

> > > SysML定义了模型元素类型集合，这些类型的模型元素在图中是不能任意出现的，每种SysML图中所能表达的模型元素是有规则限制的，参考如下的模型图和模型元素匹配表。关于元素类型所表达的含义在后续系列文章中详细说明。

> > 模型元素名称

> > > 用户自定义模型元素的名称

> > 图名称

> > > 用户自定义图的名称

#### SysML建模工具

> 我们说，SysML是一种图形化的建模语言，OMG组织发布了针对SysML的建模语言描述规范，其详细定义的SysML的语义。支持SysML的建模工具有很多，如Rhapsody，这是一款来自IBM Rational 的商业化工具。

#### 总结

> SysML是一种图形化建模语言，用于对复杂系统进行建模；

> SysML基于UML 2，并对其进行了扩展；

> SysML不是建模的方法论，也不是建模工具；

### “系统工程”（SE，Systems Engineering）

> “系统工程”（SE，Systems Engineering）：系统工程是一种使系统能够成功实现的跨学科的方法和手段。“系统工程”工作包括：在“系统”开发周期的早期阶段定义客户需求及功能，并文档化。然后进行设计综合和系统确认。同时考虑整个系统各方面的问题，包括系统运行、成本、进度、性能、培训、支持、试验、制造和销毁等。这里的“系统工程”简单说指的是产品研发过程的技术方法。

### MBSE有什么用？

> （1）改善了开发系统的利益相关者（客户、项目管理人员、系统工程师、软硬件工程师、测试人员和各专业工程学科的人员）之间的沟通。

> > 因为MBSE是基于标准的建模语言建立的规范化说明，相当于大家交流的语言是统一的。而基于自然语言的“文档”容易在不同专业的人员之间产生歧义。而且MBSE的这个“模型化说明”在各类专业人员之间传递时候是可以通过计算机软件转换为各自专业的语言、数据，而自然语言是很难实现这个转换的。但是，这要求大家要新学习一门通用的“系统建模语言”。如果大家都不懂这门语言的话，只会产生和上面的观点相反的结果。

> （2）通过使系统模型能够被从多个侧面进行观察，以及提供变更影响分析的能力， 提高了管理复杂系统的能力。

> > 这个是说系统的同一套数据模型，可以从不同的专业角度进行浏览和分析。而且由于系统模型数据之间有相互关联关系，如果那个地方更改，可以通过关系查询到所有影响到的地方。这个对于非结构化的文档来说，是做不到，或者很麻烦。即使文档也能提供从各个专业角度的说明，但是这些文档数据之间没有关联，可以说是基于各自多套数据来源的，而不是唯一的一套数据模型。这个观点也是在说“MBSE提高了开发复杂系统的能力”。

> （3）通过提供可评估一致性、正确性和完善性的无歧义的且精确的系统模型，提升了产品质量。

> > 产品的质量问题有很多是设计问题，而这些设计问题并不简简单单是设计人员的水平问题、责任心问题，而更多是复杂过程本身不可避免的会出现的质量问题。想让所有人不犯错是不可能的，而只能是通过技术手段使人少犯错。MBSE是一种使人少犯错的技术手段，因为MBSE建立的模型可以通过计算机软件自动的检查错误。相比之下传统的文档容易隐藏错误，一个笔误可能造成严重损失。

> （4）通过以更加标准化的方式捕获信息并高效地利用模型驱动方法固有的内置抽象机制，增强知识捕获及信息的复用。这会导致缩短开发周期和更低的维护成本，以改进设计。

> > 这个观点是说系统模型数据更容易复用，比文档手段的“复制、粘贴、替换”文本效率要高。模型数据的复用，可以采取“引用”方式。而且可以建立共用的模型库，提高知识的复用率。

> （5）通过提供概念清晰且无歧义的表达，提升教授与学习系统工程基本原理的能力。学会了MBSE，就掌握了系统工程的方法。



### 建模

> 我们一生中都已经见到，使用或创建了模型，从代表汽车或飞机的玩具到描述和解释物理现象（例如热力学或重力）的数学公式。尽管这些模型本质上有所不同，但这些模型都将思想与现实联系起来，并为该目的提供了足够的抽象。在对系统进行建模时，系统工程师会决定生产系统中最重要的方面，例如结构，能量或物质流，内部通信或安全性。这些方面将成为模型的焦点。建建模活动的最高目标是对模型所关注的突出方面进行建模，尽可能接近真实系统。

#### 建模使用四种工具：

> 语言

> > 建模语言是一种通用术语，用于清晰地传达模型所捕获的抽象概念。建模语言可以是正式的，具有严格的语法和规则。现有的系统建模语言有几种，包括通用语言，例如系统建模语言（SysML）和统一建模语言（UML），以及专用语言，例如体系结构分析设计语言（AADL）。虽然SysML和UML不是数学形式的，但是有效的模型需要遵循实体和关系的建模语言的规则。SysML对于元素之间的关系和连接具有严格的语法和规则，这有助于避免歧义。如果模型构建良好，则可以动态模拟几种类型的标准SysML图，并且至少可以对一种SysML图进行数学模拟。UML是半正式的；SysML与UML类似，但更为正式。

> 结构体

> > 模型必须具有结构，一个结构良好的模型可以使模型可以理解、可用和可维护，这对于复杂系统来说尤为重要。模型的目的是向利益相关者展示所提出的设计满足系统的需求。模型应该以一种易于理解的方式演示如何构建系统才能成功。可视化是保证理解性的关键途径，将抽象的想法形象化，可以使人们获得“看到”系统所需的想象力的飞跃。

> 论证

> 演示

#### 建模领域

> 即使MBSE并没有规定任何特定的过程，但基本上任何选择的过程都应涵盖四个系统工程领域：

> 需求/能力

> 行为

> 架构/结构

> 验证与确认

> > Defense Acquisition University（DAU），NASA和Avi Sharma等人对这些领域的描述进行了详细记录和讨论。MBSE的不同之处在于，这些基本的系统工程领域不是作为一组文档定义的，而是在模型本身中定义的，即使用建模语言以正式的方式定义。该模型代表了有关如何设计系统才能使其成功的争论。

> > MBSE还促进了利益相关者，系统工程师和开发人员之间的沟通。由于系统设计是在集成建模环境中执行的，因此所有系统工程师，管理人员和其他利益相关者都可以在需要时尽快访问生成的信息，例如需求，行为流和体系结构。

> > 最常见的建模活动是创建表示系统某些部分的图-视图。这种活动非常常见，以至于有些工程师错误地将创建视图等同于创建模型。这种错误非常普遍，甚至有一个新兴的术语：僵尸模型。这个术语指的是一个模型，它充满了图表，但是元素之间没有相互联系和依赖关系。

> > 任何即将开始建模的人都必须意识到，一组视图不是模型。尽管一个视图甚至一组视图可以代表系统设计的一部分，并且对于记录和传达系统的某些方面很有用，但视图只是真实系统模型的各个方面或部分。真实的模型可以产生许多视图和矩阵，执行分析和运行仿真。

#### 系统建模语言

> > 虽然像SysML这样的系统建模语言是一种正式的语法语言，但它仍然基于人类语言的元素。MBSE语言的术语仅映射到词性：

> > > 名词：参与者，角色，组件，需求

> > > 动词：操作活动，功能，用例

> > > 形容词：属性

> > > 副词：关系，需求线，交换，接口

#### MBSE模型的四个象限

> 现在，我已经描述了模型语言和领域的基础知识，我将描述建模方法。模型必须描述设计的系统要解决的问题和设计的系统本身（解决方案）。模型必须具有这两个方面，即问题方面和解决方案方面。这些有时称为操作和系统角度。

> 操作的观点是用户，操作员和业务人员的观点。它应该代表业务流程，目标，组织结构，用例和信息流。模型的操作端可以包含“世界现状”和未来状态的描述。

> 系统的观点是解决方案，系统的体系结构解决了在模型的操作端提出的问题，描述了系统的行为、结构、组件之间的数据流以及功能的分配，描述了系统将如何在现实世界中部署。它可以包含解决方案的选择和分析。

> 这些观点中的每一个都有逻辑和物理两个部分。分离模型的逻辑和物理方面是管理系统复杂性的一种方法。模型的逻辑部分通常不会随时间变化，而物理变化通常是由技术进步引发的。

> 如果模型构建正确，则所有四个象限都应紧密连接，如下图1所示。问题的陈述应该追溯到解决方案的元素，以及分配给物理结构的逻辑元素。模型的用户应该能够清楚地看到高层概念和组件如何分解为较低层的功能。用户应该能够执行系统分析，创建依赖关系矩阵，运行模拟并为每个利益相关者提供系统视图。如果系统的物理部分必须更改，则模型的逻辑端将准确确定将影响哪些功能。如果必须更改需求或业务流程，则该模型将轻松发现对解决方案的影响。

### 方法

> OOSEM方法

> > OOSEM是一种自顶向下、场景驱动建模过程，它使用SysML（系统建模语言，Systems Modeling Language）语言作为建模语言，支持系统的分析、定义、设计、和验证。该过程使用面向对象的概念和其它建模方法来构建灵活和可扩展的系统，使其能够适应技术的不断进化和需求的变更。

> > OOSEM过程的主要活动包括：

> > > （1） 分析利益相关者的需求。这个工作简单说就是分析使用产品的用户的需求，就是用户最初始的想法是啥，想怎么用这个产品、需要产品有那些功能。了解用户当前情况是什么、有什么局限，未来可以有哪些提升。

> > > （2） 分析系统需求。简单说就是产品本身应该提供那些功能，用户是如何使用产品的。在这个过程中要推导出产品的功能需求、接口需求、数据需求和性能需求。

> > > （3） 定义逻辑架构。先将系统分解为多个逻辑组件，这些逻辑组件是暂且虚拟的一个部件，它能够满足产品的各项需求。但是具体用什么硬件或软件的方案来实现它，在下一步的物理架构设计中实现。将系统方案分为逻辑架构和物理架构两个层级，有利于减少需求和技术变化对设计的影响。

> > > （4） 综合候选的物理架构。可能建立几个和逻辑元素相对应的物理架构，以进行对比分析，确定哪一个最合适。物理架构的元素是具体产品部件，包括软件和硬件。前面逻辑架构中的功能，有些是可以用软件来实现，也可以用硬件来实现，或者用不同型号规格的硬件来实现。

> > > （5） 优化并评价备选方案。对上述备选的物理架构方案进行优选，利用模型的数据，进行性能、可靠性、生命周期成本、人员和其它专业工程相关的模型参数的分析，对备选方案进行优化，确定一个最终的方案。

> > > （6） 管理需求的可追踪性。为保证需求、架构、设计、分析与验证元素之间的可追踪性，系统模型应该始终保持需求和其它元素的关系。设计过程就是一个不断填补空白需求的实现过程。当需求变动时，利用建立的需求实现关系，追踪和评估需求变更对系统设计、分析和验证元素的影响，并及时更改系统方案，使其和需求保持一致。

> > > （7） 确认和验证系统。该活动验证系统设计满足其需求，并确认哪些需求满足利益相关者的需求。开发验证计划、程序和方法。

> Harmony-SE

> > Harmony-SE本来是开发嵌入式软件的系统工程方法，逐渐成为通用的MBSE方法。这个方法的详细说明，可以参考《基于模型的系统工程最佳实践》这本书，是经典的Harmony-SE方法论说明。这里简单给出这种方法的流程图如下：

> 3.3 MagicGrid方法

> > MagicGid方法将MBSE过程各阶段工作流程放在一个表格中，这个表格典型内容如下图所示：

> > 在这个表格中，采取从左到右、从上到下的顺序逐步开展MBSE的工作。通过建立各阶段的模型之间的关系，可以统计需求覆盖情况，以及追踪模型变动的影响。有关此方法的详细说明，笔者将会在“智睿思维MBSE"公众号发布一篇详细的介绍文章，敬请关注。此方法已在"智睿思维MBSES"1.5版本中的实现，可以试用。

## MES

### 智能制造四大阶段

> 标准化

> > 标准化是智能制造的前提，如果没有标准化，企业的生产就会陷入无秩序、无效率的恶性循环，这样的企业迟早被行业淘汰。

> > 标准化的基础是对业务流程进行量化，每个环节的数据都可以采集，然后通过数据分析，发现生产中存在的问题、分析问题、解决问题，标准化为行业自动化奠定了基础。

> 自动化

> > 自动化，这里单指生产制造自动化。智能制造真正的成型，是对人类生活、工作、娱乐、消费整个的自动化体系的建成。因此，我们在讨论智能制造的自动化阶段的时候，特指生产过程的自动化。

> > 生产制造自动化又分为单机自动化、单线生产自动化、工厂自动化。在完成标准化和数字化的过程后，一些单一的、重复的工作流程就可以用机器来代替，比如上下料自动化、装配自动化等。之后，将整条流水线分散的自动化设备用一定的程序连接起来，控制好节拍，便完成了单线生产自动化；工厂的全生产流程都可以通过自动化协调起来，组成工厂自动化。

> 信息化

> > 信息化和互联化具有必然的因果关系，没有互联化就没有信息化，想要实现信息化就要先进行互联化，互联化是实现信息化的基础。

> > 互联化是手段，信息化是目标，智能制造的每个阶段，都是要实现特定的目标。比如通过精益生产实现标准化，通过系统集成实现自动化，通过互联网技术实现信息化，通过大数据、云平台、人工智能实现智能化。因此，我们不必要强调信息化之前的手段--互联化。

> 智能化

> > 智能化就是更高一级的自动化，从人类体力劳动上升到脑力劳动的自动化。这一切实现的基础就是通过互联网实现全面信息化后，产生海量大数据，然后通过云计算等手段，模拟人类行动过程，将其应用到产业中去。

> > 智能化是一个漫长的过程，从现在的基础条件看，只能在部分领域实现智能化，难以从整个层面进行智能化改造。智能制造可以拆分为智能感知、智能检测、智能管理等业务模块。

> > 智能化的发展也有一些限制，比如感知、数据采集、标准化等方面不够完善所出现的问题。特别是传感器发展水平是制约智能制造发展的主要因素，其反应在传感器的类型、微型化、集成化、价格四个方面，而传感器的微型化和集成化也可归纳到传感器的种类这个因素里面，简化成企业应用层次的传感器种类仍然太少及传感器价格过高两个因素。

> > 传感器的短板，难以保障生产现场的精细化，缺乏细节参数，在机器在分析、判断的过程中很难实施找到问题发生真实原因的智能化，机器不能掌握原因，那么智能化也难以落地。

### 系统目标

> 整合可用资源：联接企业的计划层和操作层，整合信息孤岛

> 优化生产流程：通过项目实施来梳理、优化现行生产业务流程

> 完善管理手段：将制造过程中的生产计划、进度安排、物料流动、物料跟踪、过程控制、过程监视、质量管理、设备维护等活动全面集成起来，有机协调这些活动的执行，使制造过程朝着高效方向发展；

> 掌握生产现状：让生产现场透明化；

> 提供评价依据：收集、整理生产过程中的各类数据，为管理人员提供评价依据；

> 指出改进方向：提供科学、灵活的分析评价工具，以指出改进生产过程的方向

#### 管理目标

> 生产执行系统项目实施，是实现生产过程中的组织、管理和决策的最优化，最终达到企业整体水平的最优化，使从计划、生产、调度、资源分配等管理更加科学、准确。

> 实现生产过程的快速反应与敏捷、精确制造，最终与业务系统、生产自动化系统集成，实现全厂供应链的快速反应。

> 实现工厂自动化连续化均衡生产。

> 实现生产过程中的产品生产交货期的准确预估，最终与业务系统、生产自动化系统集成，实现对客户的产品交货期的准确预估。

> 实现产品质量以及生产过程的可追溯性。

> 实现生产过程产量、消耗、质量、设备状况、产品跟踪和技术性分析等的全面动态可视和可控。

> 实现生产过程中的实时事务处理功能以及统计分析功能。

> 建立预警指标，提供预警功能（包括设备、质量、物流等）；提供调度方案供调度人员决策

#### 技术目标

> 清晰划分企业运营管理与企业生产执行作业两个不同层次的功能模块，二者相互独立而又有机集成。

> 紧密集成原本独立的系统，消除信息孤岛，保证数据的一致性，提高数据的可复用性，实现各职能部门之间的数据共享与流通

#### 应用目标

> MES系统重点关注生产管理、设备维护、质量管理和物料库存管理等四个层面的业务活动，下面分别从这几方面来阐述其应用目标：

> 生产实时指挥调度

> > 以全厂数据采集为基础，建立一个集成统一的生产指挥调度平台，有机集成卷包、制丝、动能、物流等相对独立的生产环节，提高各系统各部门间协调指挥的能力，使生产过程数字化、透明化；

> > 建立预警指标，提供预警功能（包括设备、质量、物流等），提高异常事件的快速处理能力；

> > 运用先进的高级排产算法进行生产优化排产，实现精益化生产，体现生产过程的快速反应与敏捷制造的能力，保障生产的连续性、可控性；

> > 有效支撑"敏捷制造、按单生产"的生产管理模式。实现生产过程中的产品交货期的准确预估；快速响应和处理紧急插单，以满足不断变化的市场需求。

> 全程设备管理

> > 强化和规范设备基础管理，按照ISO9000的要求，实现设备基础管理（点检、保养、维修、润滑、计量等）的程序化、电算化；

> > 通过设备的安全运行情况和故障隐患维护情况，不断完善设备维保项目和周期，逐步建立一套良好的设备预防维修机制，进行有针对性的计划维修，提高设备的保障能力；

> > 通过对员工工作记录的统计分析，加强对人的行为的管理，提高工作质量，提高员工管理考评的科学性、客观性；

> > 规范故障维修管理，逐步建立一套能指导设备维修的维修经验支持系统，加快故障抢修的速度，减少维修时间，提高维保技能；

> > 通过对各种设备数据的分析研究，发现影响设备效率的关键因素，并针对具体原因找出提高设备效率的途径，不断提高设备的生产效率。

> 全面质量管理

> > 通过对标准的参数化、程序化，建立一套完整的生产过程质量标准体系，为生产过程严格执行质量标准和工艺标准提供保障；

> > 建立一套全面的生产过程质量检验检测管理体系，迅速监测和分析半成品、成品的质量问题，加快质量异常事件的处理速度；

> > 运用SPC等工具加强在线质量控制，使质量管理模式由事后考核逐步过渡到预防为主、实时控制的模式；

> > 提供质量问题的分析工具，为改进工艺、改进质量的研究活动提供有效手段和信息，为正确制订质量标准和工艺要求提供依据与工具，实现产品质量的持续改进。

> 全程生产追踪

> > 以批次为单位，通过对原料、辅料、制造工艺参数、成本、质量、设备运行、能源消耗及人员等生产过程各种资源信息的动态记录，建立对应到最终产品与构成要素之间的双向视图，实现产品质量、物料、人员等信息的可回溯性。

> 全面信息集成

> > 通过MES系统的实施，实现烟厂各信息化系统、各自动化系统之间的全面信息集成，彻底消除制造各环节间的信息孤岛，实现计划层、执行层及控制层之间无缝的衔接。

> 生产数据管理

> > 在与各自动化系统信息集成的基础上建立生产数据中心，实现各种生产管理数据的汇总统计、报表打印等功能，实现生产管理数字化、电算化，提高生产管理效率；

> > 为领导决策提供全面准确的数据依据

### MES定义

> MESA International(生产执行系统国际协会) 将MES定义为："处理传递信息，使得从定单到成品这一系列生产活动得以优化的系统。生产过程中，MES通过使用当前正确的实时数据，对这些生产活动进行管理，给予响应，并提供报告。对于变化的条件做出迅速反应，并致力于减少无增值生产活动，这一切都推动着有效的生产操作和工艺加工。"

### 业务模型

> 以设备为基础

> 以计划为导向

> 撑控生产过程

> 敏捷指挥调度

> 强化质量控制

> 制造成本透明

> 提升管控能力

> 管理效益增值

#### MES部分模块介绍

> 资源分配和状态管理（Resource Allocation and Status）

> > 这个模块管理机床、工具、人员、物料、其它设备以及其它生产实体（例如进行加工必须准备的工艺文件、数控加工程序等文档资料），用以保证生产的正常进行。它还要提供资源使用情况的历史记录，确保设备能够正确安装和运转，同时提供资源的实时状态信息。对这些资源的管理，还包括为满足生产计划的要求对其所作的预定和调度。

> 工序详细调度（Operations/Detail Scheduling）

> > 这种调度，是基于有限能力的调度并通过考虑生产中的交错、重叠和并行操作来准确计算出设备上下料和调整时间。

> > 在编制生产作业计划中，该模块提供与指定生产单元相关的优先级（Priorities）、属性（Attributes）、特征（Characteristics）以及处方（Recipes，此为可选项）的作业排序功能。其目标是通过良好的作业顺序最大限度减少生产过程中的准备时间。

> 生产单元分配（Dispatching Production Units）

> > 这一模块以作业、订单、批量、成批和工作单等形式管理生产单元间的工作流。当车间有事件发生时，要提供一定顺序的调度信息并按此进行相关的实时操作。生产单元分配模块，能够调整车间已制订的生产进度，对返修品和废品进行处理，用缓冲管理的方法控制任意位置的在制品数量。

> 文档控制（Document Control）

> > 此模块控制、管理并传递与生产单元有关的信息文档，包括工作指令、配方、工程图纸、标准工艺规程、零件的数控加工程序、批量加工记录、工程更改通知以及各种转换操作间的通讯记录，并提供了信息编辑功能。

> > 文档控制模块将各种指令下达给操作层，包括向操作者提供操作数据或向设备控制层提供生产配方。此外，它还包括对其它重要数据(例如与环境、健康和安全制度有关的数据以及ISO信息)的控制与完整性维护。当然，还有存储历史数据功能。

> 数据采集（Data Collection/Acquisition）

> > 该功能通过数据采集接口来获取并更新与生产管理功能相关的各种数据和参数，包括产品跟踪、维护产品历史记录以及其它参数。这些现场数据，可以从车间手工方式录入或由各种自动方式获取。数据采集的时间间隔差别很大，有时可达到分钟一级的精度。

> 过程管理（Process Management）

> > 该模块监控生产过程、自动纠正生产中的错误并向用户提供决策支持以提高生产效率。这些活动，可能是针对一些比较底层的操作，它们主要集中在被监视和被控制的机器上，需要连续跟踪生产操作流程。

> > 过程管理模块还应包括报警功能，使车间人员能够及时察觉到出现了超出允许误差的加工过程。通过数据采集接口，过程管理可以实现智能设备与制造执行系统之间的数据交换。

### MES的边界定义

> 根据ISA-95标准，MES重点关注以下四类业务：

> > 生产作业管理

> > 维护作业管理

> > 质量作业管理

> > 库存作业管理

> MES系统功能划分和边界定义应遵循以下原则：

> > 安全性原则：在系统设计上考虑整体的安全措施，使用业界技术成熟的产品，采用安全可靠的系统架构，利用完善的安全策略保证信息的安全可靠。

> > 先进性原则：选用业界领先和主流的成熟可靠的技术路线和产品，既要着眼于目前系统的需求，还要面向未来的发展。

> > 可靠性原则：系统每天都处理着大量的业务数据，任何时刻的系统设备故障都有可能给用户带来损失，这要求系统具备很高的稳定性和可靠性，以及很高的平均无故障率。保证故障发生时系统能够提供有效的失效转移或者快速恢复等性能。硬件环境应消除单点故障，实现双机容错和负载均衡功能。保证系统的高可用性，即7×24小时不停机的工作模式。

> > 实用性及可扩展性原则：系统的建设既要充分体现系统业务的特点，也要具有可扩展性以适应公司管理水平的提升；充分利用现有资源，合理配置系统软硬件，保护用户投资；又要着眼建成后实际的使用与未来技术发展方向，系统应对企业组织架构和业务流程的变动具备低敏感性和优秀的支持性能，企业组织机构或业务流程发生变动时，系统如需变更，应变手段应简单易行。在下面的条件发生变化时，系统可以平滑升级，达到好的可扩展性。

> > 可维护性、界面及易用性原则：流程管理和表单定义要求简单、明确，操作简便；人员组织和角色管理要求管理简单、明确；权限管理要求对应用模块、查看、记录、操作等各级权限管理简单、明确；用户操作界面要求友好透明。

> > 可建设性原则：投标人需要提供适应本项目信息系统的硬件和网络建设方案，既要考虑达到本项目信息系统运行最优化要求，又要考虑到建设资金和建设周期的合理性。

> > 系统集成性：系统设计应与现有的信息化系统及外部系统有良好的集成

### 企业信息化层次模型