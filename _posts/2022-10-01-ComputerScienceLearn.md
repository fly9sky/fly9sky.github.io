---
layout: post
title:  计算机科学技术编程等相关学习内容总结
description: 计算机科学相关学习内容总结,包括各种操作系统安装配置，各种编程语言学习等
date: 2022-10-01 09:01:01
---

- [计算机史话](#计算机史话)
- [Windows](#windows)
- [LinuxAndOpenSource](#linuxandopensource)
  - [Linux 命令大全](#linux-命令大全)
    - [系统信息](#系统信息)
    - [文件搜索](#文件搜索)
    - [挂载一个文件系统](#挂载一个文件系统)
    - [磁盘空间](#磁盘空间)
    - [用户和群组](#用户和群组)
    - [打包和压缩文件](#打包和压缩文件)
    - [RPM 包](#rpm-包)
    - [YUM 软件包升级器](#yum-软件包升级器)
    - [DEB 包](#deb-包)
    - [查看文件内容](#查看文件内容)
    - [文本处理](#文本处理)
    - [字符设置和文件格式转换](#字符设置和文件格式转换)
    - [文件系统分析](#文件系统分析)
    - [初始化一个文件系统](#初始化一个文件系统)
    - [SWAP文件系统](#swap文件系统)
    - [备份](#备份)
    - [光盘](#光盘)
    - [网络 - （以太网和WIFI无线）](#网络---以太网和wifi无线)
  - [OpenSource主流开源协议](#opensource主流开源协议)
    - [GPL](#gpl)
    - [LGPL](#lgpl)
    - [BSD](#bsd)
    - [Apache](#apache)
    - [MIT(MITL)](#mitmitl)
    - [Mozilla(MPL)](#mozillampl)
  - [Git in linux](#git-in-linux)
    - [GithubCli](#githubcli)
    - [Login](#login)
    - [Git helper](#git-helper)
- [Docker](#docker)
  - [Docker 安装 \& 配置镜像加速器](#docker-安装--配置镜像加速器)
  - [container容器](#container容器)
    - [共享数据](#共享数据)
      - [DataVolume](#datavolume)
  - [镜像](#镜像)
  - [DockFile](#dockfile)
  - [daemon D](#daemond)
  - [Docker Server ](#docker-server)
    - [Job](#job)
  - [client](#client)
  - [Swarm](#swarm)
  - [Machine](#machine)
  - [Compose](#compose)
  - [LXC](#lxc)
    - [NameSpace](#namespace)
  - [repository](#repository)
    - [DockerHub](#dockerhub)
    - [私有仓库](#私有仓库)
  - [优点](#优点)
    - [快速，一致地交付您的应用程序](#快速一致地交付您的应用程序)
    - [响应式部署和扩展](#响应式部署和扩展)
    - [在同一硬件上运行更多工作负载](#在同一硬件上运行更多工作负载)
  - [Dockerfile 详解](#dockerfile-详解)
    - [Docker 命令详解](#docker-命令详解)
  - [Docker-compose](#docker-compose)
    - [一，Docker-compose简介](#一docker-compose简介)
    - [二，Docker-compose常用命令](#二docker-compose常用命令)
    - [三，Docker-compose模板文件](#三docker-compose模板文件)
  - [Dpcler-Kubernetes](#dpcler-kubernetes)
    - [kubernetes 概述](#kubernetes-概述)
    - [核心概念](#核心概念)
    - [kubernetes 集群搭建(kubeadm 方式)](#kubernetes-集群搭建kubeadm-方式)
    - [安装方法二](#安装方法二)
    - [kubernetes 集群搭建（二进制）](#kubernetes-集群搭建二进制)
    - [kubernetes 集群 YAML 文件详解](#kubernetes-集群-yaml-文件详解)
- [结构化程序设计](#结构化程序设计)
- [面向对象程序设计](#面向对象程序设计)
  - [面向对象设计原则](#面向对象设计原则)
    - [1、单一职责原则 SRP](#1单一职责原则-srp)
    - [2、开闭原则 OCP](#2开闭原则-ocp)
    - [3、里氏代换原则 LSP](#3里氏代换原则-lsp)
    - [4、依赖倒转原则 DIP](#4依赖倒转原则-dip)
    - [5、接口隔离原则 ISP](#5接口隔离原则-isp)
    - [6、合成复用原则 CRP](#6合成复用原则-crp)
    - [7、迪米特法则（最少知道原则）DP](#7迪米特法则最少知道原则dp)
- [Gof设计模式](#gof设计模式)
  - [行为型](#行为型)
    - [Iterator（迭代器模式）](#iterator迭代器模式)
    - [Interpreter（解析器模式）](#interpreter解析器模式)
    - [Observer（观察者模式）](#observer观察者模式)
    - [Mediator（中介者模式）](#mediator中介者模式)
    - [Visitor（访问者模式）](#visitor访问者模式)
    - [Memento（备忘录模式）](#memento备忘录模式)
    - [State（状态模式）](#state状态模式)
    - [Strategy（策略模式）](#strategy策略模式)
    - [Template Method（模板方法模式）](#template-method模板方法模式)
    - [Command（命令模式）](#command命令模式)
    - [Chain of Responsibility（职责链模式）](#chain-of-responsibility职责链模式)
  - [创建型](#创建型)
    - [Singleton（单例模式）](#singleton单例模式)
    - [Prototype（原型模式）](#prototype原型模式)
    - [Builder（建造者模式）](#builder建造者模式)
    - [Factory Method(工厂模式)](#factory-method工厂模式)
    - [ Abstract Factory（抽象工厂模式）](#abstract-factory抽象工厂模式)
  - [结构型](#结构型)
    - [Bridge（桥接模式）](#bridge桥接模式)
    - [Facade（外观模式）](#facade外观模式)
    - [Composite(组合模式)](#composite组合模式)
    - [Decorator(装饰模式)：](#decorator装饰模式)
    - [Adapter（适配器模式）](#adapter适配器模式)
    - [Proxy（代理模式）](#proxy代理模式)
    - [Flyweight（享元模式）](#flyweight享元模式)
  - [模式之间关系](#模式之间关系)
  - [其他](#其他)
  - [参考资料](#参考资料)
    - [23种设计模式UML图](#23种设计模式uml图)
- [C# .Net Base](#c-net-base)
  - [CLR基础 CLR的执行模型](#clr基础-clr的执行模型)
  - [生成、打包、部署和管理应用程序及类型](#生成打包部署和管理应用程序及类型)
  - [共享程序集和强命名程序集](#共享程序集和强命名程序集)
  - [类型基础](#类型基础)
  - [基元类型、引用类型和值类型](#基元类型引用类型和值类型)
  - [常量和字段](#常量和字段)
  - [方法](#方法)
  - [参数](#参数)
  - [属性](#属性)
  - [事件](#事件)
  - [泛型](#泛型)
  - [接口](#接口)
  - [基本类型](#基本类型)
  - [字符、字符串和文本处理](#字符字符串和文本处理)
  - [枚举类型和位标志](#枚举类型和位标志)
  - [数组](#数组)
  - [委托](#委托)
  - [定制特性](#定制特性)
  - [可空值类型](#可空值类型)
  - [异常和状态管理](#异常和状态管理)
  - [托管堆和垃圾回收](#托管堆和垃圾回收)
  - [CLR寄宿和AppDomain](#clr寄宿和appdomain)
  - [程序集加载和反射](#程序集加载和反射)
  - [运行时序列化](#运行时序列化)
  - [与WinRT组件互操作](#与winrt组件互操作)
  - [线程基础](#线程基础)
  - [计算的异步操作 Task](#计算的异步操作-task)
  - [I/O的异步操作](#io的异步操作)
  - [基元线程同步构造](#基元线程同步构造)
  - [混合线程同步构造](#混合线程同步构造)
  - [ML.NET](#mlnet)
- [WPF](#wpf)
  - [WPF控件继承](#wpf控件继承)
    - [UIElement](#uielement)
      - [方法: METHODS](#方法-methods)
      - [Events](#events)
      - [属性:](#属性-1)
      - [FiFileds:FIELDS:](#fifiledsfields)
    - [Visual](#visual)
      - [方法:METHODS](#方法methods)
      - [属性:](#属性-2)
      - [方法: METHODS](#方法-methods-1)
    - [DependencyObject](#dependencyobject)
      - [方法:METHODS](#方法methods-1)
      - [属性:PROPERTIES](#属性properties)
    - [DispatcherObject](#dispatcherobject)
      - [属性:](#属性-3)
      - [方法:](#方法-1)
    - [System.Object](#systemobject)
    - [FrameworkElement](#frameworkelement)
      - [Page](#page)
      - [Control](#control)
      - [Image](#image)
      - [Panel](#panel)
      - [属性:](#属性-4)
      - [Fielsds:](#fielsds)
  - [属性](#属性-5)
    - [普通属性](#普通属性)
    - [附加属性](#附加属性)
    - [依赖项属性dependency property](#依赖项属性dependency-property)
    - [WPF 设计器集成](#wpf-设计器集成)
  - [事件](#事件-1)
    - [普通事件](#普通事件)
      - [生命周期事件](#生命周期事件)
      - [鼠标事件](#鼠标事件)
      - [键盘事件](#键盘事件)
      - [手写笔事件](#手写笔事件)
      - [多点触控事件](#多点触控事件)
    - [路由事件](#路由事件)
    - [附加事件](#附加事件)
    - [VisualStateManager](#visualstatemanager)
  - [资源](#资源)
    - [样式](#样式)
    - [触发器](#触发器)
    - [模板](#模板)
    - [使用资源的优势：](#使用资源的优势)
    - [资源的范围（层级）：](#资源的范围层级)
  - [WPF 体系结构](#wpf-体系结构)
    - [milcore](#milcore)
    - [WindowsCodes.dll](#windowscodesdll)
    - [Direct3D是图形渲染](#direct3d是图形渲染)
    - [User32](#user32)
  - [CopyPaste(WPF)](#copypastewpf)
    - [ICopyAble](#icopyable)
    - [IPasteAble](#ipasteable)
    - [CopyPasteProxy](#copypasteproxy)
    - [CopyPasteData](#copypastedata)
  - [Behavior](#behavior)
  - [Command](#command)
    - [命令(Command)](#命令command)
    - [命令源(Command Source)](#命令源command-source)
    - [命令目标(Command Target)](#命令目标command-target)
    - [命令关联(Command Binding)](#命令关联command-binding)
  - [MVVM](#mvvm)
    - [Model](#model)
    - [View](#view)
    - [ViewModel](#viewmodel)
  - [Application類](#application類)
    - [应用程序事件](#应用程序事件)
  - [Prism](#prism)
    - [Prism框架 如何在主程序中合理的弹出子窗体](#prism框架-如何在主程序中合理的弹出子窗体)
    - [Prism框架中一些非常重要的概念](#prism框架中一些非常重要的概念)
      - [Modules](#modules)
      - [Module Catalog：](#module-catalog)
      - [Shell](#shell)
      - [Views：](#views)
      - [View Model和Presenters](#view-model和presenters)
        - [Model](#model-1)
        - [Commands](#commands)
        - [Regions：](#regions)
      - [Navigation](#navigation)
      - [EventAggregator](#eventaggregator)
      - [Dependency Injection container](#dependency-injection-container)
      - [Services：](#services)
      - [Controllers](#controllers)
      - [Bootstrapper：](#bootstrapper)
    - [Prism 简介#](#prism-简介)
    - [Prism.Core、Prism.Wpf 和 Prism.Unity#](#prismcoreprismwpf-和-prismunity)
    - [Prism.Core#](#prismcore)
    - [BindableBase 和 ErrorsContainer#](#bindablebase-和-errorscontainer)
    - [Commanding](#commanding)
    - [Event Aggregator](#event-aggregator)
    - [Productivity Tools](#productivity-tools)
    - [Prism.Wpf 和 Prism.Unity](#prismwpf-和-prismunity)
    - [PrismApplication#](#prismapplication)
    - [RegisterTypes](#registertypes)
    - [XAML ContainerProvider#](#xaml-containerprovider)
    - [ViewModelLocator](#viewmodellocator)
    - [Dialog Service](#dialog-service)
  - [拖拽](#拖拽)
  - [WPF的类层次结构](#wpf的类层次结构)
  - [XAML](#xaml)
      - [VisualTreeHelper](#visualtreehelper)
      - [LogicalTreeHelper](#logicaltreehelper)
        - [BringIntoView(DependencyObject)](#bringintoviewdependencyobject)
        - [FindLogicalNode(DependencyObject, String)](#findlogicalnodedependencyobject-string)
        - [GetChildren(DependencyObject)](#getchildrendependencyobject)
        - [GetChildren(FrameworkContentElement)](#getchildrenframeworkcontentelement)
        - [GetChildren(FrameworkElement)](#getchildrenframeworkelement)
        - [GetParent(DependencyObject)](#getparentdependencyobject)
    - [合并XAMLS命名空间](#合并xamls命名空间)
      - [注意看程序集的信息，里面有一堆这样的代码：](#注意看程序集的信息里面有一堆这样的代码)
  - [资源](#资源-1)
    - [样式](#样式-1)
    - [模板](#模板-1)
  - [布局](#布局)
      - [控制位置](#控制位置)
        - [1. Alignment](#1-alignment)
        - [2. Content Alignment](#2-content-alignment)
        - [3. FlowDirection](#3-flowdirection)
      - [Panel（面板）](#panel面板)
        - [1. 常用面板](#1-常用面板)
        - [2. TabPanel](#2-tabpanel)
        - [3. ToolBarOverflowPanel](#3-toolbaroverflowpanel)
        - [4. ToolBarTray](#4-toolbartray)
        - [5. UniformGrid](#5-uniformgrid)
        - [6. VirtualizingStackPanel](#6-virtualizingstackpanel)
  - [元素绑定](#元素绑定)
    - [绑定表达式](#绑定表达式)
    - [绑定错误](#绑定错误)
    - [绑定模式](#绑定模式)
    - [代码创建绑定](#代码创建绑定)
  - [第三方控件库](#第三方控件库)
    - [工具](#工具)
        - [自动化测试的协助工具](#自动化测试的协助工具)
  - [VisualStateManager](#visualstatemanager-1)
    - [VisualState](#visualstate)
    - [VisualStateGroup](#visualstategroup)
    - [VisualTransition](#visualtransition)
    - [VisualStateManager](#visualstatemanager-2)
  - [图形](#图形)
    - [基本图形](#基本图形)
    - [笔刷 Brush](#笔刷-brush)
    - [图形的效果与滤镜](#图形的效果与滤镜)
  - [变换](#变换)
    - [图形的变形](#图形的变形)
    - [Transform 抽象类](#transform-抽象类)
    - [变换（Transform）](#变换transform)
  - [动画](#动画)
    - [动画基类](#动画基类)
    - [关键帧动画 ：](#关键帧动画-)
      - [LinearDoubleKeyFrame](#lineardoublekeyframe)
      - [DiscreteDoubleKeyFrame](#discretedoublekeyframe)
      - [SplineDoubleKeyFrame](#splinedoublekeyframe)
      - [EasingDoubleKeyFrame](#easingdoublekeyframe)
    - [场景（Storyborad）](#场景storyborad)
- [HTML 5](#html-5)
- [JQuery](#jquery)
- [Angular](#angular)
- [React](#react)
- [Vue.js](#vuejs)
- [Bootstrap学习总结](#bootstrap学习总结)
  - [Bootstrap 基础](#bootstrap-基础)
    - [媒体查询（css3特性）](#媒体查询css3特性)
      - [媒体类型](#媒体类型)
      - [媒体特性](#媒体特性)
  - [Bootstrap 布局](#bootstrap-布局)
    - [包装容器](#包装容器)
    - [响应断点](#响应断点)
    - [堆叠顺序 z-index](#堆叠顺序-z-index)
    - [网格系统](#网格系统)
  - [Bootstrap 版式](#bootstrap-版式)
    - [文档案](#文档案)
    - [图片](#图片)
    - [表格](#表格)
    - [代码](#代码)
  - [Bootstrap 通用样式](#bootstrap-通用样式)
    - [文本](#文本)
    - [颜色](#颜色)
    - [边框](#边框)
    - [定位浮动](#定位浮动)
    - [代码弹性盒子](#代码弹性盒子)
    - [其它 对齐等](#其它-对齐等)
  - [Bootstrap 组件](#bootstrap-组件)
    - [按钮](#按钮)
    - [按钮组](#按钮组)
    - [下拉](#下拉)
    - [媒体对象](#媒体对象)
    - [表单](#表单)
    - [进度条](#进度条)
    - [导航栏](#导航栏)
    - [列表组](#列表组)
    - [面包屑](#面包屑)
    - [分页](#分页)
    - [加载指示器（转圈圈）](#加载指示器转圈圈)
    - [按钮卡片](#按钮卡片)
  - [Sass](#sass)
    - [变量](#变量)
    - [嵌套归斥责](#嵌套归斥责)
    - [导入](#导入)
    - [SASS 混合器 混合器继承](#sass-混合器-混合器继承)
- [Font Awesome](#font-awesome)
- [Asp.net core MVC 一些总结](#aspnet-core-mvc-一些总结)
  - [Router](#router)
    - [property router](#property-router)
    - [设置路由中间件](#设置路由中间件)
    - [多路由](#多路由)
    - [高级路由](#高级路由)
  - [Session](#session)
  - [授权认证管理](#授权认证管理)
    - [认证](#认证)
  - [DI](#di)
  - [Filters](#filters)
    - [授权过滤器 AuthorizeAttribute](#授权过滤器-authorizeattribute)
    - [资源过滤器 IResourceFilter](#资源过滤器-iresourcefilter)
    - [异常过滤器 IExceptionFilter](#异常过滤器-iexceptionfilter)
    - [操作过滤器 ActionFilterAttribute](#操作过滤器-actionfilterattribute)
    - [结果过滤器 ResultFilterAttribute](#结果过滤器-resultfilterattribute)
    - [结果过滤器 IFilterDiagnostics](#结果过滤器-ifilterdiagnostics)
    - [IAsyncResultFilter](#iasyncresultfilter)
  - [Controllers](#controllers-1)
    - [WebAPI](#webapi)
    - [Controller](#controller)
    - [Rezor View](#rezor-view)
  - [ViewComponent](#viewcomponent)
  - [Taghelper](#taghelper)
  - [SignalR](#signalr)
- [Tensorflow](#tensorflow)
- [C# 调用 Tensorflow](#c-调用-tensorflow)
- [gRPC](#grpc)
  - [gRPC 概述](#grpc-概述)
  - [gRPC 服务项目模板](#grpc-服务项目模板)
  - [ASP.NET Core gRPC 服务项目模板提供了一个入门版服务：](#aspnet-core-grpc-服务项目模板提供了一个入门版服务)
  - [使用 .NET 客户端调用 gRPC 服务](#使用-net-客户端调用-grpc-服务)
- [Php](#php)
  - [Pyplot，画出各种你想要的图](#pyplot画出各种你想要的图)
- [Python](#python)
  - [语言特点](#语言特点)
    - [跨平台](#跨平台)
      - [可远行于](#可远行于)
        - [各大操作系统](#各大操作系统)
    - [解释型脚本语言](#解释型脚本语言)
      - [内建](#内建)
        - [高级的数据结构](#高级的数据结构)
    - [面向对象的语言](#面向对象的语言)
      - [便于](#便于)
        - [数据和逻辑](#数据和逻辑)
    - [动态语言](#动态语言)
      - [变量本身](#变量本身)
        - [类型不固定](#类型不固定)
        - [可随意转换](#可随意转换)
        - [不需要声明](#不需要声明)
    - [不用考虑](#不用考虑)
      - [内存问题](#内存问题)
    - [可处理的数据量](#可处理的数据量)
      - [无限制](#无限制)
    - [默认编码](#默认编码)
      - [UTF-8](#utf-8)
  - [运行程序](#运行程序)
    - [两种模式](#两种模式)
      - [脚本式编程](#脚本式编程)
        - [一次性执行](#一次性执行)
      - [交互式编程](#交互式编程)
        - [逐行输入](#逐行输入)
    - [远行脚本](#远行脚本)
      - [命令行/终端模式](#命令行终端模式)
        - [python \*.py](#python-py)
      - [Linux下可执行脚本](#linux下可执行脚本)
        - [首行添加](#首行添加)
        - [赋予权限](#赋予权限)
        - [运行脚本](#运行脚本)
      - [IPython](#ipython)
        - [%run \*.py](#run-py)
  - [代码格式](#代码格式)
    - [缩进](#缩进)
      - [用【缩进深度】区分](#用缩进深度区分)
        - [语句【代码块】](#语句代码块)
    - [行长](#行长)
      - [每行不超过80字符](#每行不超过80字符)
    - [空行](#空行)
      - [将程序的不同部分分开](#将程序的不同部分分开)
    - [\\ ](#)
      - [继续上一行](#继续上一行)
      - [跨行特例](#跨行特例)
        - [闭合操作符](#闭合操作符)
        - [三引号](#三引号)
    - [;](#-1)
      - [在同一行](#在同一行)
        - [连接多个语句](#连接多个语句)
    - [:](#-2)
      - [分开代码块(组)](#分开代码块组)
        - [头\&体](#头体)
  - [变量](#变量-1)
    - [内涵](#内涵)
      - [存储了一个值](#存储了一个值)
        - [与【变量】相关联的信息](#与变量相关联的信息)
    - [命名规则](#命名规则)
      - [只能包含](#只能包含)
        - [字母、数字和下划线](#字母数字和下划线)
      - [不能](#不能)
        - [以【数字】打头](#以数字打头)
        - [包含【空格】](#包含空格)
        - [使用python保留字：用于【特殊用途】的单词](#使用python保留字用于特殊用途的单词)
      - [建议](#建议)
        - [简短又具有描述性](#简短又具有描述性)
        - [使用【小写字母】](#使用小写字母)
        - [慎用](#慎用)
  - [变量赋值](#变量赋值)
    - [赋值符](#赋值符)
      - [=](#-3)
    - [增量赋值](#增量赋值)
      - [+=](#-4)
    - [多重赋值](#多重赋值)
      - [x=y=z=1](#xyz1)
    - [多元赋值](#多元赋值)
      - [x,y,z=1,2,'a'](#xyz12a)
        - [\*var收集多余的值](#var收集多余的值)
      - [通常【元组】需要【小括号】](#通常元组需要小括号)
      - [建议](#建议-1)
        - [加上【小括号】以增加【可读性】](#加上小括号以增加可读性)
        - [(x,y,z)=(1,2,'a')](#xyz12a-1)
    - [变量交换](#变量交换)
      - [x,y=y,x](#xyyx)
- [Java](#java)
  - [consul](#consul)
- [数据库基础](#数据库基础)
  - [锁](#锁)
    - [数据库角度](#数据库角度)
      - [\* 独占锁（Exclusive Lock）](#-独占锁exclusive-lock)
      - [共享锁（Shared Lock）](#共享锁shared-lock)
      - [更新锁（Update Lock）](#更新锁update-lock)
    - [程序员角度](#程序员角度)
      - [乐观锁（Optimistic Lock）](#乐观锁optimistic-lock)
      - [悲观锁（Pessimistic Lock）](#悲观锁pessimistic-lock)
  - [数据库中事务的 ](#数据库中事务的)
    - [ACID 原则](#acid-原则)
      - [原子性 (Atomicity)：](#原子性-atomicity)
      - [一致性 (Consistency)：](#一致性-consistency)
      - [隔离性(Isolation)：](#隔离性isolation)
      - [持久性(Durability)：](#持久性durability)
- [NoSQL：选择合适的数据库](#nosql选择合适的数据库)
  - [力什么使用NoSCL数据库？](#力什么使用noscl数据库)
    - [阻抗失衡](#阻抗失衡)
      - [关系模型和内存中的数抠结构不匹配](#关系模型和内存中的数抠结构不匹配)
      - [采用更为方便的数据交互方式提升开发效率](#采用更为方便的数据交互方式提升开发效率)
    - [待处理的致据量裉大](#待处理的致据量裉大)
      - [超过关系型数据库的承载能力](#超过关系型数据库的承载能力)
      - [大集群的出现](#大集群的出现)
        - [DBMS不是设计给集群使用的](#dbms不是设计给集群使用的)
        - [成本；许可费用](#成本许可费用)
        - [横向扩展和纵向扩展](#横向扩展和纵向扩展)
    - [对数据的访同效率要求高](#对数据的访同效率要求高)
  - [NoSQL数据库的分类](#nosql数据库的分类)
    - [键值数抿库](#键值数抿库)
      - [产品](#产品)
        - [Redis](#redis)
        - [BerkeleyDB](#berkeleydb)
        - [Memcached](#memcached)
        - [Project Voldemort](#project-voldemort)
        - [Riak](#riak)
        - [LevelDB](#leveldb)
      - [特性](#特性)
      - [适用场景](#适用场景)
        - [存放会话信息](#存放会话信息)
        - [用户配置信息](#用户配置信息)
        - [购物车数据](#购物车数据)
      - [不适合的场景](#不适合的场景)
        - [数据间有大量关系](#数据间有大量关系)
        - [含有多项操作的事务](#含有多项操作的事务)
        - [根据键值的部分来查询数据](#根据键值的部分来查询数据)
        - [操作关键字集合](#操作关键字集合)
    - [文档数据库](#文档数据库)
      - [产品](#产品-1)
        - [MongoDB](#mongodb)
        - [CouchDB](#couchdb)
        - [RavenDB](#ravendb)
        - [Terrastore](#terrastore)
        - [OrientDB](#orientdb)
      - [适用场景](#适用场景-1)
        - [事件记录](#事件记录)
        - [内容管理系统及博客平台](#内容管理系统及博客平台)
        - [网站分析及实时分析](#网站分析及实时分析)
        - [电子商务应用程序](#电子商务应用程序)
      - [不适合场景](#不适合场景)
        - [包含多项操作的复杂查询](#包含多项操作的复杂查询)
        - [查询持续变化的聚合结构](#查询持续变化的聚合结构)
    - [列族数据库](#列族数据库)
      - [产品](#产品-2)
        - [HBase](#hbase)
        - [Amazon SimpleDB](#amazon-simpledb)
        - [Cassdndra](#cassdndra)
        - [Hypertable](#hypertable)
        - [BigTable(google)](#bigtablegoogle)
      - [适用场景](#适用场景-2)
        - [事件记录](#事件记录-1)
        - [CMS及博客平台](#cms及博客平台)
        - [计数器](#计数器)
      - [不适用场景](#不适用场景)
        - [需要ACID事务](#需要acid事务)
        - [查询模式变化频繁的场合](#查询模式变化频繁的场合)
    - [图数据库](#图数据库)
      - [产品](#产品-3)
        - [FlockDB](#flockdb)
        - [HyperGraphDB](#hypergraphdb)
        - [Infinite Graph](#infinite-graph)
        - [Neo4J](#neo4j)
        - [OrientDB](#orientdb-1)
      - [适用场景](#适用场景-3)
        - [互联数据](#互联数据)
        - [推荐引擎](#推荐引擎)
        - [基手位置的服务](#基手位置的服务)
      - [不适用场景](#不适用场景-1)
        - [更新全部或某个子集的实体](#更新全部或某个子集的实体)
- [Oracle](#oracle)
  - [概述](#概述)
    - [发展史](#发展史)
    - [网格计算](#网格计算)
    - [Oracle 11g新特性](#oracle-11g新特性)
  - [数据库结构](#数据库结构)
    - [体系结构](#体系结构)
      - [实例](#实例)
      - [数据库](#数据库)
        - [数据文件](#数据文件)
        - [控制文件](#控制文件)
        - [日志文件](#日志文件)
    - [服务器结构](#服务器结构)
      - [系统全局区](#系统全局区)
        - [数据高速缓冲区](#数据高速缓冲区)
        - [重做日志缓冲区](#重做日志缓冲区)
        - [共享池](#共享池)
        - [Large Pool](#large-pool)
      - [后台进程](#后台进程)
        - [DBWn](#dbwn)
        - [LGWR](#lgwr)
        - [SMON](#smon)
        - [PMON](#pmon)
        - [ARCH](#arch)
        - [......](#-5)
      - [程序全局区](#程序全局区)
    - [数据字典](#数据字典)
      - [数据字典构成](#数据字典构成)
        - [USER\_](#user_)
        - [ALL\_](#all_)
        - [DBA\_](#dba_)
        - [V$\_](#v_)
        - [GV\_](#gv_)
      - [常用数据字典](#常用数据字典)
  - [SQL语言](#sql语言)
    - [DDL](#ddl)
      - [create](#create)
        - [常用数据类型](#常用数据类型)
        - [表](#表)
        - [主键](#主键)
        - [外键](#外键)
        - [约束](#约束)
        - [索引](#索引)
        - [视图](#视图)
        - [序列](#序列)
        - [同义词](#同义词)
      - [drop](#drop)
      - [alter](#alter)
    - [DML](#dml)
      - [insert](#insert)
        - [插入数据](#插入数据)
        - [复制表数据](#复制表数据)
      - [update](#update)
      - [merge](#merge)
      - [delete](#delete)
      - [truncate](#truncate)
    - [DQL](#dql)
      - [select](#select)
        - [from子句](#from子句)
        - [投影](#投影)
        - [where子句](#where子句)
        - [基本函数](#基本函数)
        - [集合操作](#集合操作)
        - [子查询](#子查询)
    - [DCL](#dcl)
    - [TCL](#tcl)
  - [PL/SQL](#plsql)
    - [概述](#概述-1)
    - [PL/SQL编程](#plsql编程)
      - [基本语言块](#基本语言块)
      - [字符集](#字符集)
      - [注释](#注释)
      - [数据类型](#数据类型)
      - [变量和常量](#变量和常量)
      - [表达式和运算符](#表达式和运算符)
      - [流程控制](#流程控制)
        - [if-then-elsif-then-else](#if-then-elsif-then-else)
        - [case-when-else](#case-when-else)
        - [loop-exit](#loop-exit)
        - [for-loop](#for-loop)
        - [while-loop](#while-loop)
    - [过程和函数](#过程和函数)
      - [过程](#过程)
      - [函数](#函数)
    - [错误处理](#错误处理)
      - [预定义异常](#预定义异常)
        - [DUP\_VAL\_ON\_INDEX](#dup_val_on_index)
        - [LOGIN\_DENIED](#login_denied)
        - [NO\_DATA\_FOUND](#no_data_found)
        - [TOO\_MANY\_ROWS](#too_many_rows)
        - [ZERO\_DIVIDE](#zero_divide)
        - [VALUE\_ERROR](#value_error)
        - [CASE\_NOT\_FOUND](#case_not_found)
      - [自定义异常](#自定义异常)
        - [RAISE](#raise)
      - [异常函数](#异常函数)
        - [SQLCODE](#sqlcode)
        - [QLERRM](#qlerrm)
    - [包](#包)
      - [包头](#包头)
      - [包体](#包体)
      - [重载](#重载)
    - [集合](#集合)
      - [三种类型](#三种类型)
        - [index-by表](#index-by表)
        - [嵌套表](#嵌套表)
        - [可变数组](#可变数组)
      - [属性和方法](#属性和方法)
        - [COUNT](#count)
        - [DELETE](#delete-1)
        - [EXISTS](#exists)
        - [EXTEND](#extend)
        - [FIRST/LAST](#firstlast)
        - [NEXT/PRIOR](#nextprior)
    - [游标](#游标)
      - [显示游标](#显示游标)
      - [隐式游标](#隐式游标)
      - [游标for循环](#游标for循环)
      - [游标变量](#游标变量)
  - [数据库管理](#数据库管理)
    - [管理控制文件](#管理控制文件)
    - [管理日志文件](#管理日志文件)
    - [管理表空间和数据文件](#管理表空间和数据文件)
    - [模式对象管理](#模式对象管理)
    - [表分区和索引分区](#表分区和索引分区)
    - [用户管理与安全](#用户管理与安全)
    - [数据完整性和数据约束](#数据完整性和数据约束)
  - [数据库优化](#数据库优化)
    - [系统调整](#系统调整)
    - [SQL语句优化](#sql语句优化)
      - [常用优化技巧](#常用优化技巧)
        - [不要用\*代替列名](#不要用代替列名)
        - [用truncate代替delete](#用truncate代替delete)
        - [在确保完整性的情况下多用commit语句](#在确保完整性的情况下多用commit语句)
        - [尽量减少表查询的次数](#尽量减少表查询的次数)
        - [用not exists代替in/not in](#用not-exists代替innot-in)
        - [用not exists代替distinct](#用not-exists代替distinct)
        - [有效利用共享游标](#有效利用共享游标)
        - [以合理的方式使用函数](#以合理的方式使用函数)
      - [表的连接方法](#表的连接方法)
        - [选择from表的顺序](#选择from表的顺序)
        - [选择驱动表](#选择驱动表)
        - [where子句的连接顺序](#where子句的连接顺序)
      - [有效使用索引](#有效使用索引)
        - [索引列的选择](#索引列的选择)
        - [复合索引有时比单列索引有更好的性能](#复合索引有时比单列索引有更好的性能)
        - [避免对大表的全表扫描](#避免对大表的全表扫描)
        - [监视索引是否被使用](#监视索引是否被使用)
      - [优化器](#优化器)
      - [执行计划管理](#执行计划管理)
      - [SQL重演](#sql重演)
  - [备份与恢复](#备份与恢复)
    - [RMAN(Recovery Manager)工具](#rmanrecovery-manager工具)
    - [闪回技术](#闪回技术)
      - [flashback](#flashback)
      - [show recyclebin](#show-recyclebin)
    - [数据导入/导出](#数据导入导出)
      - [导出exp](#导出exp)
      - [导入imp](#导入imp)
  - [数据库集群技术](#数据库集群技术)
    - [RAC应用](#rac应用)
    - [ASM](#asm)
    - [容灾和数据卫士](#容灾和数据卫士)
    - [故障诊断](#故障诊断)
  - [商业智能与数据仓库](#商业智能与数据仓库)
    - [多维数据库](#多维数据库)
    - [数据挖掘](#数据挖掘)
  - [数据库事务隔离级别](#数据库事务隔离级别)
    - [已提交读模式](#已提交读模式)
    - [串行模式](#串行模式)
    - [只读模式](#只读模式)
  - [](#-6)
- [SQL Server](#sql-server)
  - [DDL](#ddl-1)
  - [DML](#dml-1)
  - [存储过程](#存储过程)
  - [索引](#索引-1)
    - [聚集索引](#聚集索引)
    - [非聚集索引](#非聚集索引)
  - [数据优化](#数据优化)
  - [并发](#并发)
  - [灾难恢复](#灾难恢复)
  - [RAC](#rac)
  - [行列转换](#行列转换)
    - [行转列PIVOT](#行转列pivot)
    - [列转行UNPIVOT](#列转行unpivot)
  - [SQL 事务隔离级别:](#sql-事务隔离级别)
    - [read uncommited（读取未提交数据），](#read-uncommited读取未提交数据)
    - [read commited（读取已提交数据）读取的默认方式，](#read-commited读取已提交数据读取的默认方式)
    - [repeatable read（可重复读），](#repeatable-read可重复读)
    - [serializable（可序列化），](#serializable可序列化)
    - [snapshot（快照），](#snapshot快照)
    - [read commited snapshot（已经提交读隔离）](#read-commitedsnapshot已经提交读隔离)
    - [Sql Server 事务隔离级别的查看及更改](#sql-server-事务隔离级别的查看及更改)
- [LiteDB：本地化NOSQL](#litedb本地化nosql)
  - [特点](#特点)
  - [LiteDB使用基本案例](#litedb使用基本案例)
    - [创建实体类](#创建实体类)
    - [使用Demo](#使用demo)
  - [使用场景](#使用场景)
  - [LiteDB的技术细节](#litedb的技术细节)
    - [LiteDB的工作原理](#litedb的工作原理)
    - [LiteDB的查询](#litedb的查询)
      - [Query.All 返回所有的数据，可以使用指定的索引字段进行排序](#queryall-返回所有的数据可以使用指定的索引字段进行排序)
      - [Query.EQ 查找返回和指定字段值相等的数据](#queryeq-查找返回和指定字段值相等的数据)
      - [Query.LT/LTE 查找\< 或 \<= 某个值的数据](#queryltlte-查找-或--某个值的数据)
      - [Query.GT/GTE 查找\> 或 \>= 某个值的数据](#querygtgte-查找-或--某个值的数据)
      - [Query.Between 查找在指定区间范围内的数据](#querybetween-查找在指定区间范围内的数据)
      - [Query.In - 和SQL的in类似吧，查找和列表中值相等的数据](#queryin---和sql的in类似吧查找和列表中值相等的数据)
      - [Query.Not - 和EQ相反，是不等于某个值的数据](#querynot---和eq相反是不等于某个值的数据)
      - [Query.StartsWith 查找以某个字符串开头的数据](#querystartswith-查找以某个字符串开头的数据)
      - [Query.Contains 查找保护某个字符串的数据，这个查询只扫描索引](#querycontains-查找保护某个字符串的数据这个查询只扫描索引)
      - [Query.And 2个查询的交集](#queryand-2个查询的交集)
      - [Query.Or 2个查询结果的并集](#queryor-2个查询结果的并集)
    - [LiteDB的查询](#litedb的查询-1)
      - [LiteDB的技术细节](#litedb的技术细节-1)
  - [C## 示例](#c-示例)
    - [基本示例](#基本示例)
      - [namespace Inovance.FA.FAOutTest.Views](#namespace-inovancefafaouttestviews)
- [LabView](#labview)
  - [工程](#工程)
  - [VI](#vi)
  - [第1章LabⅥEW基础知识](#第1章labⅵew基础知识)
    - [1.1LabⅥEW简介](#11labⅵew简介)
      - [1.1.1LabⅥEW概述](#111labⅵew概述)
      - [1.1.2LabⅥEW 2018的新功能](#112labⅵew-2018的新功能)
    - [1.2LabⅥEW编程环境](#12labⅵew编程环境)
      - [1.2.1前面板](#121前面板)
      - [1.2.2程序框图](#122程序框图)
      - [1.2.3菜单栏](#123菜单栏)
      - [1.2.4工具栏](#124工具栏)
      - [1.2.5项目浏览器窗口](#125项目浏览器窗口)
    - [1.3Ⅵ管理](#13ⅵ管理)
      - [1.3.1新建Ⅵ](#131新建ⅵ)
      - [1.3.2保存Ⅵ](#132保存ⅵ)
      - [1.3.3运行Ⅵ](#133运行ⅵ)
      - [1.3.4纠正Ⅵ的错误](#134纠正ⅵ的错误)
      - [1.3.5高亮显示程序执行过程](#135高亮显示程序执行过程)
      - [1.3.6单步通过Ⅵ及其子Ⅵ](#136单步通过ⅵ及其子ⅵ)
      - [1.4LabⅥEW 2018的帮助系统](#14labⅵew-2018的帮助系统)
      - [1.4.1使用即时帮助](#141使用即时帮助)
      - [1.4.2使用目录和索引查找在线帮助](#142使用目录和索引查找在线帮助)
      - [1.4.3查找LabⅥEW范例](#143查找labⅵew范例)
      - [1.4.4使用网络资源](#144使用网络资源)
    - [Xcontrol](#xcontrol)
      - [1.什么是LabVIEW XControl](#1什么是labview-xcontrol)
        - [XControl对于用户来说，和普通的控件没有区别，但XControl对于开发者来说，除了有自定义外观外，还能自定义行为。](#xcontrol对于用户来说和普通的控件没有区别但xcontrol对于开发者来说除了有自定义外观外还能自定义行为)
      - [2.XControl的好处](#2xcontrol的好处)
        - [可以将控件的功能封装起来，使其和应用程序代码分离。同时有助于重用。](#可以将控件的功能封装起来使其和应用程序代码分离同时有助于重用)
      - [3.创建XControl](#3创建xcontrol)
        - [新建XCtrl：](#新建xctrl)
        - [Data.ctl: 指定了XCtrl的数据类型；](#datactl-指定了xctrl的数据类型)
        - [State.ctl: 指定了除数据类型之外其他影响XCtrl外观的信息，其他所有数据的定义放在此处；](#statectl-指定了除数据类型之外其他影响xctrl外观的信息其他所有数据的定义放在此处)
        - [Init.vi: 当XCtrl第一次被放置在前面板上或含有XCtrl的vi第一次被载入内存时，初始化显示状态。](#initvi-当xctrl第一次被放置在前面板上或含有xctrl的vi第一次被载入内存时初始化显示状态)
        - [新建Method，定义XCtrl支持的方法（类似于类的成员函数），用于操作State中的数据；这里实现各种具体的操作。](#新建method定义xctrl支持的方法类似于类的成员函数用于操作state中的数据这里实现各种具体的操作)
        - [新建Property，定义了XCtrl的可读取属性（类似于LabVIEW类的accessor的工作），用于读取XCtrl中的数据；](#新建property定义了xctrl的可读取属性类似于labview类的accessor的工作用于读取xctrl中的数据)
        - [修改facade vi，用于定制XControl的外观，创建各种状态改变事件。](#修改facade-vi用于定制xcontrol的外观创建各种状态改变事件)
        - [X控件的本质是为控件事先定义好一系列可以响应的事件，之后使用控件时，就可以在控件的属性或调用节点中看到这些事件，像操作普通控件一样，调用这些节点来执行特定操作。](#x控件的本质是为控件事先定义好一系列可以响应的事件之后使用控件时就可以在控件的属性或调用节点中看到这些事件像操作普通控件一样调用这些节点来执行特定操作)
        - [以LabVIEW自带的摄氏华氏温度转换XCtrl为例：](#以labview自带的摄氏华氏温度转换xctrl为例)
  - [第2章前面板设计](#第2章前面板设计)
    - [2.1前面板](#21前面板)
      - [2.1.1“工具”选板](#211工具选板)
      - [2.1.2实例——标注汽车行驶车速变化表](#212实例标注汽车行驶车速变化表)
      - [2.1.3图标/连接器](#213图标连接器)
      - [2.1.4实例——设计汽车行驶车速变化表图标](#214实例设计汽车行驶车速变化表图标)
      - [2.1.5选板可见性设置](#215选板可见性设置)
    - [2.2前面板控件](#22前面板控件)
      - [2.2.1“控件”选板](#221控件选板)
      - [2.2.2控件样式](#222控件样式)
      - [2.2.3实例——数值控件的使用](#223实例数值控件的使用)
    - [2.3对象的设置](#23对象的设置)
      - [2.3.1选择对象](#231选择对象)
      - [2.3.2删除对象](#232删除对象)
      - [2.3.3变更对象位置](#233变更对象位置)
      - [2.3.4属性节点](#234属性节点)
      - [2.3.5实例——控件显示](#235实例控件显示)
    - [2.4设置前面板的外观](#24设置前面板的外观)
      - [2.4.1改变对象的大小](#241改变对象的大小)
      - [2.4.2改变对象的颜色](#242改变对象的颜色)
      - [2.4.3设置对象的字体](#243设置对象的字体)
      - [2.4.4实例——编辑汽车行驶车速变化表标注](#244实例编辑汽车行驶车速变化表标注)
      - [2.4.5对象编辑窗口](#245对象编辑窗口)
      - [2.4.6实例——设计计算机控件](#246实例设计计算机控件)
    - [2.5菜单设计](#25菜单设计)
      - [2.5.1菜单编辑器](#251菜单编辑器)
      - [2.5.2实例——自定义菜单系统](#252实例自定义菜单系统)
      - [2.5.3“菜单”函数](#253菜单函数)
    - [2.6综合实例——交通信号灯控制系统](#26综合实例交通信号灯控制系统)
  - [第3章程序框图与程序结构](#第3章程序框图与程序结构)
    - [3.1程序框图](#31程序框图)
    - [3.2循环结构](#32循环结构)
      - [3.2.1For循环及并行循环](#321for循环及并行循环)
      - [3.2.2实例——显示循环次数](#322实例显示循环次数)
      - [3.2.3移位寄存器](#323移位寄存器)
      - [3.2.4实例——计算1+2+…+100](#324实例计算12100)
      - [3.2.5实例——计算偶数的和与积](#325实例计算偶数的和与积)
      - [3.2.6实例——计算循环次数与循环总数](#326实例计算循环次数与循环总数)
      - [3.2.7While循环](#327while循环)
      - [3.2.8实例——求解平方和优选值](#328实例求解平方和优选值)
      - [3.2.9反馈节点](#329反馈节点)
      - [3.2.10实例——指示灯显示](#3210实例指示灯显示)
    - [3.3条件结构](#33条件结构)
    - [3.3.1添加条件结构](#331添加条件结构)
    - [3.3.2实例——计算圆面积](#332实例计算圆面积)
    - [3.4顺序结构](#34顺序结构)
    - [3.5事件结构](#35事件结构)
    - [3.5.1实例——自定义控件的菜单](#351实例自定义控件的菜单)
    - [3.5.2程序框图禁用结构](#352程序框图禁用结构)
    - [3.5.3条件禁用结构](#353条件禁用结构)
    - [3.6定时循环](#36定时循环)
    - [3.6.1定时循环和定时顺序结构](#361定时循环和定时顺序结构)
    - [3.6.2实例——定时循环参数设置](#362实例定时循环参数设置)
    - [3.6.3配置定时循环和定时顺序结构](#363配置定时循环和定时顺序结构)
    - [3.6.4同步开始定时结构和中止定时结构的执行](#364同步开始定时结构和中止定时结构的执行)
    - [3.6.5实例——设置循环周期](#365实例设置循环周期)
    - [3.7公式节点](#37公式节点)
    - [3.7.1程序逻辑的公式节点](#371程序逻辑的公式节点)
    - [3.7.2实例——输出函数值](#372实例输出函数值)
    - [3.8综合实例——定时循环显示循环次数](#38综合实例定时循环显示循环次数)
  - [第4章数值字符串与布尔运算](#第4章数值字符串与布尔运算)
    - [4.1数值控件](#41数值控件)
    - [4.1.1数值型控件](#411数值型控件)
    - [4.1.2实例——水库蓄水系统前面板设计](#412实例水库蓄水系统前面板设计)
    - [4.1.3布尔型控件和单选按钮](#413布尔型控件和单选按钮)
    - [4.1.4字符串与路径控件](#414字符串与路径控件)
    - [4.1.5实例——“银色”选板控件的使用方法](#415实例银色选板控件的使用方法)
    - [4.1.6设置数值型控件的属性](#416设置数值型控件的属性)
    - [4.1.7实例——显示温度单位](#417实例显示温度单位)
    - [4.1.8设置文本型控件的属性](#418设置文本型控件的属性)
    - [4.1.9实例——组合框的使用方法](#419实例组合框的使用方法)
    - [4.1.10设置布尔型控件的属性](#4110设置布尔型控件的属性)
    - [4.1.11实例——切换按钮颜色](#4111实例切换按钮颜色)
    - [4.2数值运算](#42数值运算)
    - [4.2.1数值函数](#421数值函数)
    - [4.2.2实例——水库蓄水系统](#422实例水库蓄水系统)
    - [4.2.3实例——仪表显示](#423实例仪表显示)
    - [4.2.4函数快捷菜单命令](#424函数快捷菜单命令)
    - [4.2.5实例——车检基本情况表](#425实例车检基本情况表)
    - [4.2.6实例——气温测试系统](#426实例气温测试系统)
    - [4.2.7三角函数](#427三角函数)
    - [4.2.8实例——正切函数计算](#428实例正切函数计算)
    - [4.3字符串运算](#43字符串运算)
    - [4.3.1字符串常量](#431字符串常量)
    - [4.3.2实例——字符显示](#432实例字符显示)
    - [4.3.3设置字符串控件的属性](#433设置字符串控件的属性)
    - [4.3.4实例——字符转换](#434实例字符转换)
    - [4.3.5实例——字符选择](#435实例字符选择)
    - [4.3.6字符串函数](#436字符串函数)
    - [4.3.7实例——英文字符转换](#437实例英文字符转换)
    - [4.4其余运算](#44其余运算)
    - [4.4.1布尔运算](#441布尔运算)
    - [4.4.2比较运算](#442比较运算)
    - [4.4.3定时运算](#443定时运算)
    - [4.4.4对话框与用户界面运算](#444对话框与用户界面运算)
    - [4.4.5图形与声音运算](#445图形与声音运算)
    - [4.4.6实例——水库预警系统](#446实例水库预警系统)
    - [4.5综合实例——血压测试系统](#45综合实例血压测试系统)
  - [第5章数组、矩阵与簇](#第5章数组矩阵与簇)
    - [5.1数组控件](#51数组控件)
      - [5.1.1数组、矩阵和簇控件](#511数组矩阵和簇控件)
      - [5.1.2列表框、树形控件和表格](#512列表框树形控件和表格)
      - [5.1.3容器控件](#513容器控件)
      - [5.1.4实例——数组分类](#514实例数组分类)
    - [5.2数组](#52数组)
      - [5.2.1数组的组成](#521数组的组成)
      - [5.2.2实例——创建数组控件](#522实例创建数组控件)
      - [5.2.3实例——创建多维数组控件](#523实例创建多维数组控件)
      - [5.2.4数组函数](#524数组函数)
      - [5.2.5实例——比较数组](#525实例比较数组)
      - [5.2.6实例——选项卡数组](#526实例选项卡数组)
    - [5.3簇](#53簇)
      - [5.3.1簇的组成](#531簇的组成)
      - [5.3.2创建簇](#532创建簇)
      - [5.3.3实例——创建簇控件](#533实例创建簇控件)
      - [5.3.4实例——调整“簇”控件顺序](#534实例调整簇控件顺序)
      - [5.3.5簇函数](#535簇函数)
      - [5.3.6实例——使用“捆绑”函数创建“簇”控件](#536实例使用捆绑函数创建簇控件)
    - [5.4矩阵](#54矩阵)
      - [5.4.1创建矩阵](#541创建矩阵)
      - [5.4.2矩阵函数](#542矩阵函数)
      - [5.4.3实例——创建矩阵控件](#543实例创建矩阵控件)
      - [5.4.4实例——矩阵变换](#544实例矩阵变换)
    - [5.5综合实例——矩形的绘制](#55综合实例矩形的绘制)
  - [第6章数据图形显示](#第6章数据图形显示)
    - [6.1图形控件](#61图形控件)
    - [6.1.1图形和图表](#611图形和图表)
    - [6.1.2下拉列表与枚举控件](#612下拉列表与枚举控件)
    - [6.1.3I/O控件](#613io控件)
    - [6.1.4修饰控件](#614修饰控件)
    - [6.1.5实例——设计数学运算系统前面板](#615实例设计数学运算系统前面板)
    - [6.1.6对象和应用程序的引用](#616对象和应用程序的引用)
    - [6.1.7.NET与ActiveX控件](#617net与activex控件)
    - [6.1.8设置图形显示控件的属性](#618设置图形显示控件的属性)
    - [6.1.9实例——标注曲线](#619实例标注曲线)
    - [6.2图表图形](#62图表图形)
    - [6.2.1波形图](#621波形图)
    - [6.2.2实例——双Y轴曲线](#622实例双y轴曲线)
    - [6.2.3波形图表](#623波形图表)
    - [6.2.4实例——波形图表数据显示模式](#624实例波形图表数据显示模式)
    - [6.2.5XY图](#625xy图)
    - [6.2.6实例——绘制跳动曲线](#626实例绘制跳动曲线)
    - [6.2.7强度图](#627强度图)
    - [6.2.8实例——强度图的使用](#628实例强度图的使用)
    - [6.2.9强度图表](#629强度图表)
    - [6.2.10实例——强度图表的使用](#6210实例强度图表的使用)
    - [6.3二维图形](#63二维图形)
    - [6.3.1罗盘图](#631罗盘图)
    - [6.3.2误差线图](#632误差线图)
    - [6.3.3实例——绘制铸件尺寸误差棒图](#633实例绘制铸件尺寸误差棒图)
    - [6.3.4羽状图](#634羽状图)
    - [6.3.5XY曲线矩阵](#635xy曲线矩阵)
    - [6.3.6实例——绘制XY曲线矩阵图](#636实例绘制xy曲线矩阵图)
    - [6.4三维图形](#64三维图形)
    - [6.4.1三维曲面图](#641三维曲面图)
    - [6.4.2实例——山峰函数曲面图](#642实例山峰函数曲面图)
    - [6.4.3三维参数图](#643三维参数图)
    - [6.4.4实例——单位球面](#644实例单位球面)
    - [6.4.5三维曲线图](#645三维曲线图)
    - [6.4.6实例——绘制螺旋线](#646实例绘制螺旋线)
    - [6.4.7极坐标图](#647极坐标图)
    - [6.5综合实例——延迟波形](#65综合实例延迟波形)
  - [第7章数学函数](#第7章数学函数)
    - [7.1数学函数运算](#71数学函数运算)
    - [7.2线性代数Ⅵ](#72线性代数ⅵ)
    - [7.2.1特殊矩阵](#721特殊矩阵)
    - [7.2.2矩阵的基本运算](#722矩阵的基本运算)
    - [7.2.3实例——创建逆矩阵与转置矩阵](#723实例创建逆矩阵与转置矩阵)
    - [7.2.4矩阵的分解](#724矩阵的分解)
    - [7.2.5实例——分解帕斯卡矩阵](#725实例分解帕斯卡矩阵)
    - [7.2.6特征值](#726特征值)
    - [7.2.7实例——创建矩阵特征向量](#727实例创建矩阵特征向量)
    - [7.2.8线性方程组](#728线性方程组)
    - [7.3初等与特殊函数](#73初等与特殊函数)
    - [7.3.1指数函数](#731指数函数)
    - [7.3.2实例——绘制火柴杆图](#732实例绘制火柴杆图)
    - [7.3.3双曲函数](#733双曲函数)
    - [7.3.4实例——绘制双曲正弦曲线](#734实例绘制双曲正弦曲线)
    - [7.3.5离散数学](#735离散数学)
    - [7.3.6实例——离散计算选项卡](#736实例离散计算选项卡)
    - [7.3.7贝塞尔曲线](#737贝塞尔曲线)
    - [7.3.8实例——绘制贝塞尔曲线条形图](#738实例绘制贝塞尔曲线条形图)
    - [7.3.9Gamma函数](#739gamma函数)
    - [7.3.10实例——绘制Gamma函数及其倒数函数](#7310实例绘制gamma函数及其倒数函数)
    - [7.3.11超几何函数](#7311超几何函数)
    - [7.3.12椭圆积分函数](#7312椭圆积分函数)
    - [7.3.13指数积分函数](#7313指数积分函数)
    - [7.3.14误差函数](#7314误差函数)
    - [7.3.15椭圆与抛物函数](#7315椭圆与抛物函数)
    - [7.3.16实例——绘制抛物柱面曲线](#7316实例绘制抛物柱面曲线)
    - [7.4拟合Ⅵ](#74拟合ⅵ)
    - [7.4.1曲线拟合](#741曲线拟合)
    - [7.4.2拟合函数](#742拟合函数)
    - [7.4.3实例——金属材料应力拟合数据](#743实例金属材料应力拟合数据)
    - [7.5内插与外推Ⅵ](#75内插与外推ⅵ)
    - [7.6概率与统计Ⅵ](#76概率与统计ⅵ)
    - [7.6.1累积分布函数（连续）](#761累积分布函数连续)
    - [7.6.2逆累积分布函数（连续](#762逆累积分布函数连续)
    - [7.6.3累积分布函数（离散）](#763累积分布函数离散)
    - [7.6.4逆累积分布函数（离散）](#764逆累积分布函数离散)
    - [7.6.5实例——绘制几何概率曲线](#765实例绘制几何概率曲线)
    - [7.6.6方差分析Ⅵ](#766方差分析ⅵ)
    - [7.7很优化Ⅵ](#77很优化ⅵ)
    - [7.8微分方程Ⅵ](#78微分方程ⅵ)
    - [7.9多项式Ⅵ](#79多项式ⅵ)
    - [7.10综合实例——分解矩阵](#710综合实例分解矩阵)
  - [第8章波形运算](#第8章波形运算)
    - [8.1波形数据](#81波形数据)
    - [8.1.1变体函数](#811变体函数)
    - [8.1.2时间标识](#812时间标识)
    - [8.2波形生成](#82波形生成)
    - [8.2.1基本函数发生器](#821基本函数发生器)
    - [8.2.2实例——生成正弦信号的波形图](#822实例生成正弦信号的波形图)
    - [8.2.3正弦波形](#823正弦波形)
    - [8.2.4公式波形](#824公式波形)
    - [8.2.5实例——生成公式信号](#825实例生成公式信号)
    - [8.2.6基本混合单频](#826基本混合单频)
    - [8.2.7混合单频与噪声波形](#827混合单频与噪声波形)
    - [8.2.8基本带幅值混合单频](#828基本带幅值混合单频)
    - [8.2.9混合单频信号发生器](#829混合单频信号发生器)
    - [8.2.10均匀白噪声波形](#8210均匀白噪声波形)
    - [8.2.11实例——创建均匀白噪声波形](#8211实例创建均匀白噪声波形)
    - [8.2.12周期性随机噪声波形](#8212周期性随机噪声波形)
    - [8.2.13二项分布的噪声波形信号](#8213二项分布的噪声波形信号)
    - [8.2.14伯努利噪声波形](#8214伯努利噪声波形)
    - [8.2.15实例——输出噪声波形](#8215实例输出噪声波形)
    - [8.2.16仿真信号](#8216仿真信号)
    - [8.2.17实例——使用ExpressⅥ生成曲线](#8217实例使用expressⅵ生成曲线)
    - [8.3基本波形函数](#83基本波形函数)
    - [8.3.1获取波形成分](#831获取波形成分)
    - [8.3.2创建波形](#832创建波形)
    - [8.3.3实例——创建随机波形图](#833实例创建随机波形图)
    - [8.3.4“设置波形属性”函数和“获取波形属性”函数](#834设置波形属性函数和获取波形属性函数)
    - [8.3.5“索引波形数组”函数](#835索引波形数组函数)
    - [8.3.6“获取波形子集”函数](#836获取波形子集函数)
    - [8.3.7实例——简单正弦波形](#837实例简单正弦波形)
    - [8.3.8模拟波形](#838模拟波形)
    - [8.3.9实例——波形的偏移与缩放](#839实例波形的偏移与缩放)
    - [8.3.10数字波形Ⅵ和函数](#8310数字波形ⅵ和函数)
    - [8.4波形调理](#84波形调理)
    - [8.4.1数字FIR滤波器](#841数字fir滤波器)
    - [8.4.2数字IIR滤波器](#842数字iir滤波器)
    - [8.4.3按窗函数缩放](#843按窗函数缩放)
    - [8.4.4波形对齐（连续）](#844波形对齐连续)
    - [8.4.5波形对齐（单次）](#845波形对齐单次)
    - [8.4.6实例——波形的对齐和相减](#846实例波形的对齐和相减)
    - [8.4.7连续卷积（FIR）](#847连续卷积fir)
    - [8.4.8滤波器](#848滤波器)
    - [8.4.9对齐和重采样](#849对齐和重采样)
    - [8.4.10触发与门限](#8410触发与门限)
    - [8.4.11实例——执行带可选规范的IIR滤波](#8411实例执行带可选规范的iir滤波)
    - [8.5波形测量](#85波形测量)
    - [8.5.1基本平均直流——均方根](#851基本平均直流均方根)
    - [8.5.2瞬态特性测量](#852瞬态特性测量)
    - [8.5.3提取单频信息](#853提取单频信息)
    - [8.5.4快速傅里叶变换频谱（幅度——相位）](#854快速傅里叶变换频谱幅度相位)
    - [8.5.5频率响应函数（幅度——相位）](#855频率响应函数幅度相位)
    - [8.5.6频谱测量](#856频谱测量)
    - [8.5.7失真测量](#857失真测量)
    - [8.5.8幅值和电平测量](#858幅值和电平测量)
    - [8.5.9实例——幅值和电平测量计算](#859实例幅值和电平测量计算)
    - [8.5.10波形监测](#8510波形监测)
    - [8.5.11实例——基本电平触发波形](#8511实例基本电平触发波形)
    - [8.6综合实例——混合信号图](#86综合实例混合信号图)
  - [第9章信号生成与处理](#第9章信号生成与处理)
    - [9.1信号生成](#91信号生成)
    - [9.1.1基于持续时间的信号发生器](#911基于持续时间的信号发生器)
    - [9.1.2混合单频与噪声](#912混合单频与噪声)
    - [9.1.3高斯调制正弦波](#913高斯调制正弦波)
    - [9.1.4实例——计算高斯调制正弦波](#914实例计算高斯调制正弦波)
    - [9.1.5正弦信号](#915正弦信号)
    - [9.1.6正弦波](#916正弦波)
    - [9.1.7均匀白噪声](#917均匀白噪声)
    - [9.1.8任意波形发生器](#918任意波形发生器)
    - [9.1.9实例——对方波信号进行仿真滤波](#919实例对方波信号进行仿真滤波)
    - [9.2信号运算](#92信号运算)
    - [9.2.1卷积和相关ExpressⅥ](#921卷积和相关expressⅵ)
    - [9.2.2缩放和映射](#922缩放和映射)
    - [9.3窗](#93窗)
    - [9.4滤波器](#94滤波器)
    - [9.4.1巴特沃斯滤波器](#941巴特沃斯滤波器)
    - [9.4.2实例——正弦信号滤波](#942实例正弦信号滤波)
    - [9.4.3切比雪夫滤波器](#943切比雪夫滤波器)
    - [9.4.4FIR加窗滤波器](#944fir加窗滤波器)
    - [9.4.5SaⅥtzky-Golay滤波器](#945saⅵtzky-golay滤波器)
    - [9.4.6贝塞尔滤波器](#946贝塞尔滤波器)
    - [9.5谱分析](#95谱分析)
    - [9.6变换](#96变换)
    - [9.6.1FFT](#961fft)
    - [9.6.2FHT](#962fht)
    - [9.6.3反FFT](#963反fft)
    - [9.6.4反FHT](#964反fht)
    - [9.6.5实例——序列FFT](#965实例序列fft)
    - [9.7逐点](#97逐点)
    - [9.7.1信号生成](#971信号生成)
    - [9.7.2信号运算](#972信号运算)
    - [9.7.3滤波器](#973滤波器)
    - [9.7.4谱分析](#974谱分析)
    - [9.7.5变换](#975变换)
    - [9.7.6实例——生成STFT时频图](#976实例生成stft时频图)
    - [9.7.7线性代数](#977线性代数)
    - [9.8综合实例——获取回声信号的位置](#98综合实例获取回声信号的位置)
  - [第10章文件管理](#第10章文件管理)
    - [10.1文件数据](#101文件数据)
    - [10.1.1路径](#1011路径)
    - [10.1.2文件I/O格式](#1012文件io格式)
    - [10.1.3文件操作](#1013文件操作)
    - [10.1.4文件常量](#1014文件常量)
    - [10.1.5实例——格式化写入文件和扫描文件](#1015实例格式化写入文件和扫描文件)
    - [10.2文件类型](#102文件类型)
    - [10.2.1文本文件](#1021文本文件)
    - [10.2.2实例——写入余弦数据](#1022实例写入余弦数据)
    - [10.2.3实例——读取余弦数据](#1023实例读取余弦数据)
    - [10.2.4带分隔符电子表格文件](#1024带分隔符电子表格文件)
    - [10.2.5实例——输出带噪声锯齿波数据](#1025实例输出带噪声锯齿波数据)
    - [10.2.6实例——读取带Gamma噪声锯齿波数据](#1026实例读取带gamma噪声锯齿波数据)
    - [10.2.7二进制文件](#1027二进制文件)
    - [10.2.8配置文件](#1028配置文件)
    - [10.2.9TDMS](#1029tdms)
    - [10.2.10存储/数据插件](#10210存储数据插件)
    - [10.2.11实例——写入TDM数据文件](#10211实例写入tdm数据文件)
    - [10.2.12实例——读取TDM文件](#10212实例读取tdm文件)
    - [10.2.13Zip文件](#10213zip文件)
    - [10.2.14XML格式](#10214xml格式)
    - [10.2.15波形文件I/O函数](#10215波形文件io函数)
    - [10.2.16不错文件函数](#10216不错文件函数)
    - [10.2.17实例——编辑选中的文件](#10217实例编辑选中的文件)
    - [10.2.18数据记录文件的创建和读取](#10218数据记录文件的创建和读取)
    - [10.2.19记录前面板数据](#10219记录前面板数据)
    - [10.2.20实例——获取子Ⅵ前面板记录](#10220实例获取子ⅵ前面板记录)
    - [10.2.21数据与XML格式间的相互转换](#10221数据与xml格式间的相互转换)
    - [10.3综合实例——多路解调器](#103综合实例多路解调器)
  - [第11章数据采集](#第11章数据采集)
    - [11.1数据采集基础](#111数据采集基础)
    - [11.1.1DAQ功能概述](#1111daq功能概述)
    - [11.1.2NI-DAQ安装及节点介绍](#1112ni-daq安装及节点介绍)
    - [11.1.3DAQ节点常用的参数简介](#1113daq节点常用的参数简介)
    - [11.2DAQmx节点及其编程](#112daqmx节点及其编程)
    - [11.3综合实例——DAQ助手的使用](#113综合实例daq助手的使用)
  - [第12章通信技术](#第12章通信技术)
    - [12.1串行通信技术](#121串行通信技术)
    - [12.1.1串行通信介绍](#1211串行通信介绍)
    - [12.1.2ⅥSA配置串口](#1212ⅵsa配置串口)
    - [12.2DataSocket技术](#122datasocket技术)
    - [12.2.1DataSocket技术](#1221datasocket技术)
    - [12.2.2读取DataSocket](#1222读取datasocket)
    - [12.2.3写入DataSocket](#1223写入datasocket)
    - [12.2.4打开DataSocket](#1224打开datasocket)
    - [12.2.5关闭DataSocket](#1225关闭datasocket)
    - [12.2.6实例——正弦信号的远程通信](#1226实例正弦信号的远程通信)
    - [12.3TCP通信](#123tcp通信)
    - [12.3.1TCP](#1231tcp)
    - [12.3.2TCP侦听](#1232tcp侦听)
    - [12.3.3打开TCP连接](#1233打开tcp连接)
    - [12.3.4读取TCP数据](#1234读取tcp数据)
    - [12.3.5写入TCP数据](#1235写入tcp数据)
    - [12.3.6实例——随机波形的局域传递](#1236实例随机波形的局域传递)
    - [12.4其他通信方法介绍](#124其他通信方法介绍)
    - [12.4.1UDP通信](#1241udp通信)
    - [12.4.2实例——数据的地址传送](#1242实例数据的地址传送)
    - [12.5综合实例——队列速度的控制](#125综合实例队列速度的控制)
  - [第13章综合实例](#第13章综合实例)
    - [13.1火车故障检测系统实例](#131火车故障检测系统实例)
    - [13.2预测成本实例](#132预测成本实例)
    - [13.32D图片旋转显示实例](#1332d图片旋转显示实例)
    - [13.4二进制文件的字节顺序实例](#134二进制文件的字节顺序实例)
- [插件式框架](#插件式框架)
  - [Main](#main)
    - [Log4Net配置](#log4net配置)
      - [log4net.Config.XmlConfigurator.Configure();](#log4netconfigxmlconfiguratorconfigure)
    - [Log4Net初始化](#log4net初始化)
    - [MEF初始化](#mef初始化)
      - [new FABuilder().Load();](#new-fabuilderload)
  - [Plugin实现层](#plugin实现层)
    - [服务实现层](#服务实现层)
      - [FACommonService](#facommonservice)
        - [FALoggerService](#faloggerservice)
        - [FAMessageService](#famessageservice)
      - [FACommonViews](#facommonviews)
        - [DebugPanel.xaml](#debugpanelxaml)
        - [DebugPanelViewModel](#debugpanelviewmodel)
        - [DebugPanel.Xaml.cs](#debugpanelxamlcs)
    - [插件实现层](#插件实现层)
      - [MyFAPlugin1](#myfaplugin1)
        - [MyFAPlugin1](#myfaplugin1-1)
      - [MyFAPlugin2](#myfaplugin2)
        - [MyFAPlugin2](#myfaplugin2-1)
    - [FAStaticData](#fastaticdata)
  - [Controls](#controls)
    - [Conveter](#conveter)
      - [ProjectVisableConverter](#projectvisableconverter)
    - [DialogCloser](#dialogcloser)
    - [FADialog](#fadialog)
    - [FAWindow](#fawindow)
  - [Plugin接口层](#plugin接口层)
    - [Plugin插件模型接口层](#plugin插件模型接口层)
      - [FAPluginBase](#fapluginbase)
      - [FAView](#faview)
      - [FAViewModel](#faviewmodel)
    - [服务接口层](#服务接口层)
      - [IDebugOut](#idebugout)
      - [IFALogger](#ifalogger)
      - [IFAMessageBox](#ifamessagebox)
    - [Plugin插件模型接口层](#plugin插件模型接口层-1)
      - [MessageReceivedEventArgs](#messagereceivedeventargs)
  - [Core](#core)
    - [FABuilder](#fabuilder)
  - [Viwes](#viwes)
    - [CreateProject](#createproject)
      - [Xaml](#xaml-1)
      - [ViewModel](#viewmodel-1)
    - [MainWindow](#mainwindow)
      - [Xaml](#xaml-2)
      - [ViewModel](#viewmodel-2)
    - [SelectDevices](#selectdevices)
      - [Xaml](#xaml-3)
      - [ViewModel](#viewmodel-3)
    - [ViewLocator](#viewlocator)
  - [外部包依赖](#外部包依赖)
    - [Dirkster.AvalonDock](#dirksteravalondock)
      - [Dirkster.AvalonDock.Themes.VS2013](#dirksteravalondockthemesvs2013)
    - [Fluent.Ribbon](#fluentribbon)
    - [log4net](#log4net)
    - [MEF](#mef)
      - [System.ComponentModel.Composition](#systemcomponentmodelcomposition)
    - [Dirkster.AvalonDock](#dirksteravalondock-1)
    - [log4net](#log4net-1)
  - [LanguageResource实现多语言支持](#languageresource实现多语言支持)
- [数据结构与算法](#数据结构与算法)
  - [数据结构](#数据结构)
    - [逻辑结构](#逻辑结构)
      - [集合结构](#集合结构)
      - [线性结构](#线性结构)
      - [树形结构](#树形结构)
      - [图形结构](#图形结构)
    - [线性结构](#线性结构-1)
      - [顺序存储结构](#顺序存储结构)
      - [链式存储结构](#链式存储结构)
  - [算法](#算法)
    - [算法复杂度](#算法复杂度)
      - [时间复杂度](#时间复杂度)
      - [空间复杂度](#空间复杂度)
    - [\*\*\*章 从数据到算法](#章-从数据到算法)
      - [1.1 数据与数据结构](#11-数据与数据结构)
        - [1.1.1 数据及其类型](#111-数据及其类型)
        - [1.1.2 数据结构简介](#112-数据结构简介)
      - [1.2 算法](#12-算法)
        - [1.2.1 算法的概念](#121-算法的概念)
        - [1.2.2 算法的分析](#122-算法的分析)
        - [1.2.3 算法的设计](#123-算法的设计)
      - [1.3 C++中的STL](#13-c中的stl)
        - [1.3.1 STL 简介](#131-stl-简介)
        - [1.3.2 STL 构成](#132-stl-构成)
        - [1.3.3 STL 的不同版本](#133-stl-的不同版本)
    - [第2章 指针与数组--也谈中国古代兵制](#第2章-指针与数组--也谈中国古代兵制)
      - [2.1 指针](#21-指针)
        - [2.1.1 内存与地址](#211-内存与地址)
        - [2.1.2 指针的语法](#212-指针的语法)
        - [2.1.3 使用指针变量](#213-使用指针变量)
        - [2.1.4 函数与参数传递](#214-函数与参数传递)
      - [2.2 数组](#22-数组)
        - [2.2.1 结构型数据类型](#221-结构型数据类型)
        - [2.2.2 数组定义与初始化](#222-数组定义与初始化)
        - [2.2.3 数组与指针](#223-数组与指针)
        - [2.2.4 数组的抽象数据类型](#224-数组的抽象数据类型)
      - [2.3 数组应用举例](#23-数组应用举例)
        - [2.3.1 Z 字形编排问题](#231-z-字形编排问题)
        - [2.3.2 大整数乘法问题](#232-大整数乘法问题)
        - [2.3.3 九宫格问题](#233-九宫格问题)
      - [2.4 动态内存管理](#24-动态内存管理)
        - [2.4.1 关键词new 和delete](#241-关键词new-和delete)
        - [2.4.2 避免内存错误](#242-避免内存错误)
    - [第3章 字符串与模式匹配--梦里寻她千百度](#第3章-字符串与模式匹配--梦里寻她千百度)
      - [3.1 基本概念与定义](#31-基本概念与定义)
        - [3.1.1 C++中的字符串](#311-c中的字符串)
        - [3.1.2 字符串抽象数据类型](#312-字符串抽象数据类型)
      - [3.2 文本的\*\*\*匹配](#32-文本的匹配)
        - [3.2.1 BF 算法](#321-bf-算法)
        - [3.2.2 MP 算法](#322-mp-算法)
        - [3.2.3 KMP 算法](#323-kmp-算法)
        - [3.2.4 BM 算法](#324-bm-算法)
        - [3.2.5 BMH 算法](#325-bmh-算法)
      - [3.3 文本的模糊匹配](#33-文本的模糊匹配)
        - [3.3.1 全局编辑距离](#331-全局编辑距离)
        - [3.3.2 局部\*\*\*佳对准](#332-局部佳对准)
        - [3.3.3 N 元距离模型](#333-n-元距离模型)
      - [3.3.4 语音编码模型](#334-语音编码模型)
    - [第4章 链表--老鹰捉小鸡](#第4章-链表--老鹰捉小鸡)
      - [4.1 链表的概念](#41-链表的概念)
      - [4.2 单向链表](#42-单向链表)
        - [4.2.1 单向链表的结构](#421-单向链表的结构)
        - [4.2.2 单向链表的操作算法](#422-单向链表的操作算法)
        - [4.2.3 有序链表的合并算法](#423-有序链表的合并算法)
      - [4.3 单向循环链表](#43-单向循环链表)
        - [4.3.1 单向循环链表的结构](#431-单向循环链表的结构)
        - [4.3.2 单向循环链表的实现](#432-单向循环链表的实现)
        - [4.3.3 约瑟夫环的问题](#433-约瑟夫环的问题)
        - [4.3.4 魔术师发牌问题](#434-魔术师发牌问题)
        - [4.3.5 拉丁方阵的问题](#435-拉丁方阵的问题)
      - [4.4 双向循环链表](#44-双向循环链表)
        - [4.4.1 双向循环链表的结构](#441-双向循环链表的结构)
        - [4.4.2 双向循环链表的实现](#442-双向循环链表的实现)
        - [4.4.3 维吉尼亚加密法问题](#443-维吉尼亚加密法问题)
      - [4.5 游标类的设计与实现](#45-游标类的设计与实现)
        - [4.5.1 游标类的结构](#451-游标类的结构)
        - [4.5.2 游标类的实现](#452-游标类的实现)
      - [4.6 STL 与链表](#46-stl-与链表)
        - [4.6.1 STL 中链表类的接口](#461-stl-中链表类的接口)
        - [4.6.2 遍历](#462-遍历)
        - [4.6.3 元素的插入与删除](#463-元素的插入与删除)
    - [第5章 \*\*先出与后进先出--简单而深刻](#第5章-先出与后进先出--简单而深刻)
      - [5.1 摞盘子的策略](#51-摞盘子的策略)
        - [5.1.1 栈的结构](#511-栈的结构)
        - [5.1.2 栈的操作及实现](#512-栈的操作及实现)
        - [5.1.3 括号匹配问题](#513-括号匹配问题)
        - [5.1.4 停车场模拟问题](#514-停车场模拟问题)
      - [5.2 排队的智慧](#52-排队的智慧)
        - [5.2.1 队列的结构](#521-队列的结构)
        - [5.2.2 队列的操作及实现](#522-队列的操作及实现)
        - [5.2.3 舞伴问题](#523-舞伴问题)
        - [5.2.4 杨辉三角问题](#524-杨辉三角问题)
        - [5.2.5 游程编码问题](#525-游程编码问题)
      - [5.3 优先级队列--兼谈页面置换算法](#53-优先级队列--兼谈页面置换算法)
        - [5.3.1 优先级队列的结构](#531-优先级队列的结构)
        - [5.3.2 优先级队列的实现](#532-优先级队列的实现)
        - [5.4 STL 中的栈与队列](#54-stl-中的栈与队列)
        - [5.4.1 STL 中的stack](#541-stl-中的stack)
        - [5.4.2 STL 中的queue](#542-stl-中的queue)
        - [5.4.3 STL 中的priority\_queue](#543-stl-中的priority_queue)
    - [第6章 递归--老和尚讲故事](#第6章-递归--老和尚讲故事)
      - [6.1 递归的概念](#61-递归的概念)
        - [6.1.1 定义](#611-定义)
        - [6.1.2 应用递归的原则](#612-应用递归的原则)
        - [6.1.3 递归和非递归的转化](#613-递归和非递归的转化)
      - [6.2 分治法](#62-分治法)
        - [6.2.1 分治法简述](#621-分治法简述)
        - [6.2.2 汉诺塔问题](#622-汉诺塔问题)
        - [6.2.3 传染病问题](#623-传染病问题)
      - [6.3 回溯法](#63-回溯法)
        - [6.3.1 回溯法简述](#631-回溯法简述)
        - [6.3.2 迷宫问题](#632-迷宫问题)
        - [6.3.3 八皇后问题](#633-八皇后问题)
    - [树](#树)
      - [7.1 认识树这种结构](#71-认识树这种结构)
        - [7.1.1 基本定义](#711-基本定义)
        - [7.1.2 一些术语](#712-一些术语)
        - [7.1.3 树的抽象](#713-树的抽象)
      - [7.2 花开二枝分外香--二叉树及相关算法](#72-花开二枝分外香--二叉树及相关算法)
        - [7.2.1 二叉树的定义](#721-二叉树的定义)
        - [7.2.2 二叉树的性质](#722-二叉树的性质)
        - [7.2.3 二叉树的实现](#723-二叉树的实现)
        - [7.2.4 二叉树的遍历算法](#724-二叉树的遍历算法)
        - [7.2.5 二叉树线索化算法](#725-二叉树线索化算法)
      - [7.3 合抱之木，生于毫末--从树到森林](#73-合抱之木生于毫末--从树到森林)
        - [7.3.1 树的存储表示](#731-树的存储表示)
        - [7.3.2 树的实现](#732-树的实现)
        - [7.3.3 树与森林的遍历算法](#733-树与森林的遍历算法)
        - [7.3.4 森林与二叉树的转换](#734-森林与二叉树的转换)
      - [7.4 哈夫曼树--\*\*\*优二叉树编码算法](#74-哈夫曼树--优二叉树编码算法)
        - [7.4.1 哈夫曼编码](#741-哈夫曼编码)
        - [7.4.2 构造哈夫曼树](#742-构造哈夫曼树)
        - [7.4.3 哈夫曼编码的实现](#743-哈夫曼编码的实现)
      - [7.5 堆](#75-堆)
        - [7.5.1 堆的概念](#751-堆的概念)
        - [7.5.2 堆的建立](#752-堆的建立)
        - [7.5.3 堆的操作](#753-堆的操作)
      - [7.6 基于STL 实现树结构](#76-基于stl-实现树结构)
        - [7.6.1 STL 中的vector](#761-stl-中的vector)
        - [7.6.2 STL 中的map](#762-stl-中的map)
    - [第8章 图--始于哥尼斯堡的七桥问题](#第8章-图--始于哥尼斯堡的七桥问题)
      - [8.1 图的基本概念](#81-图的基本概念)
        - [8.1.1 图的定义](#811-图的定义)
        - [8.1.2 图的术语](#812-图的术语)
        - [8.1.3 图的运算](#813-图的运算)
        - [8.1.4 图的抽象数据类型](#814-图的抽象数据类型)
      - [8.2 图的存储与表示](#82-图的存储与表示)
        - [8.2.1 图的邻接矩阵表示](#821-图的邻接矩阵表示)
        - [8.2.2 图的邻接表表示](#822-图的邻接表表示)
        - [8.2.3 两种表示法的比较](#823-两种表示法的比较)
      - [8.3 图的遍历](#83-图的遍历)
        - [8.3.1 欧拉路径与欧拉回路](#831-欧拉路径与欧拉回路)
        - [8.3.2 哈密尔顿路径与哈密尔顿回路](#832-哈密尔顿路径与哈密尔顿回路)
        - [8.3.3 广度优先遍历算法](#833-广度优先遍历算法)
        - [8.3.4 深度优先遍历算法](#834-深度优先遍历算法)
      - [8.4 \*\*\*短路径问题](#84-短路径问题)
        - [8.4.1 固定起点\*\*\*短路径问题](#841-固定起点短路径问题)
        - [8.4.2 非固定起点\*\*\*短路径问题](#842-非固定起点短路径问题)
        - [8.4.3 \*\*\*短路径的动态规划解法](#843-短路径的动态规划解法)
      - [8.5 \*\*\*小生成树](#85-小生成树)
        - [8.5.1 \*\*\*小生成树的定义](#851-小生成树的定义)
        - [8.5.2 克鲁斯卡尔算法](#852-克鲁斯卡尔算法)
        - [8.5.3 普里姆算法](#853-普里姆算法)
    - [第9章 树形搜索结构-](#第9章-树形搜索结构-)
      - [9.1 二叉搜索树](#91-二叉搜索树)
        - [9.1.1 二叉搜索树的概念](#911-二叉搜索树的概念)
        - [9.1.2 二叉搜索树的操作](#912-二叉搜索树的操作)
        - [9.1.3 二叉搜索树的实现](#913-二叉搜索树的实现)
        - [9.1.4 二叉搜索树的分析](#914-二叉搜索树的分析)
      - [9.2 自平衡的二叉搜索树--\*\*L 树](#92-自平衡的二叉搜索树--l-树)
        - [9.2.1 \*\*L 树的概念](#921-l-树的概念)
        - [9.2.2 \*\*L 树的旋转](#922-l-树的旋转)
        - [9.2.3 \*\*L 树的实现](#923-l-树的实现)
      - [9.3 树中亦有"红与黑"](#93-树中亦有红与黑)
        - [9.3.1 红黑树的概念](#931-红黑树的概念)
        - [9.3.2 红黑树的操作](#932-红黑树的操作)
        - [9.3.3 红黑树的实现](#933-红黑树的实现)
      - [9.4 基于Trie 树的单词检索](#94-基于trie-树的单词检索)
        - [9.4.1 Trie 树的概念](#941-trie-树的概念)
        - [9.4.2 Trie 树的表示](#942-trie-树的表示)
        - [9.4.3 Trie 树的实现](#943-trie-树的实现)
    - [第10章 集合与字典--再言搜索之话题](#第10章-集合与字典--再言搜索之话题)
      - [10.1 集合论基础](#101-集合论基础)
        - [10.1.1 集合的概念](#1011-集合的概念)
        - [10.1.2 集合的运算](#1012-集合的运算)
      - [10.2 集合的实现](#102-集合的实现)
        - [10.2.1 位向量集合](#1021-位向量集合)
        - [10.2.2 单链表集合](#1022-单链表集合)
      - [10.3 字典](#103-字典)
        - [10.3.1 字典的概念](#1031-字典的概念)
        - [10.3.2 搜索运算](#1032-搜索运算)
      - [10.4 散列](#104-散列)
        - [10.4.1 散列的概念](#1041-散列的概念)
        - [10.4.2 散列函数](#1042-散列函数)
        - [10.4.3 字符串散列](#1043-字符串散列)
        - [10.4.4 处理散列冲突](#1044-处理散列冲突)
      - [10.5 拼写检查问题](#105-拼写检查问题)
      - [10.6 不相交集](#106-不相交集)
        - [10.6.1 不相交集的概念](#1061-不相交集的概念)
        - [10.6.2 不相交集的实现](#1062-不相交集的实现)
        - [10.6.3 犯罪团伙的问题](#1063-犯罪团伙的问题)
        - [10.6.4 路径压缩的实现](#1064-路径压缩的实现)
      - [10.7 STL 中的set](#107-stl-中的set)
      - [本章参考文献](#本章参考文献)
    - [第11章 排序--有序让世界\*\*\*美好](#第11章-排序--有序让世界美好)
      - [11.1 排序问题概述](#111-排序问题概述)
        - [11.1.1 基本概念和定义](#1111-基本概念和定义)
        - [11.1.2 排序算法的分类](#1112-排序算法的分类)
        - [11.1.3 排序算法的分析](#1113-排序算法的分析)
      - [11.2 插入排序](#112-插入排序)
        - [11.2.1 直接插入排序](#1121-直接插入排序)
        - [11.2.2 二分插入排序](#1122-二分插入排序)
        - [11.2.3 希尔排序](#1123-希尔排序)
      - [11.3 选择排序](#113-选择排序)
        - [11.3.1 直接选择排序](#1131-直接选择排序)
        - [11.3.2 堆排序](#1132-堆排序)
      - [11.4 交换排序](#114-交换排序)
        - [11.4.1 冒泡排序](#1141-冒泡排序)
        - [11.4.2 鸡尾酒排序](#1142-鸡尾酒排序)
        - [11.4.3 快速排序](#1143-快速排序)
      - [11.5 归并排序](#115-归并排序)
      - [11.6 计数排序](#116-计数排序)
  - [具体算法结构](#具体算法结构)
    - [线性表](#线性表)
      - [顺序表](#顺序表)
        - [静态顺序表](#静态顺序表)
        - [动态顺序表](#动态顺序表)
      - [链表](#链表)
        - [单链表](#单链表)
        - [双链表](#双链表)
        - [三链表](#三链表)
      - [链表相关面试题](#链表相关面试题)
        - [1.链表的逆序](#1链表的逆序)
        - [2.无头链表的删除和插入](#2无头链表的删除和插入)
        - [3.链表带环问题](#3链表带环问题)
      - [顺序表与链表的优缺点](#顺序表与链表的优缺点)
      - [栈和队列](#栈和队列)
        - [内容](#内容)
        - [栈](#栈)
        - [队列](#队列)
    - [树形结构](#树形结构-1)
      - [树的基本概念](#树的基本概念)
        - [节点](#节点)
        - [节点的度](#节点的度)
        - [叶节点](#叶节点)
        - [分支节点](#分支节点)
        - [祖先节点](#祖先节点)
        - [双亲节点](#双亲节点)
        - [兄弟节点](#兄弟节点)
        - [孩子节点](#孩子节点)
        - [树的深度](#树的深度)
      - [树的表示方法](#树的表示方法)
        - [双亲表示法](#双亲表示法)
        - [孩子表示法](#孩子表示法)
        - [双亲孩子表示法](#双亲孩子表示法)
        - [孩子兄弟表示法](#孩子兄弟表示法)
      - [树的存储形式](#树的存储形式)
      - [树的应用](#树的应用)
      - [二叉树](#二叉树)
        - [二叉树的概念](#二叉树的概念)
        - [二叉树的性质](#二叉树的性质)
        - [二叉树的存储](#二叉树的存储)
        - [二叉树的基本操作](#二叉树的基本操作)
        - [二叉树相关面试题练习](#二叉树相关面试题练习)
        - [线索化二叉树](#线索化二叉树)
      - [堆](#堆)
        - [堆的概念](#堆的概念)
        - [堆的创建](#堆的创建)
        - [堆的插入和删除](#堆的插入和删除)
        - [堆的应用](#堆的应用)
      - [huffman树](#huffman树)
        - [huffman树基本概念](#huffman树基本概念)
        - [huffman树构建算法](#huffman树构建算法)
        - [huffman编码](#huffman编码)
        - [huffman树的应用](#huffman树的应用)
    - [搜索](#搜索)
      - [搜索概念](#搜索概念)
      - [搜索分类](#搜索分类)
        - [线性查找](#线性查找)
        - [树形查找](#树形查找)
        - [哈希查找](#哈希查找)
    - [哈希表](#哈希表)
      - [哈希表概念](#哈希表概念)
      - [哈希冲突及解决方法](#哈希冲突及解决方法)
        - [哈希函数](#哈希函数)
        - [哈希冲突——开散列](#哈希冲突开散列)
        - [哈希冲突——闭散列](#哈希冲突闭散列)
      - [哈希表变形](#哈希表变形)
        - [哈希表变形——位图](#哈希表变形位图)
        - [哈希表变形——布隆过滤器](#哈希表变形布隆过滤器)
    - [排序](#排序)
      - [插入排序](#插入排序)
        - [直接插入排序](#直接插入排序)
        - [希尔排序](#希尔排序)
      - [选择排序](#选择排序)
        - [选择排序](#选择排序-1)
        - [堆排序](#堆排序)
      - [交换排序](#交换排序)
        - [冒泡排序](#冒泡排序)
        - [快速排序](#快速排序)
      - [归并排序](#归并排序)
      - [排序算法的优缺点](#排序算法的优缺点)
- [备注](#备注)

## 计算机史话

> 阿兰图灵是通用计算机的提出者，但是在有些问题上效率十分低下。

> 图灵机，又称图灵计算机指一个抽象的机器，是，英国数学家艾伦・麦席森・图灵(1912―-1954年)于1936年提出的一种抽象的计算模型，即将人们使用纸笔进行数学运算的过程进行抽象，由一个虚拟的机器替代人类进行数学运算。它有一条无限长的纸带，纸带分成了一个一个的小方格，每个方格有不同的颜色。有一个机器头在纸带上移来移去。机器头有一组内部状态，还有一些固定的程序。在每个时刻，机器头都要从当前纸带上读入一个方格信息，然后结合自己的内部状态查找程序表，根据程序输出信息到纸带方格上，并转换自己的内部状态，然后进行移动

> 最早的存储指令结构计算机模型实际是由ENIAC创建者埃可特和莫奇利，冯诺依曼与以上二位共同商议，1944年9月起草了《EDVAC报告书一号草案》，并署名，且为埃可特和莫奇利留了署名位置，但戈德斯塔提前发表了这份报告导致埃可特和莫奇利没有书名，所以现在存储程序计算机的逻辑结构成了广为人知的“冯诺依曼体系结构”。明确提出了，存储程序，顺序执行指令，使用二进制开关电路。并且这个体系产生了两个新的工程学科，计计算机体系结构和软件工程。冯诺依曼把计算机硬件划分为：CA（中央运算单元）CC（中央控制单元）M（内存）I（输入设备）O（输出设备。）

> 第一台冯诺依曼体系计算机1948年6月研制出原型机"Baby"由英国团队研制出来。

> 二战期间英国的计算机水平非常厉害，但是英国政府隐瞒了计算机方面研究的成就，包括阿兰图林一度不为人所知，因此导致美国冯诺依曼体系结构成了以后计算机的主要设计思想。

> 香农定律是关于信道容量的计算的一个经典定律，可以说是信息论的基础。

> Bug 一次是女程序员葛蕾丝霍普引入。

## Windows

## LinuxAndOpenSource

### Linux 命令大全

#### 系统信息 

> cat /etc/redhat-release 显示安装的系统版本

> getconf LONG_BIT 显示系统是多少位的（32/64bit）

> centos7的防火墙相关：

> firewall-cmd --state （防火墙状态）

> systemctl list-unit-files|grep firewalld.service（防火墙状态）

> systemctl restart firewalld.service(重启防火墙)

> systemctl disable firewalld.service（禁止开机自动启动）

> centos7以下的防火墙相关：

> service iptables stop(关闭防火墙centos7以下)

> chkconfig iptables off（禁止开机自动启动）

> arch 显示机器的处理器架构(1) 

> uname -m 显示机器的处理器架构(2) 

> uname -r 显示正在使用的内核版本 

> dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) 

> hdparm -i /dev/hda 罗列一个磁盘的架构特性 

> hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 

> cat /proc/cpuinfo 显示CPU info的信息 

> cat /proc/interrupts 显示中断 

> cat /proc/meminfo 校验内存使用 

> cat /proc/swaps 显示哪些swap被使用 

> cat /proc/version 显示内核的版本 

> cat /proc/net/dev 显示网络适配器及统计 

> cat /proc/mounts 显示已加载的文件系统 

> lspci -tv 罗列 PCI 设备 

> lsusb -tv 显示 USB 设备 

> date 显示系统日期 

> cal 2007 显示2007年的日历表 

> date 041217002007.00 设置日期和时间 - 月日时分年.秒 

> clock -w 将时间修改保存到 BIOS 

> 关机 (系统的关机、重启以及登出 ) 

> shutdown -h now 关闭系统(1) 

> init 0 关闭系统(2) 

> telinit 0 关闭系统(3) 

> shutdown -h hours:minutes & 按预定时间关闭系统 

> shutdown -c 取消按预定时间关闭系统 

> shutdown -r now 重启(1) 

> reboot 重启(2) 

> logout 注销 

> 文件和目录

> cd /home 进入 '/home' 目录' 

> cd .. 返回上一级目录 

> cd ../.. 返回上两级目录 

> cd 进入个人的主目录 

> cd ~user1 进入个人的主目录 

> cd - 返回上次所在的目录 

> pwd 显示工作路径 

> ls 查看目录中的文件 

> ls -F 查看目录中的文件 

> ls -l 显示文件和目录的详细资料 

> ls -a 显示隐藏文件 

> ls *[0-9]* 显示包含数字的文件名和目录名 

> tree 显示文件和目录由根目录开始的树形结构(1) 

> lstree 显示文件和目录由根目录开始的树形结构(2) 

> mkdir dir1 创建一个叫做 'dir1' 的目录' 

> mkdir dir1 dir2 同时创建两个目录 

> mkdir -p /tmp/dir1/dir2 创建一个目录树 

> rm -f file1 删除一个叫做 'file1' 的文件' 

> rmdir dir1 删除一个叫做 'dir1' 的目录' 

> rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 

> rm -rf dir1 dir2 同时删除两个目录及它们的内容 

> mv dir1 new_dir 重命名/移动 一个目录 

> cp file1 file2 复制一个文件 

> cp dir/* . 复制一个目录下的所有文件到当前工作目录 

> cp -a /tmp/dir1 . 复制一个目录到当前工作目录 

> cp -a dir1 dir2 复制一个目录 

> ln -s file1 lnk1 创建一个指向文件或目录的软链接 

> ln file1 lnk1 创建一个指向文件或目录的物理链接 

> touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) 

> file file1 outputs the mime type of the file as text 

> iconv -l 列出已知的编码 

> iconv -f fromEncoding -t toEncoding inputFile > outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. 

> find . -maxdepth 1 -name *.jpg -print -exec convert "{}" -resize 80x60 "thumbs/{}" \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)

#### 文件搜索 

> find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录 

> find / -user user1 搜索属于用户 'user1' 的文件和目录 

> find /home/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 

> find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 

> find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 

> find / -name \*.rpm -exec chmod 755 '{}' \; 搜索以 '.rpm' 结尾的文件并定义其权限 

> find / -xdev -name \*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备 

> locate \*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令 

> whereis halt 显示一个二进制文件、源码或man的位置 

> which halt 显示一个二进制文件或可执行文件的完整路径

#### 挂载一个文件系统 

> mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在 

> umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出 

> fuser -km /mnt/hda2 当设备繁忙时强制卸载 

> umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 

> mount /dev/fd0 /mnt/floppy 挂载一个软盘 

> mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom 

> mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom 

> mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom 

> mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 

> mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 

> mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 

> mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享

#### 磁盘空间 

> df -h 显示已经挂载的分区列表 

> ls -lSr |more 以尺寸大小排列文件和目录 

> du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间' 

> du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 

> rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) 

> dpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)

#### 用户和群组 

> groupadd group_name 创建一个新用户组 

> groupdel group_name 删除一个用户组 

> groupmod -n new_group_name old_group_name 重命名一个用户组 

> useradd -c "Name Surname " -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 "admin" 用户组的用户 

> useradd user1 创建一个新用户 

> userdel -r user1 删除一个用户 ( '-r' 排除主目录) 

> usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 

> passwd 修改口令 

> passwd user1 修改一个用户的口令 (只允许root执行) 

> chage -E 2005-12-31 user1 设置用户口令的失效期限 

> pwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户 

> grpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组 

> newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组

> 文件的权限 - 使用 "+" 设置权限，使用 "-" 用于取消 

> ls -lh 显示权限 

> ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 

> chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 

> chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 

> chown user1 file1 改变一个文件的所有人属性 

> chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 

> chgrp group1 file1 改变文件的群组 

> chown user1:group1 file1 改变一个文件的所有人和群组属性 

> find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 

> chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 

> chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 

> chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 

> chmod g-s /home/public 禁用一个目录的 SGID 位 

> chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 

> chmod o-t /home/public 禁用一个目录的 STIKY 位

> 文件的特殊属性 - 使用 "+" 设置权限，使用 "-" 用于取消 

> chattr +a file1 只允许以追加方式读写文件 

> chattr +c file1 允许这个文件能被内核自动压缩/解压 

> chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 

> chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 

> chattr +s file1 允许一个文件被安全地删除 

> chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 

> chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 

> lsattr 显示特殊的属性

#### 打包和压缩文件 

> bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件 

> bzip2 file1 压缩一个叫做 'file1' 的文件 

> gunzip file1.gz 解压一个叫做 'file1.gz'的文件 

> gzip file1 压缩一个叫做 'file1'的文件 

> gzip -9 file1 最大程度压缩 

> rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包 

> rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1' 

> rar x file1.rar 解压rar包 

> unrar x file1.rar 解压rar包 

> tar -cvf archive.tar file1 创建一个非压缩的 tarball 

> tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件 

> tar -tf archive.tar 显示一个包中的内容 

> tar -xvf archive.tar 释放一个包 

> tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 

> tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 

> tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包 

> tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 

> tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包 

> zip file1.zip file1 创建一个zip格式的压缩包 

> zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 

> unzip file1.zip 解压一个zip格式压缩包

#### RPM 包 

> > （Fedora, Redhat及类似系统） 

> rpm -ivh package.rpm 安装一个rpm包 

> rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 

> rpm -U package.rpm 更新一个rpm包但不改变其配置文件 

> rpm -F package.rpm 更新一个确定已经安装的rpm包 

> rpm -e package_name.rpm 删除一个rpm包 

> rpm -qa 显示系统中所有已经安装的rpm包 

> rpm -qa | grep httpd 显示所有名称中包含 "httpd" 字样的rpm包 

> rpm -qi package_name 获取一个已安装包的特殊信息 

> rpm -qg "System Environment/Daemons" 显示一个组件的rpm包 

> rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 

> rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 

> rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 

> rpm -q package_name --whatprovides 显示一个rpm包所占的体积 

> rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l 

> rpm -q package_name --changelog 显示一个rpm包的修改历史 

> rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 

> rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 

> rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 

> rpm --checksig package.rpm 确认一个rpm包的完整性 

> rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 

> rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 

> rpm -Va 检查系统中所有已安装的rpm包- 小心使用 

> rpm -Vp package.rpm 确认一个rpm包还未安装 

> rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 

> rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包 

> rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包

#### YUM 软件包升级器

> > （Fedora, RedHat及类似系统） 

> yum install package_name 下载并安装一个rpm包 

> yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 

> yum update package_name.rpm 更新当前系统中所有安装的rpm包 

> yum update package_name 更新一个rpm包 

> yum remove package_name 删除一个rpm包 

> yum list 列出当前系统中安装的所有包 

> yum search package_name 在rpm仓库中搜寻软件包 

> yum clean packages 清理rpm缓存删除下载的包 

> yum clean headers 删除所有头文件 

> yum clean all 删除所有缓存的包和头文件

#### DEB 包

> > (Debian, Ubuntu 以及类似系统) 

> dpkg -i package.deb 安装/更新一个 deb 包 

> dpkg -r package_name 从系统删除一个 deb 包 

> dpkg -l 显示系统中所有已经安装的 deb 包 

> dpkg -l | grep httpd 显示所有名称中包含 "httpd" 字样的deb包 

> dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 

> dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 

> dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 

> dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 

> APT 软件工具 (Debian, Ubuntu 以及类似系统) 

> apt-get install package_name 安装/更新一个 deb 包 

> apt-cdrom install package_name 从光盘安装/更新一个 deb 包 

> apt-get update 升级列表中的软件包 

> apt-get upgrade 升级所有已安装的软件 

> apt-get remove package_name 从系统删除一个deb包 

> apt-get check 确认依赖的软件仓库正确 

> apt-get clean 从下载的软件包中清理缓存 

> apt-cache search searched-package 返回包含所要搜索字符串的软件包名称

#### 查看文件内容 

> cat file1 从第一个字节开始正向查看文件的内容 

> tac file1 从最后一行开始反向查看一个文件的内容 

> more file1 查看一个长文件的内容 

> less file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作 

> head -2 file1 查看一个文件的前两行 

> tail -2 file1 查看一个文件的最后两行 

> tail -f /var/log/messages 实时查看被添加到一个文件中的内容 

#### 文本处理 

> cat file1 file2 ... | command <> file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT 

> cat file1 | command( sed, grep, awk, grep, etc...) > result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 

> cat file1 | command( sed, grep, awk, grep, etc...) >> result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 

> grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词"Aug" 

> grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以"Aug"开始的词汇 

> grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行 

> grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串"Aug" 

> sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 "string1" 替换成 "string2" 

> sed '/^$/d' example.txt 从example.txt文件中删除所有空白行 

> sed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行 

> echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容 

> sed -e '1d' result.txt 从文件example.txt 中排除第一行 

> sed -n '/stringa1/p' 查看只包含词汇 "string1"的行 

> sed -e 's/ *$//' example.txt 删除每一行最后的空白字符 

> sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 "string1" 并保留剩余全部 

> sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容 

> sed -n '5p;5q' example.txt 查看第5行 

> sed -e 's/00*/0/g' example.txt 用单个零替换多个零 

> cat -n file1 标示文件的行数 

> cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行 

> echo a b c | awk '{print $1}' 查看一行第一栏 

> echo a b c | awk '{print $1,$3}' 查看一行的第一和第三栏 

> paste file1 file2 合并两个文件或两栏的内容 

> paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用"+"区分 

> sort file1 file2 排序两个文件的内容 

> sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) 

> sort file1 file2 | uniq -u 删除交集，留下其他的行 

> sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) 

> comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容 

> comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容 

> comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 

#### 字符设置和文件格式转换 

> dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX 

> unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS 

> recode ..HTML < page.txt > page.html 将一个文本文件转换成html 

> recode -l | more 显示所有允许的转换格式 

#### 文件系统分析 

> badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 

> fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 

> fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 

> e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 

> e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 

> fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 

> fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 

> fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 

> dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 

#### 初始化一个文件系统 

> mkfs /dev/hda1 在hda1分区创建一个文件系统 

> mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 

> mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 

> mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 

> fdformat -n /dev/fd0 格式化一个软盘 

> mkswap /dev/hda3 创建一个swap文件系统 

#### SWAP文件系统 

> mkswap /dev/hda3 创建一个swap文件系统 

> swapon /dev/hda3 启用一个新的swap文件系统 

> swapon /dev/hda2 /dev/hdb3 启用两个swap分区 

#### 备份 

> dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份 

> dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份 

> restore -if /tmp/home0.bak 还原一个交互式备份 

> rsync -rogpav --delete /home /tmp 同步两边的目录 

> rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync 

> rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 

> rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 

> dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作 

> dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 

> tar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作 

> ( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p' 通过ssh在远程目录中复制一个目录内容 

> ( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p' 通过ssh在远程目录中复制一个本地目录 

> tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 

> find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录 

> find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包 

> dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 

> dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 

#### 光盘 

> cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 

> mkisofs /dev/cdrom > cd.iso 在磁盘上创建一个光盘的iso镜像文件 

> mkisofs /dev/cdrom | gzip > cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 

> mkisofs -J -allow-leading-dots -R -V "Label CD" -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 

> cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 

> gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 

> mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 

> cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 

> cd-paranoia -- "-3" 从一个CD光盘转录音轨到 wav 文件中（参数-3） 

> cdrecord --scanbus 扫描总线以识别scsi通道 

> dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 

#### 网络 - （以太网和WIFI无线）

> ifconfig eth0 显示一个以太网卡的配置 

> ifup eth0 启用一个 'eth0' 网络设备 

> ifdown eth0 禁用一个 'eth0' 网络设备 

> ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 

> ifconfig eth0 promisc 设置 'eth0' 成混杂模式以嗅探数据包 (sniffing) 

> dhclient eth0 以dhcp模式启用 'eth0' 

> route -n show routing table 

> route add -net 0/0 gw IP_Gateway configura default gateway 

> route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network '192.168.0.0/16' 

> route del 0/0 gw IP_gateway remove static route 

> echo "1" > /proc/sys/net/ipv4/ip_forward activate ip routing 

> hostname show hostname of system 

> host www.example.com lookup hostname to resolve name to ip address and viceversa(1) 

> nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) 

> ip link show show link status of all interfaces 

> mii-tool eth0 show link status of 'eth0' 

> ethtool eth0 show statistics of network card 'eth0' 

> netstat -tup show all active network connections and their PID 

> netstat -tupl show all network services listening on the system and their PID 

> tcpdump tcp port 80 show all HTTP traffic 

> iwlist scan show wireless networks 

> iwconfig eth1 show configuration of a wireless network card 

> hostname show hostname 

> host www.example.com lookup hostname to resolve name to ip address and viceversa 

> nslookup www.example.com lookup hostname to resolve name to ip address and viceversa 

> whois www.example.com lookup on Whois database 

### OpenSource主流开源协议

#### GPL

> 最开放，只要引用GPL协议的软件必须开源免费，不适合商业软件 有5大自由 使用，复制，修改，衍生，收费。

#### LGPL

> 较GPL 宽松

#### BSD  

> 发布带源代码 则源代码必须遵循BSD

> 发布只有二进制则必须声明遵循了BSD协议

#### Apache 

> 软件以及衍生品必须继续使用Apache许可。

> 修改了源代码则必须声明

> 基于他人源代码则必须保留原始代码的许可商标声明等。

> 类库保护，只正对引用的类库，而无须适用整个软件系统。

> 发布软件中有声明软件则需在此文件中注明基于Apache 和其他协议。

#### MIT(MITL)

> 修改后的源代码需要保留作者的许可信息即可。

#### Mozilla(MPL)

> 后续只开源使用的特定代码

> 多种协议可以混合使用

> 发布软件附带专门说明文件有原始的代码的修改时间和方式。

### Git in linux 

#### GithubCli

> Download and Install :

> https://github.com/cli/cli/releases

#### Login 

> $ gh auth login (config use ssh,need your token from github config)

#### Git helper 

> $ git clone git@github.com:devgis/MyWriting.git  //need your private key

> 提交修改 上传修改的代码后执行增加修改： 

> $ git add . 

> 增加修改信息： 

> $ git commit -m ‘修改lol清晰增加口径’ 

> 推送分支： 

> $ git push origin main

## Docker 

### Docker 安装 & 配置镜像加速器

> step 1：安装必要的一些系统工具

> > apt update

> > apt -y install apt-transport-https ca-certificates curl software-properties-common

> step 2：安装 GPG 证书

> > curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -

> Step 3：写入软件源信息

> > add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"

> Step 4：更新并安装 Docker-CE

> > apt -y update

> > apt -y install docker-ce

> > mkdir -p /etc/docker

> > tee /etc/docker/daemon.json <<-'EOF'

> > {

> > "registry-mirrors": ["https://jrzzvzok.mirror.aliyuncs.com"]

> > }

> > EOF

> > systemctl daemon-reload

> > systemctl restart docker

### container容器

#### 共享数据

##### DataVolume

### 镜像

> 镜像是只读的

> 镜像中包含有需要运行的文件

> 镜像用来创建container，一个镜像可以运行多个container；

> 镜像可以通过Dockerfile创建，也可以从Docker hub/registry上下载

### DockFile

### daemon D

> ocker Daemon是Docker架构中运行在后台的守护进程

### Docker Server  

> Server模块接受Docker Client的请求

> Engine Engine中处理请求，然后根据请求类型，创建出指定的Job并运行

> 向Docker Registry获取镜像，通过graphdriver执行容器镜像的本地化操作，通过networkdriver执行容器网络环境的配置，通过execdriver执行容器内部运行的执行工作等。

#### Job

### client

> Docker引擎可以直观理解为就是在某一台机器上运行的Docker程序，实际上它是一个C/S结构的软件，有一个后台守护进程在运行，每次运行docker命令的时候实际上都是通过RESTful Remote API来和守护进程进行交互的，即使是在同一台机器上也是如此。

### Swarm

### Machine

### Compose

### LXC

#### NameSpace

### repository

#### DockerHub

#### 私有仓库

### 优点

#### 快速，一致地交付您的应用程序

#### 响应式部署和扩展

#### 在同一硬件上运行更多工作负载

### Dockerfile 详解

> Docker 的架构很有魅力，他拥有类似于虚拟机性质的隔离机制，但并不是严格意义上的虚拟机。我还是喜欢拿货轮举例，以前我们是一条小船运一个集装箱的货物，现在可以把 N 个集装箱扔到一条大货轮上。每个容器（集装箱）共用宿主机（货轮）的内核（运载力），Dockerfile 就像是每个集装箱中的货物清单和说明书，一般由以下五部分构成：

> 2.1 基础指令

> > FROM： 指定基础镜像，且必须位于第一行，使用格式如下：

> > FROM <image>

> > FROM <image>:<tag>

> > FROM <image>@<digest>

> > Docker 的原理基于 Linux 内核的隔离技术，且 Linux From Scratch，因此 FROM scratch 是 docker 中最基础的镜像，debian、ubuntu 和 centos 等都基于 scratch 之上。在实际的运用中，如果必须从零开始搭建镜像的一般都选择 FROM debian 作为基础镜像，不过大多数情况下一般都会以如下：FROM python、FROM nginx、FROM java 等为基础镜像。

> > MAINTAINER：指定维护者信息，例：MAINTAINER user user@mail.com。

> 2.2 控制指令

> > RUN： 在构建的过程中指定需要被执行的命令，使用格式如下：

> > RUN command param1 param2 # 更推荐

> > RUN ["executable","param1","param2"]

> > WORKDIR： 用于切换构建过程中的工作目录，例：WORKDIR project。可配合环境变量使用，例：

> > ENV BASEDIR /project

> > WORKDIR $BASEDIR/test

> > ONBUILD: 在当前镜像被当做基础镜像时，执行其携带指令，例：ONBUILD RUN echo "hello world" “hello world”会在子镜像被构建的过程中输出。

> 2.3 引入指令

> > COPY： 拷贝文件或目录，格式：

> > COPY <src> <dest>

> > COPY ["<src>","<dest>"]

> > ADD： 在COPY的基础之上，ADD可识别压缩文件，例：ADD rootfs.tar.xz /。理论上也可添加网络地址，但还是建议在 RUN 指令中执行 wget 或 curl 命令，感觉这样更加可控。实际应用中我喜欢将 COPY 用于文件，ADD 用于目录（仅我个人的使用习惯）。

> 2.4 执行指令

> > CMD： 容器启动时需要执行的命令，格式：

> > CMD ["executable","param1","param2"] # 更推荐

> > CMD ["param1","param2"]

> > CMD command param1 param2 

> > 若在 docker run 中指定启动命令，则 CMD 将被覆盖。

> > ENTRYPOINT：主程序启动前的准备指令，用于启动主程序所依赖的服务，格式同CMD（基本上没用过就不介绍了，而且容易出错，不推荐使用）。

> 2.5 配置指令

> > EXPOSE： 暴露容器端口，格式：EXPOSE <port> [<port>...]，注意此处的暴露端口和docker run 中-p指定的映射端口是两个概念。

> > ENV： 声明环境变量，格式：ENV <key>=<value> ...。

> > LABEL： 标记，格式：LABEL <key>=<value>...。

> > USER： 设置启动容器的用户，格式：USER daemo。

> > ARG： 设置变量，格式同ENV。

> > STOPSIGNAL： 容器停止时给应用程序发出的信号，例：STOPSIGNAL SIGKELL。

> > SHELL： 指定shell，例：SHELL ["bash","-c"]。

#### Docker 命令详解

> 为了避免喧宾夺主，此处仅摘录我个人操作中较为常用的命令。

> 3.1 生命周期管理

> > run： 创建并运行容器，格式：docker run [OPTIONS] IMAGE [COMMAND] [ARG...]，参数说明：

> > -d , --detach            # 后台运行

> > -it, --interactive tty   # 交互终端形式运行

> > -p , --publish list      # 指定端口

> > -v , --volume list       # 挂载存储卷

> > 		 --name string       # 定义名字

> > 		 --rm                # 容器终止后自动删除（不支持在后台运行的容器）

> > 		 --restart string    # no、on-failure（非正常退出时重启，on-failure:3 最多重启三次）、always、unless-stopped

> > docker run 的参数甚多，可通过 --help 查询，后续这些复杂的配置都会移交给 Docker Compose，以上几个足以应用70%~80%的场景，例：

> 类似 ubuntu 这类容器必须以 -it 交互终端形式运行，否则无法在后台保留

> > docker run -it -d --name my-ubuntu ubuntu

> 端口映射和挂载数据卷

> > docker run -d \

> > -p 8080:80 \

> > -v /data/www:/usr/share/nginx/html\

> > --name my-nginx nginx

> > start/stop/restart：docker start/stop/restart my-container。

> > rm：移除容器，格式：docker rm [OPTIONS] CONTAINER [CONTAINER...]，参数说明：

> > -f, --force     Force the removal of a running container

> > -l, --link      Remove the specified link

> > -v, --volumes   Remove the volumes associated with the container

> > exec：在运行的容器中执行命令，不过更常用的还是先进入容器再执行命令，例子:docker exec -it my-nginx bash。

> 3.2 容器操作

> > ps： 列出容器，常用：docker ps -anq，参数说明：all、n last（最新 n 个容器）、quiet（只显示容器编号）。

> > top： 查看容器中的进程信息，例：docker top my-container。

> > logs： 查看容器日志，常用：docker logs -f --tail，参数说明：follow、--tail n（最新条日志）。

> > port：查看端口映射情况，例：docker port my-container。

> 3.3 镜像仓库

> > login/logout： 镜像仓库的登录和退出，格式：

> > docker login [OPTIONS] [SERVER]

> > docker logout  [SERVER]

> > 如果是Docker Hub，则示例如下：

> > docker login -u username -p passward

> > docker logout

> > 在生产环境中，我们一般会选择使用云厂商的镜像仓库，例：

> > docker login -u yo****@qq.com -p ****** registry-vpc.cn-hangzhou.aliyuncs.com

> > docker logout registry-vpc.cn-hangzhou.aliyuncs.com 

> > pull： 拉取镜像，最常用的命令之一，格式：docker pull [OPTIONS] NAME[:TAG|@DIGEST]。

> > push： 上传镜像，格式：docker push [OPTIONS] NAME[:TAG]。

> 3.4 本地镜像管理

> > images： 列出本地镜像，常用 docker images -q，参数说明：quiet（只显示image Id）。

> > rmi： 删除本地镜像，常用 docker rmi -f，参数说明：force。

> > tag： 标记镜像，归入仓库，格式：docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]，例：docker tag ubuntu youclk/my-ubuntu:v1。

> > build： 使用Dockerfile创建镜像，格式：docker build [OPTIONS] PATH | URL | -，参数说明：-t tag 例：docker build -t youclk/my-ubuntu:v1 .。

> > Install :sudo apt-get -y install docker.io

> Other

> > docker image ls # 列出当前环境下的镜像

> > docker images   # 列出当前环境下的镜像

> > docker image rm ididididid      # 安装id删除镜像

> > 操作容器

> > docker run -i -t --rm centos /bin/bash   # 启动一个centos容器并进入，此时容器是干干净净，没有一点东西的，do everything

> > docker container kill container_id    # 杀掉这个容器，强行终止

> > docker container rm container_id      # 删除这个容器

> > docker container ls            # 查找当前容器

> > docker ps // 查看所有正在运行容器

> > docker stop containerId // containerId 是容器的ID

> > docker ps -a // 查看所有容器

> > docker ps -a -q // 查看所有容器ID

> > docker stop $(docker ps -a -q) //  stop停止所有容器

> > docker  rm $(docker ps -a -q) //   remove删除所有容器

### Docker-compose 

#### 一，Docker-compose简介

> 1，Docker-compose简介

> > Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。 Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。 Docker-Compose的工程配置文件默认为docker-compose.yml，可通过环境变量COMPOSE_FILE或-f参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。 使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。 Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。

> > 

> 2，Docker-compose的安装

> > 安装环境查看

> > 也可以使用其他发行版本Linux系统

> > image

> > 安装

> > apt-get install python-pip

> > apt-get -y install docker-compose

> > 红帽系Linux使用以下命令安装

> > yum -y install python-pip

> > yum -y install docker-compose

> > 查看安装的版本

> > docker-compose -v

> > docker-compose version 1.21.0, build unknown

> > 

> 3，Docker-compose卸载

> > apt-get remove docker-compose

> > 

#### 二，Docker-compose常用命令

> 1，Docker-compose命令格式

> > docker-compose [-f <arg>...] [options] [COMMAND] [ARGS...]

> > 命令选项如下

> > 

> > -f --file FILE指定Compose模板文件，默认为docker-compose.yml

> > -p --project-name NAME 指定项目名称，默认使用当前所在目录为项目名

> > --verbose  输出更多调试信息

> > -v，-version 打印版本并退出

> > --log-level LEVEL 定义日志等级(DEBUG, INFO, WARNING, ERROR, CRITICAL)

> 2，docker-compose up

> > docker-compose up [options] [--scale SERVICE=NUM...] [SERVICE...]

> > 选项包括：

> > -d 在后台运行服务容器

> > -no-color 不是有颜色来区分不同的服务的控制输出

> > -no-deps 不启动服务所链接的容器

> > --force-recreate 强制重新创建容器，不能与-no-recreate同时使用

> > –no-recreate 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用

> > –no-build 不自动构建缺失的服务镜像

> > –build 在启动容器前构建服务镜像

> > –abort-on-container-exit 停止所有容器，如果任何一个容器被停止，不能与-d同时使用

> > -t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）

> > –remove-orphans 删除服务中没有在compose文件中定义的容器

> 3，docker-compose ps

> > docker-compose  ps [options] [SERVICE...]

> > 列出项目中所有在运行的容器

> 4，docker-compose stop

> > docker-compose stop [options] [SERVICE...]

> > 选项包括

> > -t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）

> > docker-compose stop

> > 停止正在运行的容器，可以通过docker-compose start 再次启动

> 5，docker-compose -h

> > docker-compose -h

> > 查看帮助

> 6，docker-compose down

> > docker-compose down [options]

> > 停止和删除容器、网络、卷、镜像。

> > 选项包括：

> > –rmi type，删除镜像，类型必须是：all，删除compose文件中定义的所有镜像；local，删除镜像名为空的镜像

> > -v, –volumes，删除已经在compose文件中定义的和匿名的附在容器上的数据卷

> > –remove-orphans，删除服务中没有在compose中定义的容器

> > docker-compose down

> > 停用移除所有容器以及网络相关

> 7，docker-compose logs

> > docker-compose logs [options] [SERVICE...]

> > 查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。

> > docker-compose logs

> > 查看服务容器的输出 

> > -f 跟踪日志输出

> 8，docker-compose bulid

> > docker-compose build [options] [--build-arg key=val...] [SERVICE...]

> > 构建（重新构建）项目中的服务容器。

> > 选项包括：

> > –compress 通过gzip压缩构建上下环境

> > –force-rm 删除构建过程中的临时容器

> > –no-cache 构建镜像过程中不使用缓存

> > –pull 始终尝试通过拉取操作来获取更新版本的镜像

> > -m, –memory MEM为构建的容器设置内存大小

> > –build-arg key=val为服务设置build-time变量

> > 服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-compose build来重新构建服务

> 9，docker-compose pull

> > docker-compose pull [options] [SERVICE...]

> > 拉取服务依赖的镜像。

> > 选项包括：

> > –ignore-pull-failures，忽略拉取镜像过程中的错误

> > –parallel，多个镜像同时拉取

> > –quiet，拉取镜像过程中不打印进度信息

> > docker-compose pull

> > 拉取服务依赖的镜像

> 10，docker-compose restart

> > docker-compose restart [options] [SERVICE...]

> > 重启项目中的服务。

> > 选项包括：

> > -t, –timeout TIMEOUT，指定重启前停止容器的超时（默认为10秒）

> > docker-compose restart

> > 重启项目中的服务 

> 11，docker-compose rm

> > docker-compose rm [options] [SERVICE...]

> > 删除所有（停止状态的）服务容器。

> > 选项包括：

> > –f, –force，强制直接删除，包括非停止状态的容器

> > -v，删除容器所挂载的数据卷

> > docker-compose rm

> > 删除所有（停止状态的）服务容器。推荐先执行docker-compose stop命令来停止容器。

> 12，docker-compose start

> > docker-compose start [SERVICE...]

> > docker-compose start

> > 启动已经存在的服务容器。

> 13，docker-compose run

> > docker-compose scale web=3 db=2

> > 设置指定服务运行的容器个数。通过service=num的参数来设置数量

> 14，docker-compose scale

> > docker-compose scale web=3 db=2

> > 设置指定服务运行的容器个数。通过service=num的参数来设置数量

> 15，docker-compose pause

> > docker-compose pause [SERVICE...]

> > 暂停一个服务容器

> 16，docker-compose kill

> > docker-compose kill [options] [SERVICE...]

> > 通过发送SIGKILL信号来强制停止服务容器。 

> > 支持通过-s参数来指定发送的信号，例如通过如下指令发送SIGINT信号：

> > docker-compose kill -s SIGINT

> 17，docker-compose config

> > docker-compose config [options]

> > 验证并查看compose文件配置。

> > 选项包括：

> > –resolve-image-digests 将镜像标签标记为摘要

> > -q, –quiet 只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息

> > –services 打印服务名，一行一个

> > –volumes 打印数据卷名，一行一个

> 18，docker-compose create

> > docker-compose create [options] [SERVICE...]

> > 为服务创建容器。

> > 选项包括：

> > –force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容–no-recreate参数

> > –no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数

> > –no-build：不创建镜像，即使缺失

> > –build：创建容器前　　，生成镜像

> 19，docker-compose exec

> > docker-compose exec [options] SERVICE COMMAND [ARGS...]

> > 选项包括：

> > -d 分离模式，后台运行命令。

> > –privileged 获取特权。

> > –user USER 指定运行的用户。

> > -T 禁用分配TTY，默认docker-compose exec分配TTY。

> > –index=index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务，例如：docker-compose exec –index=1 web /bin/bash ，web服务中包含多个容器

> 20，docker-compose port

> > docker-compose port [options] SERVICE PRIVATE_PORT

> > 显示某个容器端口所映射的公共端口。

> > 选项包括：

> > –protocol=proto，指定端口协议，TCP（默认值）或者UDP

> > –index=index，如果同意服务存在多个容器，指定命令对象容器的序号（默认为1）

> 21，docker-compose push

> > docker-compose push [options] [SERVICE...]

> > 推送服务依的镜像。

> > 选项包括：

> > –ignore-push-failures 忽略推送镜像过程中的错误

> 22，docker-compose stop

> > docker-compose stop [options] [SERVICE...]

> > 停止运行的容器

> 23，docker-compose uppause

> > docker-compose unpause [SERVICE...]

> > 恢复处于暂停状态中的服务。

#### 三，Docker-compose模板文件

> 1，Docker-compose模板文件简介

> > Compose允许用户通过一个docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Compose模板文件是一个定义服务、网络和卷的YAML文件。Compose模板文件默认路径是当前目录下的docker-compose.yml，可以使用.yml或.yaml作为文件扩展名。

> > Docker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分。

> > 举例

> > 

> > version: '3'

> > services:

> > web:

> > image: dockercloud/hello-world

> > ports:

> >   - 8080

> > networks:

> >   - front-tier

> >   - back-tier

> > 

> > redis:

> > image: redis

> > links:

> >   - web

> > networks:

> >   - back-tier

> > 

> > lb:

> > image: dockercloud/haproxy

> > ports:

> >   - 80:80

> > links:

> >   - web

> > networks:

> >   - front-tier

> >   - back-tier

> > volumes:

> >   - /var/run/docker.sock:/var/run/docker.sock 

> > 

> > networks:

> > front-tier:

> > driver: bridge

> > back-tier:

> > driver: bridge

> > Compose目前有三个版本分别为Version 1，Version 2，Version 3，Compose区分Version 1和Version 2（Compose 1.6.0+，Docker Engine 1.10.0+）。Version 2支持更多的指令。Version 1将来会被弃用。

> > 

> 2，image

> > image是指定服务的镜像名称或镜像ID。如果镜像在本地不存在，Compose将会尝试拉取镜像。

> > 

> > services: 

> > web: 

> >     image: hello-world

> 3，build

> > 服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建任务，构建标签是build，可以指定Dockerfile所在文件夹的路径。Compose将会利用Dockerfile自动构建镜像，然后使用镜像启动服务容器。

> > 

> > build: /path/to/build/dir

> > 也可以是相对路径，只要上下文确定就可以读取到Dockerfile。

> > 

> > build: ./dir

> > 设定上下文根目录，然后以该目录为准指定Dockerfile。

> > 

> > build:

> > context: ../

> > dockerfile: path/of/Dockerfile

> > build都是一个目录，如果要指定Dockerfile文件需要在build标签的子级标签中使用dockerfile标签指定。 如果同时指定image和build两个标签，那么Compose会构建镜像并且把镜像命名为image值指定的名字。

> > 

> 4,context

> > context选项可以是Dockerfile的文件路径，也可以是到链接到git仓库的url，当提供的值是相对路径时，被解析为相对于撰写文件的路径，此目录也是发送到Docker守护进程的context

> > 

> > build:

> > context: ./dir

> 5,dockerfile

> > 使用dockerfile文件来构建，必须指定构建路径

> > 

> > build:

> > context: .

> > dockerfile: Dockerfile-alternate

> 6,commond

> > command: bundle exec thin -p 3000

> 7,container_name

> > Compose的容器名称格式是：<项目名称><服务名称><序号>

> > 可以自定义项目名称、服务名称，但如果想完全控制容器的命名，可以使用标签指定：

> > 

> > container_name: app

> 8,depends_on

> > 在使用Compose时，最大的好处就是少打启动命令，但一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。例如在没启动数据库容器的时候启动应用容器，应用容器会因为找不到数据库而退出。depends_on标签用于解决容器的依赖、启动先后的问题

> > 

> > version: '2'

> > services:

> > web:

> > build: .

> > depends_on:

> >   - db

> >   - redis

> > redis:

> > image: redis

> > db:

> > image: postgres

> > 上述YAML文件定义的容器会先启动redis和db两个服务，最后才启动web 服务。

> > 

> 9,PID

> > pid: "host"

> > 将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用pid标签将能够访问和操纵其他容器和宿主机的名称空间。

> > 

> 10,ports

> > ports用于映射端口的标签。　

> > 使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。

> > 

> > ports:

> > /- "3000"

> > /- "8000:8000"

> > /- "49100:22"

> > /- "127.0.0.1:8001:8001"

> > 当使用HOST:CONTAINER格式来映射端口时，如果使用的容器端口小于60可能会得到错误得结果，因为YAML将会解析xx:yy这种数字格式为60进制。所以建议采用字符串格式。

> > 

> 11,extra_hosts

> > 添加主机名的标签，会在/etc/hosts文件中添加一些记录。

> > 

> > extra_hosts:

> > /- "somehost:162.242.195.82"

> > /- "otherhost:50.31.209.229"

> > 启动后查看容器内部hosts：

> > 

> 162.242.195.82  somehost

> 50.31.209.229   otherhost

> 12,volumes

> > 挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER]格式，或者使用[HOST:CONTAINER:ro]格式，后者对于容器来说，数据卷是只读的，可以有效保护宿主机的文件系统。 Compose的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。 数据卷的格式可以是下面多种形式

> > 

> > volumes:

> > // 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。

> > /- /var/lib/mysql

> > // 使用绝对路径挂载数据卷

> > /- /opt/data:/var/lib/mysql

> > // 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。

> > /- ./cache:/tmp/cache

> > // 使用用户的相对路径（~/ 表示的目录是 /home/<用户目录>/ 或者 /root/）。

> > /- ~/configs:/etc/configs/:ro

> > // 已经存在的命名的数据卷。

> > /- datavolume:/var/lib/mysql

> > 如果不使用宿主机的路径，可以指定一个volume_driver。

> > 

> 13,volumes_from

> > 从另一个服务或容器挂载其数据卷：

> > 

> > volumes_from:

> > - service_name    

> >  - container_name

> 14,dns

> > 自定义DNS服务器。可以是一个值，也可以是一个列表。

> > 

> > dns：8.8.8.8

> > dns：

> > - 8.8.8.8    

> >   - 9.9.9.9

> 15,expose

> > 暴露端口，但不映射到宿主机，只允许能被连接的服务访问。仅可以指定内部端口为参数，如下所示：

> > 

> > expose:

> > - "3000"

> > - "8000"

> 16,links

> > 链接到其它服务中的容器。使用服务名称（同时作为别名），或者服务名称:服务别名（如 SERVICE:ALIAS），例如

> > 

> > links:

> > - db

> > - db:database

> > - redis

> 17,net

> > 设置网络模式。

> > 

> > net: "bridge"

> > net: "none"

> > net: "host"

> > 四，Docker-compose模板文件示例

> 1，Docker-compose模板文件编写

> > docker-compose.yml

> > 

> > version: '2'

> > services:

> > web1:

> > image: nginx

> > ports: 

> >   - "6061:80"

> > container_name: "web1"

> > networks:

> >   - dev

> > web2:

> > image: nginx

> > ports: 

> >   - "6062:80"

> > container_name: "web2"

> > networks:

> >   - dev

> >   - pro

> > web3:

> > image: nginx

> > ports: 

> >   - "6063:80"

> > container_name: "web3"

> > networks:

> >   - pro

> > networks:

> > dev:

> > driver: bridge

> > pro:

> > driver: bridge

> > docker-compose.yml文件指定了3个web服务

> > 

> 2，启动应用

> > 创建一个webapp目录，将docker-compose.yaml文件拷贝到webapp目录下，使用docker-compose启动应用。

> > 

> > docker-compose up -d

> 3，服务访问

> > 通过浏览器访问web1，web2，web3

> > 

> > http://127.0.0.1:6061

> > http://127.0.0.1:6062

> > http://127.0.0.1:6063

### Dpcler-Kubernetes

> Kubernetes 也称为 K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统。

#### kubernetes 概述

> kubernetes 基本介绍

> > kubernetes，简称 K8s，是用 8 代替 8 个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。说白了，K8S，就是基于容器(Docker单机版)的集群管理平台,用于管理多个Docker的。Docker 非常适合在一台主机上运行容器，并为此提供所有必需的功能。但在当今的分布式服务环境中，真正的挑战是管理跨服务器和复杂基础架构的资源和工作负载。

> > Kubernetes 是 Google 开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。在 Kubernetes 中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。

> kubernetes 功能和架构

> > Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes 能够进行应用的自动化部署和扩缩容。在 Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes 积累了作为 Google 生产环境运行工作负载 15 年的经验，并吸收了来自于社区的最佳想法和实践。

> > K8s 功能(Kubernetes 适用场景):

> > > （1）自动装箱:基于容器对应用运行环境的资源配置要求自动部署应用容器

> > > （2）自我修复(自愈能力):当容器失败时，会对容器进行重启,当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度,当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务

> > > （3）水平扩展:通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁

> > > （3）服务发现:用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡

> > > （4）滚动更新:可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新

> > > （5）版本回退:可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退

> > > （6）密钥和配置管理:在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。

> > > （7）存储编排:自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务

> > > （8）批处理:提供一次性任务，定时任务；满足批量数据处理和分析的场景

> > 应用部署架构分类

> > > (1) 无中心节点架构： GlusterFS

> > > (2) 有中心节点架构： HDFS、K8S

> > k8s 集群架构

> > > Pod

> > > > 一个服务，是k8s管理的`最小单元`，k8s从 Pod中启动和管理容器；

> > > > 由Pod来管理一组相同功能的容器；

> > > > 一个Pod可以管理一个容器,也可以管理多个容器；

> > k8s 集群架构节点角色功能

Master Node:集群主控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；Master Node 由

API server (管理接口):是整个系统的对外接口，供客户端和其他组件调用，相当于“营业厅”

scheduler（调度器）:负责对集群内部的资源进行调度，相当于“调度室”

controller (控制器):负责管理控制器，相当于“大总管”。

etcd (键值对数据库):是一个键值存储仓库，存储集群的状态

Worker Node:集群工作节点，运行用户业务应用容器；Worker Node 包含 `

docker：容器管理

kubelet：主要负责监视指派到它所在的 Pod，包括创建、修改、监控、删除等。

kube-proxy：主要负责为Pod对象提供代理

其他附加服务

分布式键值存储服务

Etcd 服务

etcd是什么：

etcd 是 CoreOS 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。在分布式系统中，各种服务的配置信息的管理分享，服务的发现是一个很基本同时也是很重要的问题。CoreOS 项目就希望基于 etcd 来解决这一问题。

我们使用 etcd 来存储网络配置，解决容器互联互通的问题。

> > K8S核心概念：

通过Service统一入口进行访问，Controller用于创建Pot，Pot是一组容器的集合。

Pod:最小部署单元,一组容器的集合,共享网络,生命周期是短暂的

controller：确保预期的pod副本数量、无状态应用部署（无约定）、有状态应用部署(有特定条件)、确保所有的node运行同一个pod、一次性任务和定时任务

Service：定义一组pod的访问规则

搭建k8环境平台规划

服务器硬件配置要求搭建

测试环境：

master：2核+4G+20G

node：4核+8G+40G

生产环境：

Kubernetes 架构

核心角色

master (管理节点)

node（计算节点）

image (镜像仓库)

master 节点

master 节点服务

API server (管理接口)

scheduler（调度器）

controller (控制器)

etcd (键值对数据库)

Node 节点

node节点服务

docer

kubelet

kube-proxy

#### 核心概念

> 基础架构

> > Master

> > > Master节点上面主要由四个模块组成：APIServer、scheduler、controller manager、etcd。

> > > APIServer。APIServer负责对外提供RESTful的Kubernetes API服务，它是系统管理指令的统一入口，任何对资源进行增删改查的操作都要交给APIServer处理后再提交给etcd。如架构图中所示，kubectl（Kubernetes提供的客户端工具，该工具内部就是对Kubernetes API的调用）是直接和APIServer交互的。

> > > schedule。scheduler的职责很明确，就是负责调度pod到合适的Node上。如果把scheduler看成一个黑匣子，那么它的输入是pod和由多个Node组成的列表，输出是Pod和一个Node的绑定，即将这个pod部署到这个Node上。Kubernetes目前提供了调度算法，但是同样也保留了接口，用户可以根据自己的需求定义自己的调度算法。

> > > controller manager。如果说APIServer做的是“前台”的工作的话，那controller manager就是负责“后台”的。每个资源一般都对应有一个控制器，而controller manager就是负责管理这些控制器的。比如我们通过APIServer创建一个pod，当这个pod创建成功后，APIServer的任务就算完成了。而后面保证Pod的状态始终和我们预期的一样的重任就由controller manager去保证了。

> > > etcd。etcd是一个高可用的键值存储系统，Kubernetes使用它来存储各个资源的状态，从而实现了Restful的API。

> > Node

> > > 每个Node节点主要由三个模块组成：kubelet、kube-proxy、runtime。

> > > runtime。runtime指的是容器运行环境，目前Kubernetes支持docker和rkt两种容器。

> > > kube-proxy。该模块实现了Kubernetes中的服务发现和反向代理功能。反向代理方面：kube-proxy支持TCP和UDP连接转发，默认基于Round Robin算法将客户端流量转发到与service对应的一组后端pod。服务发现方面，kube-proxy使用etcd的watch机制，监控集群中service和endpoint对象数据的动态变化，并且维护一个service到endpoint的映射关系，从而保证了后端pod的IP变化不会对访问者造成影响。另外kube-proxy还支持session affinity。

> > > kubelet。Kubelet是Master在每个Node节点上面的agent，是Node节点上面最重要的模块，它负责维护和管理该Node上面的所有容器，但是如果容器不是通过Kubernetes创建的，它并不会管理。本质上，它负责使Pod得运行状态与期望的状态一致。

> > > 至此，Kubernetes的Master和Node就简单介绍完了。下面我们来看Kubernetes中的各种资源/对象。

> Pod

> > > Pod 是Kubernetes的基本操作单元，也是应用运行的载体。整个Kubernetes系统都是围绕着Pod展开的，比如如何部署运行Pod、如何保证Pod的数量、如何访问Pod等。另外，Pod是一个或多个机关容器的集合，这可以说是一大创新点，提供了一种容器的组合的模型。

> > 基本操作

 

> > > 创建

> > > > kubectl create -f xxx.yaml

> > > 查询

> > > > kubectl get pod yourPodName

> > > > kubectl describe pod yourPodName

> > > 删除

> > > > kubectl delete pod yourPodName

> > > 更新

> > > > kubectl replace /path/to/yourNewYaml.yaml

> > Pod与容器

> > > 在Docker中，容器是最小的处理单元，增删改查的对象是容器，容器是一种虚拟化技术，容器之间是隔离的，隔离是基于Linux Namespace实现的。而在Kubernetes中，Pod包含一个或者多个相关的容器，Pod可以认为是容器的一种延伸扩展，一个Pod也是一个隔离体，而Pod内部包含的一组容器又是共享的（包括PID、Network、IPC、UTS）。除此之外，Pod中的容器可以访问共同的数据卷来实现文件系统的共享。

> > 镜像

> > > 在kubernetes中，镜像的下载策略为：

> > > Always：每次都下载最新的镜像

> > > Never：只使用本地镜像，从不下载

> > > IfNotPresent：只有当本地没有的时候才下载镜像

> > > Pod被分配到Node之后会根据镜像下载策略进行镜像下载，可以根据自身集群的特点来决定采用何种下载策略。无论何种策略，都要确保Node上有正确的镜像可用。

> > 其他设置

> > > 通过yaml文件，可以在Pod中设置：

> > > 启动命令，如：spec-->containers-->command；

> > > 环境变量，如：spec-->containers-->env-->name/value；

> > > 端口桥接，如：spec-->containers-->ports-->containerPort/protocol/hostIP/hostPort（使用hostPort时需要注意端口冲突的问题，不过Kubernetes在调度Pod的时候会检查宿主机端口是否冲突，比如当两个Pod均要求绑定宿主机的80端口，Kubernetes将会将这两个Pod分别调度到不同的机器上）;

> > > Host网络，一些特殊场景下，容器必须要以host方式进行网络设置（如接收物理机网络才能够接收到的组播流），在Pod中也支持host网络的设置，如：spec-->hostNetwork=true；

> > > 数据持久化，如：spec-->containers-->volumeMounts-->mountPath;

> > > 重启策略，当Pod中的容器终止退出后，重启容器的策略。这里的所谓Pod的重启，实际上的做法是容器的重建，之前容器中的数据将会丢失，如果需要持久化数据，那么需要使用数据卷进行持久化设置。Pod支持三种重启策略：Always（默认策略，当容器终止退出后，总是重启容器）、OnFailure（当容器终止且异常退出时，重启）、Never（从不重启）；

> > Pod生命周期

> > > Pod被分配到一个Node上之后，就不会离开这个Node，直到被删除。当某个Pod失败，首先会被Kubernetes清理掉，之后ReplicationController将会在其它机器上（或本机）重建Pod，重建之后Pod的ID发生了变化，那将会是一个新的Pod。所以，Kubernetes中Pod的迁移，实际指的是在新Node上重建Pod。以下给出Pod的生命周期图。

> > > 生命周期回调函数：PostStart（容器创建成功后调研该回调函数）、PreStop（在容器被终止前调用该回调函数）。以下示例中，定义了一个Pod，包含一个JAVA的web应用容器，其中设置了PostStart和PreStop回调函数。即在容器创建成功后，复制/sample.war到/app文件夹中。而在容器终止之前，发送HTTP请求到http://monitor.com:8080/waring，即向监控系统发送警告。具体示例如下：

```

………..

containers:

- image: sample:v2  

     name: war

     lifecycle：

      posrStart:

       exec:

         command:

          - “cp”

          - “/sample.war”

          - “/app”

      prestop:

       httpGet:

        host: monitor.com

        psth: /waring

        port: 8080

        scheme: HTTP

```

 

> Replication Controller

> > > Replication Controller（RC）是Kubernetes中的另一个核心概念，应用托管在Kubernetes之后，Kubernetes需要保证应用能够持续运行，这是RC的工作内容，它会确保任何时间Kubernetes中都有指定数量的Pod在运行。在此基础上，RC还提供了一些更高级的特性，比如滚动升级、升级回滚等。

> > RC与Pod的关联——Label

> > > RC与Pod的关联是通过Label来实现的。Label机制是Kubernetes中的一个重要设计，通过Label进行对象的弱关联，可以灵活地进行分类和选择。对于Pod，需要设置其自身的Label来进行标识，Label是一系列的Key/value对，在Pod-->metadata-->labeks中进行设置。

> > > Label的定义是任一的，但是Label必须具有可标识性，比如设置Pod的应用名称和版本号等。另外Lable是不具有唯一性的，为了更准确的标识一个Pod，应该为Pod设置多个维度的label。如下：

> > > "release" : "stable", "release" : "canary"

> > > "environment" : "dev", "environment" : "qa", "environment" : "production"

> > > "tier" : "frontend", "tier" : "backend", "tier" : "cache"

> > > "partition" : "customerA", "partition" : "customerB"

> > > "track" : "daily", "track" : "weekly"

> > > 举例，当你在RC的yaml文件中定义了该RC的selector中的label为app:my-web，那么这个RC就会去关注Pod-->metadata-->labeks中label为app:my-web的Pod。修改了对应Pod的Label，就会使Pod脱离RC的控制。同样，在RC运行正常的时候，若试图继续创建同样Label的Pod，是创建不出来的。因为RC认为副本数已经正常了，再多起的话会被RC删掉的。

> > 弹性伸缩

> > > 弹性伸缩是指适应负载变化，以弹性可伸缩的方式提供资源。反映到Kubernetes中，指的是可根据负载的高低动态调整Pod的副本数量。调整Pod的副本数是通过修改RC中Pod的副本是来实现的，示例命令如下：

> > > 扩容Pod的副本数目到10

> > > > $ kubectl scale relicationcontroller yourRcName --replicas=10

> > > 缩容Pod的副本数目到1

> > > > $ kubectl scale relicationcontroller yourRcName --replicas=1

 

> > 滚动升级

> > > 滚动升级是一种平滑过渡的升级方式，通过逐步替换的策略，保证整体系统的稳定，在初始升级的时候就可以及时发现、调整问题，以保证问题影响度不会扩大。Kubernetes中滚动升级的命令如下：

$ kubectl rolling-update my-rcName-v1 -f my-rcName-v2-rc.yaml --update-period=10s

> > > 升级开始后，首先依据提供的定义文件创建V2版本的RC，然后每隔10s（--update-period=10s）逐步的增加V2版本的Pod副本数，逐步减少V1版本Pod的副本数。升级完成之后，删除V1版本的RC，保留V2版本的RC，及实现滚动升级。

> > > 升级过程中，发生了错误中途退出时，可以选择继续升级。Kubernetes能够智能的判断升级中断之前的状态，然后紧接着继续执行升级。当然，也可以进行回退，命令如下：

$ kubectl rolling-update my-rcName-v1 -f my-rcName-v2-rc.yaml --update-period=10s --rollback

回退的方式实际就是升级的逆操作，逐步增加V1.0版本Pod的副本数，逐步减少V2版本Pod的副本数。

> > 新一代副本控制器replica set

> > > 这里所说的replica set，可以被认为 是“升级版”的Replication Controller。也就是说。replica set也是用于保证与label selector匹配的pod数量维持在期望状态。区别在于，replica set引入了对基于子集的selector查询条件，而Replication Controller仅支持基于值相等的selecto条件查询。这是目前从用户角度肴，两者唯一的显著差异。 社区引入这一API的初衷是用于取代vl中的Replication Controller，也就是说．当v1版本被废弃时，Replication Controller就完成了它的历史使命，而由replica set来接管其工作。虽然replica set可以被单独使用，但是目前它多被Deployment用于进行pod的创建、更新与删除。Deployment在滚动更新等方面提供了很多非常有用的功能，关于DeplOymCn的更多信息，读者们可以在后续小节中获得。

 

> Job

> > > 从程序的运行形态上来区分，我们可以将Pod分为两类：长时运行服务（jboss、mysql等）和一次性任务（数据计算、测试）。RC创建的Pod都是长时运行的服务，而Job创建的Pod都是一次性任务。

> > > 在Job的定义中，restartPolicy（重启策略）只能是Never和OnFailure。Job可以控制一次性任务的Pod的完成次数（Job-->spec-->completions）和并发执行数（Job-->spec-->parallelism），当Pod成功执行指定次数后，即认为Job执行完毕。

 

> Service

> > > 为了适应快速的业务需求，微服务架构已经逐渐成为主流，微服务架构的应用需要有非常好的服务编排支持。Kubernetes中的核心要素Service便提供了一套简化的服务代理和发现机制，天然适应微服务架构。

> > 原理

> > > 在Kubernetes中，在受到RC调控的时候，Pod副本是变化的，对于的虚拟IP也是变化的，比如发生迁移或者伸缩的时候。这对于Pod的访问者来说是不可接受的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略，Service同Pod的关联同样是居于Label来完成的。Service的目标是提供一种桥梁， 它会为访问者提供一个固定访问地址，用于在访问时重定向到相应的后端，这使得非 Kubernetes原生应用程序，在无须为Kubemces编写特定代码的前提下，轻松访问后端。

> > > Service同RC一样，都是通过Label来关联Pod的。当你在Service的yaml文件中定义了该Service的selector中的label为app:my-web，那么这个Service会将Pod-->metadata-->labeks中label为app:my-web的Pod作为分发请求的后端。当Pod发生变化时（增加、减少、重建等），Service会及时更新。这样一来，Service就可以作为Pod的访问入口，起到代理服务器的作用，而对于访问者来说，通过Service进行访问，无需直接感知Pod。

> > > 需要注意的是，Kubernetes分配给Service的固定IP是一个虚拟IP，并不是一个真实的IP，在外部是无法寻址的。真实的系统实现上，Kubernetes是通过Kube-proxy组件来实现的虚拟IP路由及转发。所以在之前集群部署的环节上，我们在每个Node上均部署了Proxy这个组件，从而实现了Kubernetes层级的虚拟转发网络。

> > Service代理外部服务

> > > Service不仅可以代理Pod，还可以代理任意其他后端，比如运行在Kubernetes外部Mysql、Oracle等。这是通过定义两个同名的service和endPoints来实现的。示例如下：

> > > redis-service.yaml

```

apiVersion: v1

kind: Service

metadata:

  name: redis-service

spec:

  ports:

  - port: 6379

    targetPort: 6379

    protocol: TCP

```

> > > redis-endpoints.yaml

```

apiVersion: v1

kind: Endpoints

metadata:

  name: redis-service

subsets:

  - addresses:

    - ip: 10.0.251.145

    ports:

    - port: 6379

      protocol: TCP

```

> > > 基于文件创建完Service和Endpoints之后，在Kubernetes的Service中即可查询到自定义的Endpoints。

```

[root@k8s-master demon]# kubectl describe service redis-service

Name:            redis-service

Namespace:        default

Labels:            <none>

Selector:        <none>

Type:            ClusterIP

IP:            10.254.52.88

Port:            <unset> 6379/TCP

Endpoints:        10.0.251.145:6379

Session Affinity:    None

No events.

[root@k8s-master demon]# etcdctl get /skydns/sky/default/redis-service

{"host":"10.254.52.88","priority":10,"weight":10,"ttl":30,"targetstrip":0}

```

> > Service内部负载均衡

> > > 当Service的Endpoints包含多个IP的时候，及服务代理存在多个后端，将进行请求的负载均衡。默认的负载均衡策略是轮训或者随机（有kube-proxy的模式决定）。同时，Service上通过设置Service-->spec-->sessionAffinity=ClientIP，来实现基于源IP地址的会话保持。

> > 发布Service

> > > Service的虚拟IP是由Kubernetes虚拟出来的内部网络，外部是无法寻址到的。但是有些服务又需要被外部访问到，例如web前段。这时候就需要加一层网络转发，即外网到内网的转发。Kubernetes提供了NodePort、LoadBalancer、Ingress三种方式。

> > > NodePort，在之前的Guestbook示例中，已经延时了NodePort的用法。NodePort的原理是，Kubernetes会在每一个Node上暴露出一个端口：nodePort，外部网络可以通过（任一Node）[NodeIP]:[NodePort]访问到后端的Service。

> > > LoadBalancer，在NodePort基础上，Kubernetes可以请求底层云平台创建一个负载均衡器，将每个Node作为后端，进行服务分发。该模式需要底层云平台（例如GCE）支持。

> > > Ingress，是一种HTTP方式的路由转发机制，由Ingress Controller和HTTP代理服务器组合而成。Ingress Controller实时监控Kubernetes API，实时更新HTTP代理服务器的转发规则。HTTP代理服务器有GCE Load-Balancer、HaProxy、Nginx等开源方案。

> > servicede 自发性机制

> > > Kubernetes中有一个很重要的服务自发现特性。一旦一个service被创建，该service的service IP和service port等信息都可以被注入到pod中供它们使用。Kubernetes主要支持两种service发现 机制：环境变量和DNS。

> > 环境变量方式

> > > Kubernetes创建Pod时会自动添加所有可用的service环境变量到该Pod中，如有需要．这些环境变量就被注入Pod内的容器里。需要注意的是，环境变量的注入只发送在Pod创建时，且不会被自动更新。这个特点暗含了service和访问该service的Pod的创建时间的先后顺序，即任何想要访问service的pod都需要在service已经存在后创建，否则与service相关的环境变量就无法注入该Pod的容器中，这样先创建的容器就无法发现后创建的service。

> > DNS方式

> > > Kubernetes集群现在支持增加一个可选的组件——DNS服务器。这个DNS服务器使用Kubernetes的watchAPI，不间断的监测新的service的创建并为每个service新建一个DNS记录。如果DNS在整个集群范围内都可用，那么所有的Pod都能够自动解析service的域名。Kube-DNS搭建及更详细的介绍请见：基于Kubernetes集群部署skyDNS服务

> > 多个service如何避免地址和端口冲突

> > > 此处设计思想是，Kubernetes通过为每个service分配一个唯一的ClusterIP，所以当使用ClusterIP：port的组合访问一个service的时候，不管port是什么，这个组合是一定不会发生重复的。另一方面，kube-proxy为每个service真正打开的是一个绝对不会重复的随机端口，用户在service描述文件中指定的访问端口会被映射到这个随机端口上。这就是为什么用户可以在创建service时随意指定访问端口。

> > service目前存在的不足

> > > Kubernetes使用iptables和kube-proxy解析service的人口地址，在中小规模的集群中运行良好，但是当service的数量超过一定规模时，仍然有一些小问题。首当其冲的便是service环境变量泛滥，以及service与使用service的pod两者创建时间先后的制约关系。目前来看，很多使用者在使用Kubernetes时往往会开发一套自己的Router组件来替代service，以便更好地掌控和定制这部分功能。

 

> Deployment

> > > Kubernetes提供了一种更加简单的更新RC和Pod的机制，叫做Deployment。通过在Deployment中描述你所期望的集群状态，Deployment Controller会将现在的集群状态在一个可控的速度下逐步更新成你所期望的集群状态。Deployment主要职责同样是为了保证pod的数量和健康，90%的功能与Replication Controller完全一样，可以看做新一代的Replication Controller。但是，它又具备了Replication Controller之外的新特性：

> > > Replication Controller全部功能：Deployment继承了上面描述的Replication Controller全部功能。

> > > 事件和状态查看：可以查看Deployment的升级详细进度和状态。

> > > 回滚：当升级pod镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。

> > > 版本记录: 每一次对Deployment的操作，都能保存下来，给予后续可能的回滚使用。

> > > 暂停和启动：对于每一次升级，都能够随时暂停和启动。

> > > 多种升级方案：Recreate----删除所有已存在的pod,重新创建新的; RollingUpdate----滚动升级，逐步替换的策略，同时滚动升级时，支持更多的附加参数，例如设置最大不可用pod数量，最小升级间隔时间等等。

> > 滚动升级

> > > 相比于RC，Deployment直接使用kubectl edit deployment/deploymentName 或者kubectl set方法就可以直接升级（原理是Pod的template发生变化，例如更新label、更新镜像版本等操作会触发Deployment的滚动升级）。操作示例——首先 我们同样定义一个nginx-deploy-v1.yaml的文件，副本数量为2：

```

apiVersion: extensions/v1beta1

kind: Deployment

metadata:

  name: nginx-deployment

spec:

  replicas: 3

  template:

    metadata:

      labels:

        app: nginx

    spec:

      containers:

      - name: nginx

        image: nginx:1.7.9

        ports:

        - containerPort: 80

```

> > > 创建deployment：

```

$ kubectl create -f nginx-deploy-v1.yaml --record

deployment "nginx-deployment" created

$ kubectl get deployments

NAME       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE

nginx-deployment   3         0         0            0           1s

$ kubectl get deployments

NAME       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE

nginx-deployment   3         3         3            3           18s

```

> > > 正常之后，将nginx的版本进行升级，从1.7升级到1.9。第一种方法，直接set镜像：

$ kubectl set image deployment/nginx-deployment2 nginx=nginx:1.9

deployment "nginx-deployment2" image updated

> > > 第二种方法，直接edit：

> > > > $ kubectl edit deployment/nginx-deployment

> > > > deployment "nginx-deployment2" edited

> > > 查看Deployment的变更信息（以下信息得以保存，是创建时候加的“--record”这个选项起的作用）：

```

$ kubectl rollout history deployment/nginx-deployment

deployments "nginx-deployment":

REVISION    CHANGE-CAUSE

1           kubectl create -f docs/user-guide/nginx-deployment.yaml --record

2           kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1

3           kubectl set image deployment/nginx-deployment nginx=nginx:1.91

$ kubectl rollout history deployment/nginx-deployment --revision=2

deployments "nginx-deployment" revision 2

  Labels:       app=nginx

          pod-template-hash=1159050644

  Annotations:  kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1

  Containers:

   nginx:

    Image:      nginx:1.9.1

    Port:       80/TCP

     QoS Tier:

        cpu:      BestEffort

        memory:   BestEffort

    Environment Variables:      <none>

  No volumes.

```

> > > 最后介绍下Deployment的一些基础命令。

> > > > $ kubectl describe deployments  #查询详细信息，获取升级进度

> > > > $ kubectl rollout pause deployment/nginx-deployment2  #暂停升级

> > > > $ kubectl rollout resume deployment/nginx-deployment2  #继续升级

> > > > $ kubectl rollout undo deployment/nginx-deployment2  #升级回滚

> > > > $ kubectl scale deployment nginx-deployment --replicas 10  #弹性伸缩Pod数量

> > > 关于多重升级，举例，当你创建了一个nginx1.7的Deployment，要求副本数量为5之后，Deployment Controller会逐步的将5个1.7的Pod启动起来；当启动到3个的时候，你又发出更新Deployment中Nginx到1.9的命令；这时Deployment Controller会立即将已启动的3个1.7Pod杀掉，然后逐步启动1.9的Pod。Deployment Controller不会等到1.7的Pod都启动完成之后，再依次杀掉1.7，启动1.9。

 

> Volume

> > 在Docker的设计实现中，容器中的数据是临时的，即当容器被销毁时，其中的数据将会丢失。如果需要持久化数据，需要使用Docker数据卷挂载宿主机上的文件或者目录到容器中。在Kubernetes中，当Pod重建的时候，数据是会丢失的，Kubernetes也是通过数据卷挂载来提供Pod数据的持久化的。Kubernetes数据卷是对Docker数据卷的扩展，Kubernetes数据卷是Pod级别的，可以用来实现Pod中容器的文件共享。目前，Kubernetes支持的数据卷类型如下：

> > > 1)        EmptyDir

> > > 2)        HostPath

> > > 3)        GCE Persistent Disk

> > > 4)        AWS Elastic Block Store

> > > 5)        NFS

> > > 6)        iSCSI

> > > 7)        Flocker

> > > 8)        GlusterFS

> > > 9)        RBD

> > > 10)    Git Repo

> > > 11)    Secret

> > > 12)    Persistent Volume Claim

> > > 13)    Downward API

> > 本地数据卷

> > > EmptyDir、HostPath这两种类型的数据卷，只能最用于本地文件系统。本地数据卷中的数据只会存在于一台机器上，所以当Pod发生迁移的时候，数据便会丢失。该类型Volume的用途是：Pod中容器间的文件共享、共享宿主机的文件系统。

> > > EmptyDir

> > > 如果Pod配置了EmpyDir数据卷，在Pod的生命周期内都会存在，当Pod被分配到 Node上的时候，会在Node上创建EmptyDir数据卷，并挂载到Pod的容器中。只要Pod 存在，EmpyDir数据卷都会存在（容器删除不会导致EmpyDir数据卷丟失数据），但是如果Pod的生命周期终结（Pod被删除），EmpyDir数据卷也会被删除，并且永久丢失。

> > > EmpyDir数据卷非常适合实现Pod中容器的文件共享。Pod的设计提供了一个很好的容器组合的模型，容器之间各司其职，通过共享文件目录来完成交互，比如可以通过一个专职日志收集容器，在每个Pod中和业务容器中进行组合，来完成日志的收集和汇总。

> > > HostPath

> > > HostPath数据卷允许将容器宿主机上的文件系统挂载到Pod中。如果Pod需要使用宿主机上的某些文件，可以使用HostPath。

> > 网络数据卷

> > > Kubernetes提供了很多类型的数据卷以集成第三方的存储系统，包括一些非常流行的分布式文件系统，也有在IaaS平台上提供的存储支持，这些存储系统都是分布式的，通过网络共享文件系统，因此我们称这一类数据卷为网络数据卷。

> > > 网络数据卷能够满足数据的持久化需求，Pod通过配置使用网络数据卷，每次Pod创建的时候都会将存储系统的远端文件目录挂载到容器中，数据卷中的数据将被水久保存，即使Pod被删除，只是除去挂载数据卷，数据卷中的数据仍然保存在存储系统中，且当新的Pod被创建的时候，仍是挂载同样的数据卷。网络数据卷包含以下几种：NFS、iSCISI、GlusterFS、RBD（Ceph Block Device）、Flocker、AWS Elastic Block Store、GCE Persistent Disk

> > Persistent Volume和Persistent Volume Claim

> > > 理解每个存储系统是一件复杂的事情，特别是对于普通用户来说，有时候并不需要关心各种存储实现，只希望能够安全可靠地存储数据。Kubernetes中提供了Persistent Volume和Persistent Volume Claim机制，这是存储消费模式。Persistent Volume是由系统管理员配置创建的一个数据卷（目前支持HostPath、GCE Persistent Disk、AWS Elastic Block Store、NFS、iSCSI、GlusterFS、RBD），它代表了某一类存储插件实现；而对于普通用户来说，通过Persistent Volume Claim可请求并获得合适的Persistent Volume，而无须感知后端的存储实现。Persistent Volume和Persistent Volume Claim的关系其实类似于Pod和Node，Pod消费Node资源，Persistent Volume Claim则消费Persistent Volume资源。Persistent Volume和Persistent Volume Claim相互关联，有着完整的生命周期管理：

> > > 1)        准备：系统管理员规划或创建一批Persistent Volume；

> > > 2)        绑定：用户通过创建Persistent Volume Claim来声明存储请求，Kubernetes发现有存储请求的时候，就去查找符合条件的Persistent Volume（最小满足策略）。找到合适的就绑定上，找不到就一直处于等待状态；

> > > 3)        使用：创建Pod的时候使用Persistent Volume Claim；

> > > 4)        释放：当用户删除绑定在Persistent Volume上的Persistent Volume Claim时，Persistent Volume进入释放状态，此时Persistent Volume中还残留着上一个Persistent Volume Claim的数据，状态还不可用；

> > > 5)        回收：是否的Persistent Volume需要回收才能再次使用。回收策略可以是人工的也可以是Kubernetes自动进行清理（仅支持NFS和HostPath）

> > 信息数据卷

　　

> > >Kubernetes中有一些数据卷，主要用来给容器传递配置信息，我们称之为信息数据卷，比如Secret（处理敏感配置信息，密码、Token等）、Downward API（通过环境变量的方式告诉容器Pod的信息）、Git Repo（将Git仓库下载到Pod中），都是将Pod的信息以文件形式保存，然后以数据卷方式挂载到容器中，容器通过读取文件获取相应的信息。

> Pet Sets/StatefulSet

> > K8s在1.3版本里发布了Alpha版的PetSet功能。在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、宠物（pet）、有名（having name）、不可丢弃（non-disposable）。RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了、名字和启动在哪儿都不重要，重要的只是Pod总数；而PetSet是用来控制有状态服务，PetSet中的每个Pod的名字都是事先确定的，不能更改。PetSet中Pod的名字的作用，是用来关联与该Pod对应的状态。

> > 对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别；对于PetSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂在上原来Pod的存储继续以它的状态提供服务。

> > 适合于PetSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务Zookeeper、etcd等有状态服务。PetSet的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。使用PetSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，PetSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。

> ConfigMap

> > 很多生产环境中的应用程序配置较为复杂，可能需要多个config文件、命令行参数和环境变量的组合。并且，这些配置信息应该从应用程序镜像中解耦出来，以保证镜像的可移植性以及配置信息不被泄露。社区引入ConfigMap这个API资源来满足这一需求。

> > ConfigMap包含了一系列的键值对，用于存储被Pod或者系统组件（如controller）访问的信息。这与secret的设计理念有异曲同工之妙，它们的主要区别在于ConfigMap通常不用于存储敏感信息，而只存储简单的文本信息。

> Horizontal Pod Autoscaler

> > 自动扩展作为一个长久的议题，一直为人们津津乐道。系统能够根据负载的变化对计算资源的分配进行自动的扩增或者收缩，无疑是一个非常吸引人的特征，它能够最大可能地减少费用或者其他代价（如电力损耗）。自动扩展主要分为两种，其一为水平扩展，针对于实例数目的增减；其二为垂直扩展，即单个实例可以使用的资源的增减。Horizontal Pod Autoscaler（HPA）属于前者。

> > Horizontal Pod Autoscaler如何工作

> > > Horizontal Pod Autoscaler的操作对象是Replication Controller、ReplicaSet或Deployment对应的Pod，根据观察到的CPU实际使用量与用户的期望值进行比对，做出是否需要增减实例数量的决策。controller目前使用heapSter来检测CPU使用量，检测周期默认是30秒。

> > Horizontal Pod Autoscaler的决策策略

> > > 在HPA Controller检测到CPU的实际使用量之后，会求出当前的CPU使用率（实际使用量与pod 请求量的比率)。然后，HPA Controller会通过调整副本数量使得CPU使用率尽量向期望值靠近．另外，考虑到自动扩展的决策可能需要一段时间才会生效，甚至在短时间内会引入一些噪声． 例如当pod所需要的CPU负荷过大，从而运行一个新的pod进行分流，在创建的过程中，系统的CPU使用量可能会有一个攀升的过程。所以，在每一次作出决策后的一段时间内，将不再进行扩展决策。对于ScaleUp而言，这个时间段为3分钟，Scaledown为5分钟。再者HPA Controller允许一定范围内的CPU使用量的不稳定，也就是说，只有当aVg（CurrentPodConsumption／Target低于0.9或者高于1.1时才进行实例调整，这也是出于维护系统稳定性的考虑。

#### kubernetes 集群搭建(kubeadm 方式)

2.搭建K8s集群--->kubeadm

2.1环境准备

2.1.1关闭防火墙

2.1.2关闭seliux

2.1.3关闭swap分区

2.1.4设置主机名称

2.1.5将桥接的IPv4流量传递到iptables的链

2.1.6时间同步

2.2三台虚拟机都安装Docker

2.3添加阿里云YUM软件源

2.4安装/kubeadm/kubelet

2.5部署Kubernetes Master

2.6加入Kubernetes Node

2.7 部署CNI网络插件

2.8 测试kubernetes集群

> 目前生产部署 Kubernetes 集群主要有两种方式：

（1）kubeadm

Kubeadm 是一个K8s 部署工具，提供kubeadm init和 kubeadm join，用于快速部署 Kubernetes 集群。官方地址

（2）二进制包

从 github 下载发行版的二进制包，手动部署每个组件，组成 Kubernetes 集群。

Kubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可

控，推荐使用二进制包部署 Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很

多工作原理，也利于后期维护。

kubeadm 部署方式介绍

kubeadm 是官方社区推出的一个用于快速部署 kubernetes 集群的工具，这个工具能通过两条指令完成一个 kubernetes 集群的部署：

第一、创建一个 Master 节点 kubeadm init

第二， 将 Node节点加入到当前集群中 $ kubeadm join <Master 节点的 IP 和端口 >

安装要求

在开始之前，部署 Kubernetes 集群机器需要满足以下几个条件：

一台或多台机器，操作系统 CentOS7.x-86_x64

硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 30GB 或更多

集群中所有机器之间网络互通

可以访问外网，需要拉取镜像

禁止 swap 分区

最终目标

角色	IP

k8s-master	192.168.31.61

k8s-node1	192.168.31.62

k8s-node2	192.168.31.63

> 系统初始化

> > 关闭防火墙：

```

$ systemctl stop firewalld

$ systemctl disable firewalld

```

> > 关闭 selinux：

```

$ sed -i 's/enforcing/disabled/' /etc/selinux/config # 永久

$ setenforce 0 # 临时

```

> > swap：

```

$ swapoff -a # 临时

$ vim /etc/fstab # 永久

```

> > 主机名：

```

$ hostnamectl set-hostname <hostname>

```

> > 在 master 添加 hosts：

```

$ cat >> /etc/hosts << EOF

192.168.31.61 k8s-master

192.168.31.62 k8s-node1

192.168.31.63 k8s-node2

EOF

```

> > 将桥接的 IPv4 流量传递到 iptables 的链：

```

$ cat > /etc/sysctl.d/k8s.conf << EOF

net.bridge.bridge-nf-call-ip6tables = 1

net.bridge.bridge-nf-call-iptables = 1

EOF

$ sysctl --system # 生效

```

> > 时间同步：

```

$ yum install ntpdate -y

$ ntpdate time.windows.com

```

> 所有节点安装 Docker/kubeadm/kubelet

> > Kubernetes 默认 CRI（容器运行时）为 Docker，因此先安装 Docker。

> > （1）安装 Docker

```

$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo

$ yum -y install docker-ce-18.06.1.ce-3.el7

$ systemctl enable docker && systemctl start docker

$ docker --version

```

> > 添加阿里云 YUM 软件源

> > 设置仓库地址

```

$ cat > /etc/docker/daemon.json << EOF

{

"registry-mirrors": ["https://b9pmyelo.mirror.aliyuncs.com"]

}

EOF

```

> > 添加 yum 源

```

$ cat > /etc/yum.repos.d/kubernetes.repo << EOF

[kubernetes]

name=Kubernetes

baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64

enabled=1

gpgcheck=0

repo_gpgcheck=0

gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg

https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg

EOF

```

> > 安装 kubeadm，kubelet 和 kubectl

```

$ yum install -y kubelet kubeadm kubectl

$ systemctl enable kubelet

```

> 部署 Kubernetes Master

> > 在 192.168.31.61（Master）执行

```

$ kubeadm init \

--apiserver-advertise-address=192.168.31.61 \

--image-repository registry.aliyuncs.com/google_containers \

--kubernetes-version v1.17.0 \

--service-cidr=10.96.0.0/12 \

--pod-network-cidr=10.244.0.0/16

```

> > 由于默认拉取镜像地址 k8s.gcr.io 国内无法访问，这里指定阿里云镜像仓库地址。

> > 使用 kubectl 工具：

```

mkdir -p $HOME/.kube

sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config

sudo chown $(id -u):$(id -g) $HOME/.kube/config

$ kubectl get nodes

```

> 安装 Pod 网络插件（CNI）

```

$ kubectl apply –f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kubeflannel.yml

```

> > 检查一下

```

kubect1 get pods -n kube-system

```

> > 确保能够访问到 quay.io 这个 registery。如果 Pod 镜像下载失败，可以改这个镜像地址

> 加入 Kubernetes Node

> > 在 192.168.31.62/63（Node）执行

> > 向集群添加新节点，执行在 kubeadm init 输出的 kubeadm join 命令：

```

$ kubeadm join 192.168.31.61:6443 --token esce21.q6hetwm8si29qxwn \

--discovery-token-ca-cert-hash

sha256:00603a05805807501d7181c3d60b478788408cfe6cedefedb1f97569708be9c5

```

> 测试 kubernetes 集群

> > 在 Kubernetes 集群中创建一个 pod，验证是否正常运行：

```

$ kubectl create deployment nginx --image=nginx

$ kubectl expose deployment nginx --port=80 --type=NodePort

$ kubectl get pod,svc

```

> > 访问地址：http://NodeIP:Port

#### 安装方法二

> 安装三台虚拟机，centos7

> 对三台操作系统进行初始化

> > 关闭防火墙

```

systemctl status firewalld //查看防火墙状态

systemctl stop firewalld //关闭防火墙

systemctl disable firewalld //开机不启动防火墙

```

> > 关闭seliux

```

 getenforce

 sed -ri 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config

```

> > 关闭swap分区

```

swapoff -a # 临时关闭

sed -ri 's/.*swap.*/#&/' /etc/fstab    # 永久

```

> > 设置主机名称

> > > 根据规划设置主机名

```

hostnamectl set-hostname <hostname>

```

> > > 在master添加hosts

```

cat >> /etc/hosts << EOF

192.168.26.128 k8smaster

192.168.26.129 k8snode1

192.168.26.130 k8snode2

EOF

```

> > 将桥接的IPv4流量传递到iptables的链

```

cat > /etc/sysctl.d/k8s.conf << EOF

net.bridge.bridge-nf-call-ip6tables = 1

net.bridge.bridge-nf-call-iptables = 1

EOF

sysctl --system  # 生效

```

> > 时间同步

```

yum install ntpdate -y

ntpdate time.windows.com

```

> 三台虚拟机都安装Docker

```

yum -y install wget

$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo

$ yum -y install docker-ce-18.06.1.ce-3.el7

$ systemctl enable docker && systemctl start docker

$ docker --version

Docker version 18.06.1-ce, build e68fc7a

$ cat > /etc/docker/daemon.json << EOF

{

  "registry-mirrors": ["https://b9pmyelo.mirror.aliyuncs.com"]

}

EOF

systemctl restart docker

```

> 添加阿里云YUM软件源

```

$ cat > /etc/yum.repos.d/kubernetes.repo << EOF

[kubernetes]

name=Kubernetes

baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64

enabled=1

gpgcheck=0

repo_gpgcheck=0

gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg

EOF

```

> 安装/kubeadm/kubelet

> > 由于版本更新频繁，这里指定版本号部署：

```

$ yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0

$ systemctl enable kubelet

```

> 部署Kubernetes Master

> > 在192.168.26.128（Master）执行。

```

$ kubeadm init \

  --apiserver-advertise-address=192.168.26.128 \

  --image-repository registry.aliyuncs.com/google_containers \

  --kubernetes-version v1.18.0 \

  --service-cidr=10.96.0.0/12 \

  --pod-network-cidr=10.244.0.0/16

```

> > 执行慢，稍作等待

> > 由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。

> > 使用kubectl工具：

```

mkdir -p $HOME/.kube

sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config

sudo chown $(id -u):$(id -g) $HOME/.kube/config

$ kubectl get nodes

```

> 加入Kubernetes Node

> > 在（Node）服务器执行。

> > 向集群添加新节点，执行在kubeadm init输出的kubeadm join命令：

```

$ kubeadm join 192.168.1.11:6443 --token esce21.q6hetwm8si29qxwn \

    --discovery-token-ca-cert-hash sha256:00603a05805807501d7181c3d60b478788408cfe6cedefedb1f97569708be9c5

```

> > 默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：

> > kubeadm token create --print-join-command

> 部署CNI网络插件

> > wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

> > 默认镜像地址无法访问，sed命令修改为docker hub镜像仓库。可以换源下载

```

kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

kubectl get pods -n kube-system

NAME                          READY   STATUS    RESTARTS   AGE

kube-flannel-ds-amd64-2pc95   1/1     Running   0          72s

```

> 测试kubernetes集群

> > 在Kubernetes集群中创建一个pod，验证是否正常运行：

```

$ kubectl create deployment nginx --image=nginx

$ kubectl expose deployment nginx --port=80 --type=NodePort

$ kubectl get pod,svc

```

> > 访问地址：http://NodeIP:Port

```

http://192.168.26.128:30340/

```

#### kubernetes 集群搭建（二进制）

> 安装要求

> 准备环境、操作系统初始化

> 为etcd和apiserver准备自签证书（△）

> > 准备 cfssl 证书生成工具

> > > cfssl 是一个开源的证书管理工具， 使用 json 文件生成证书， 相比 openssl 更方便使用。找任意一台服务器操作， 这里用 Master 节点。

```

wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64

wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64

wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64

chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64

mv cfssl_linux-amd64 /usr/local/bin/cfssl

mv cfssljson_linux-amd64 /usr/local/bin/cfssljson

mv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo

```

> > 生成 Etcd 证书

> > > 自签证书颁发机构（ CA）

> > > 创建工作目录：

```

mkdir -p ~/TLS/{etcd,k8s}

cd TLS/etcd

```

> > > 自签 CA：

```

cat > ca-config.json<< EOF

	{

	"signing": {

	"default": {

		"expiry": "87600h"

	},

	"profiles": {

	"www": {

		"expiry": "87600h",

		"usages": [

			"signing",

			"key encipherment",

			"server auth",

			"client auth"

		]

	}

	}

}

} EOF

cat > ca-csr.json<< EOF

{

	"CN": "etcd CA",

	"key": {

	"algo": "rsa",

	"size": 2048

	},

	"names": [

		{

		"C": "CN",

		"L": "Beijing",

		"ST": "Beijing"

		}

	]

} EOF

```

> > > 生成证书：

```

cfssl gencert -initca ca-csr.json | cfssljson -bare ca -

ls *pem

ca-key.pem ca.pem

```

> > > 使用自签 CA 签发 Etcd HTTPS 证书

> > > 创建证书申请文件：

```

cat > server-csr.json<< EOF

{

	"CN": "etcd",

	"hosts": [

		"192.168.31.71",

		"192.168.31.72",

		"192.168.31.73"

	],

	"key": {

		"algo": "rsa",

		"size": 2048

	},

	"names": [

		{

			"C": "CN",

			"L": "BeiJing",

			"ST": "BeiJing"

		}

	]

} EOF

```

> > > 注： 上述文件 hosts 字段中 IP 为所有 etcd 节点的集群内部通信 IP， 一个都不能少！ 为了方便后期扩容可以多写几个预留的 IP。

> > > 生成证书：

```

cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -

profile=www server-csr.json | cfssljson -bare server

ls server*pem

server-key.pem server.pem

```

> > 从 Github 下载二进制文件

> > > 下载地址： https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz

> 部署Etcd集群（△）

> > Etcd 是一个分布式键值存储系统， Kubernetes 使用 Etcd 进行数据存储， 所以先准备一个 Etcd 数据库， 为解决 Etcd 单点故障， 应采用集群方式部署， 这里使用 3 台组建集群， 可容忍 1 台机器故障， 当然， 你也可以使用 5 台组建集群， 可容忍 2 台机器故障。

> > > 创建工作目录并解压二进制包

```

mkdir /opt/etcd/{bin,cfg,ssl} – p

tar zxvf etcd-v3.4.9-linux-amd64.tar.gz

mv etcd-v3.4.9-linux-amd64/{etcd,etcdctl} /opt/etcd/bin/

```

> > > 创建 etcd 配置文件

```

cat > /opt/etcd/cfg/etcd.conf << EOF

#[Member]

	ETCD_NAME="etcd-1"

	ETCD_DATA_DIR="/var/lib/etcd/default.etcd"

	ETCD_LISTEN_PEER_URLS="https://192.168.31.71:2380"

	ETCD_LISTEN_CLIENT_URLS="https://192.168.31.71:2379"

	#[Clustering]

	ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.31.71:2380"

	ETCD_ADVERTISE_CLIENT_URLS="https://192.168.31.71:2379"

	ETCD_INITIAL_CLUSTER="etcd-1=https://192.168.31.71:2380,etcd-

	2=https://192.168.31.72:2380,etcd-3=https://192.168.31.73:2380"

	ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"

	ETCD_INITIAL_CLUSTER_STATE="new"

EOF

ETCD_NAME： 节点名称， 集群中唯一

ETCD_DATA_DIR： 数据目录

ETCD_LISTEN_PEER_URLS： 集群通信监听地址

ETCD_LISTEN_CLIENT_URLS： 客户端访问监听地址

ETCD_INITIAL_ADVERTISE_PEER_URLS： 集群通告地址

ETCD_ADVERTISE_CLIENT_URLS： 客户端通告地址

ETCD_INITIAL_CLUSTER： 集群节点地址

ETCD_INITIAL_CLUSTER_TOKEN： 集群 Token

ETCD_INITIAL_CLUSTER_STATE： 加入集群的当前状态， new 是新集群， existing 表示加入已有集群

```

> > > systemd 管理 etcd

```

cat > /usr/lib/systemd/system/etcd.service << EOF

[Unit]

	Description=Etcd Server

	After=network.target

	After=network-online.target

	Wants=network-online.target

	[Service]

	Type=notify

	EnvironmentFile=/opt/etcd/cfg/etcd.conf

	ExecStart=/opt/etcd/bin/etcd \

	--cert-file=/opt/etcd/ssl/server.pem \

	--key-file=/opt/etcd/ssl/server-key.pem \

	--peer-cert-file=/opt/etcd/ssl/server.pem \

	--peer-key-file=/opt/etcd/ssl/server-key.pem \

	--trusted-ca-file=/opt/etcd/ssl/ca.pem \

	--peer-trusted-ca-file=/opt/etcd/ssl/ca.pem \

	--logger=zap

	Restart=on-failure

	LimitNOFILE=65536

	[Install]

	WantedBy=multi-user.target

EOF

```

> > > 拷贝刚才生成的证书把刚才生成的证书拷贝到配置文件中的路径：

```

cp ~/TLS/etcd/ca*pem ~/TLS/etcd/server*pem /opt/etcd/ssl/

```

> > > 启动并设置开机启动

```

systemctl daemon-reload

systemctl start etcd

systemctl enable etcd

```

> > > 将上面节点 1 所有生成的文件拷贝到节点 2 和节点 3

```

scp -r /opt/etcd/ root@192.168.31.72:/opt/

scp /usr/lib/systemd/system/etcd.service

root@192.168.31.72:/usr/lib/systemd/system/

scp -r /opt/etcd/ root@192.168.31.73:/opt/

scp /usr/lib/systemd/system/etcd.service

root@192.168.31.73:/usr/lib/systemd/system/

```

> > > 然后在节点 2 和节点 3 分别修改 etcd.conf 配置文件中的节点名称和当前服务器 IP：

```

vi /opt/etcd/cfg/etcd.conf

#[Member]

ETCD_NAME="etcd-1" # 修改此处， 节点 2 改为 etcd-2， 节点 3 改为 etcd-3

ETCD_DATA_DIR="/var/lib/etcd/default.etcd"

ETCD_LISTEN_PEER_URLS="https://192.168.31.71:2380" # 修改此处为当前服务器 IP

ETCD_LISTEN_CLIENT_URLS="https://192.168.31.71:2379" # 修改此处为当前服务器 IP

#[Clustering]

ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.31.71:2380" # 修改此处为当前

服务器 IP

ETCD_ADVERTISE_CLIENT_URLS="https://192.168.31.71:2379" # 修改此处为当前服务器

IP

ETCD_INITIAL_CLUSTER="etcd-1=https://192.168.31.71:2380,etcd-

2=https://192.168.31.72:2380,etcd-3=https://192.168.31.73:2380"

ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"

ETCD_INITIAL_CLUSTER_STATE="new"

```

> > > 最后启动 etcd 并设置开机启动， 同上。

> > > 查看集群状态

```

ETCDCTL_API=3 /opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem --

cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --

endpoints="https://192.168.31.71:2379,https://192.168.31.72:2379,https://192.16

8.31.73:2379" endpoint health

https://192.168.31.71:2379 is healthy: successfully committed proposal: took =

8.154404ms

https://192.168.31.73:2379 is healthy: successfully committed proposal: took =

9.044117ms

https://192.168.31.72:2379 is healthy: successfully committed proposal: took =

10.000825ms

```

> > > 如果输出上面信息， 就说明集群部署成功。 如果有问题第一步先看日志：

```

/var/log/message 或 journalctl -u etcd

```

> 安装Docker

> > systemd 管理 docker

```

cat > /usr/lib/systemd/system/docker.service << EOF

[Unit]

Description=Docker Application Container Engine

Documentation=https://docs.docker.com

After=network-online.target firewalld.service

Wants=network-online.target

[Service]

Type=notify

ExecStart=/usr/bin/dockerd

ExecReload=/bin/kill -s HUP $MAINPID

LimitNOFILE=infinity

LimitNPROC=infinity

LimitCORE=infinity

TimeoutStartSec=0

Delegate=yes

KillMode=process

Restart=on-failure

StartLimitBurst=3

StartLimitInterval=60s

[Install]

WantedBy=multi-user.target

EOF

```

> > 创建配置文件

```

mkdir /etc/docker

cat > /etc/docker/daemon.json << EOF

{"registry-mirrors": ["https://b9pmyelo.mirror.aliyuncs.com"]

} EOF

```

> > > registry-mirrors 阿里云镜像加速器

> 部署Master Node

> 部署Worker Node

> 部署集群网络

#### kubernetes 集群 YAML 文件详解

1、YAML 文件概述

k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，也就是可以把需要对资源对象操作编辑到 YAML 格式文件中，我们把这种文件叫做资源清单文件，通过 kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。

3、资源清单描述方法

（1）在 k8s 中，一般使用 YAML 格式的文件来创建符合我们预期期望的 pod,这样的 YAML文件称为资源清单。

必须存在的属性（必须写）

参数名	字段类型	说明	默认值

apiVersion	String	这里是指的是K8S API的版本，目前基本上是v1，可以用 kubectl api-versions 或者 kubectl explain pod 命令查询	

kind	String	这里指的是yaml文件定义的资源类型和角色，比如: Pod	

metadata	Object	元数据对象，固定值就写metadata	

metadata.name	String	元数据对象的名字，这里由我们编写，比如命名Pod的名字	

metadata.namespace	String	元数据对象的命名空间，由我们自身定义	default

metadata.labels	map[string]string	键值数据，常被用作挑选条件	

spec	Object 详细定义对象，固定值就写Spec		

spec.containers[]		List	这里是Spec对象的容器列表定义，是个列表

spec.containers[].name	String	这里定义容器的名字	

spec.containers[].image	String	这里定义要用到的镜像名称，如果镜像的标签是 latest，每次使用该镜像都会从远程下载	

## 结构化程序设计

## 面向对象程序设计

### 面向对象设计原则

#### 1、单一职责原则 SRP

> （Single Responsibility Principle）

> 一个类，只有一个引起它变化的原因。

> 应该只有一个职责。

> 每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。

> 这会导致脆弱的设计。

> 当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。

#### 2、开闭原则 OCP

> （Open Close Principle）

> 开闭原则就是说对扩展开放，对修改关闭。

> 在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。

> 所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。

> 想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

#### 3、里氏代换原则 LSP

> （Liskov Substitution Principle）

> 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。

> 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。

> LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，

> 而衍生类也能够在基类的基础上增加新的行为。

> 里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。

> 而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

#### 4、依赖倒转原则 DIP

> （Dependence Inversion Principle）

> 所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。

> 实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，

> 如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。

#### 5、接口隔离原则 ISP

> （Interface Segregation Principle）

> 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。

> 还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，

> 从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

#### 6、合成复用原则 CRP

> （Composite Reuse Principle）

> 合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；

> 新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。

#### 7、迪米特法则（最少知道原则）DP

> （Demeter Principle）

> 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

> 也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。

> 这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。

## Gof设计模式

> GoF:（Gang of Four，GOF设计模式）---四人组

> Design Patterns: Elements of Reusable Object-Oriented Software（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John 

> Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为“四人组（Gang of Four）”，而这本书也就被称为“四人组（或 GoF）”书。

### 行为型

#### Iterator（迭代器模式）

> Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。

#### Interpreter（解析器模式）

> Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。

#### Observer（观察者模式）

> Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。

#### Mediator（中介者模式）

> Mediator（中介者模式）：用一个中介对象来封装一系列的对象交互。

> 中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

#### Visitor（访问者模式）

> Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

#### Memento（备忘录模式）

> Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。

#### State（状态模式）

> State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。

#### Strategy（策略模式）

> Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。

#### Template Method（模板方法模式）

> Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

> Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

#### Command（命令模式）

> Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。

#### Chain of Responsibility（职责链模式）

> Chain of Responsibility（职责链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

### 创建型

#### Singleton（单例模式）

> Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

#### Prototype（原型模式）

> Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 

#### Builder（建造者模式）

> Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

#### Factory Method(工厂模式)

> Factory Method(工厂模式)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。 Factory Method使一个类的实例化延迟到其子类

####  Abstract Factory（抽象工厂模式）

> Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

### 结构型

#### Bridge（桥接模式）

> Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

#### Facade（外观模式）

> Facade（外观模式）：为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

#### Composite(组合模式)

> Composite(组合模式)：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。

#### Decorator(装饰模式)：

> Decorator(装饰模式)：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。

#### Adapter（适配器模式）

> Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

#### Proxy（代理模式）

> Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。

#### Flyweight（享元模式）

> Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。

### 模式之间关系

### 其他

### 参考资料

#### 23种设计模式UML图

## C# .Net Base 

### CLR基础 CLR的执行模型

### 生成、打包、部署和管理应用程序及类型

### 共享程序集和强命名程序集

### 类型基础

### 基元类型、引用类型和值类型

### 常量和字段

### 方法

### 参数

### 属性

### 事件

### 泛型

### 接口

### 基本类型

### 字符、字符串和文本处理

### 枚举类型和位标志

### 数组

### 委托

### 定制特性

### 可空值类型

### 异常和状态管理

### 托管堆和垃圾回收

### CLR寄宿和AppDomain

### 程序集加载和反射

### 运行时序列化

### 与WinRT组件互操作

### 线程基础

### 计算的异步操作 Task

### I/O的异步操作

### 基元线程同步构造

### 混合线程同步构造

### ML.NET

> 微软人工智能学习

## WPF

### WPF控件继承

#### UIElement

> 其中定义很多与输入和焦点有关的特性，例如键盘事件，鼠标，还包括一些与WPF事件模型有关的API。

##### 方法: METHODS

> AddHandler(RoutedEvent, Delegate)	

Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.

> AddHandler(RoutedEvent, Delegate, Boolean)	

Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element. Specify handledEventsToo as true to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.

> AddToEventRoute(EventRoute, RoutedEventArgs)	

Adds handlers to the specified EventRoute for the current UIElement event handler collection.

> AddVisualChild(Visual)	

Defines the parent-child relationship between two visuals.

> ApplyAnimationClock(DependencyProperty, AnimationClock)	(Inherited from Visual)

Applies an animation to a specified dependency property on this element. Any existing animations are stopped and replaced with the new animation.

> ApplyAnimationClock(DependencyProperty, AnimationClock, HandoffBehavior)	

Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.

> Arrange(Rect)	

Positions child elements and determines a size for a UIElement. Parent elements call this method from their ArrangeCore(Rect) implementation (or a WPF framework-level equivalent) to form a recursive layout update. This method constitutes the second pass of a layout update.

> ArrangeCore(Rect)	

Defines the template for WPF core-level arrange layout definition.

> BeginAnimation(DependencyProperty, AnimationTimeline)	

Starts an animation for a specified animated property on this element.

> BeginAnimation(DependencyProperty, AnimationTimeline, HandoffBehavior)	

Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.

> CaptureMouse()	

Attempts to force capture of the mouse to this element.

> CaptureStylus()	

Attempts to force capture of the stylus to this element.

> CaptureTouch(TouchDevice)	

Attempts to force capture of a touch to this element.

> CheckAccess()	

Determines whether the calling thread has access to this DispatcherObject.(Inherited from DispatcherObject)

> ClearValue(DependencyProperty)	

Clears the local value of a property. The prope

rty to be cleared is specified by a DependencyProperty identifier.

> ClearValue(DependencyPropertyKey)		(Inherited from DependencyObject)

Clears the local value of a read-only property. The property to be cleared is specified by a DependencyPropertyKey.

> CoerceValue(DependencyProperty)		(Inherited from DependencyObject)

Coerces the value of the specified dependency property. This is accomplished by invoking any CoerceValueCallback function specified in property metadata for the dependency property as it exists on the calling DependencyObject.

> Equals(Object)		(Inherited from DependencyObject)

Determines whether a provided DependencyObject is equivalent to the current DependencyObject.

> FindCommonVisualAncestor(DependencyObject)		(Inherited from DependencyObject)

Returns the common ancestor of two visual objects.

> Focus()	(Inherited from Visual)

Attempts to set focus to this element.

> GetAnimationBaseValue(DependencyProperty)	

Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.

> GetHashCode()	

Gets a hash code for this DependencyObject.

> GetLayoutClip(Size)		(Inherited from DependencyObject)

Returns an alternative clipping geometry that represents the region that would be clipped if ClipToBounds were set to true.

> GetLocalValueEnumerator()	

Creates a specialized enumerator for determining which dependency properties have locally set values on this DependencyObject.

> GetType()		(Inherited from DependencyObject)

Gets the Type of the current instance.(Inherited from Object)

> GetUIParentCore()	

When overridden in a derived class, returns an alternative user interface (UI) parent for this element if no visual parent exists.

> GetValue(DependencyProperty)	

Returns the current effective value of a dependency property on this instance of a DependencyObject.

> GetVisualChild(Int32)		(Inherited from DependencyObject)

Returns the specified Visual in the parent VisualCollection.

> HitTestCore(GeometryHitTestParameters)	(Inherited from Visual)

Implements HitTestCore(GeometryHitTestParameters) to supply base element hit testing behavior (returning GeometryHitTestResult).

> HitTestCore(PointHitTestParameters)	

Implements HitTestCore(PointHitTestParameters) to supply base element hit testing behavior (returning HitTestResult).

> InputHitTest(Point)	

Returns the input element within the current element that is at the specified coordinates, relative to the current element's origin.

> InvalidateArrange()	

Invalidates the arrange state (layout) for the element. After the invalidation, the element will have its layout updated, which will occur asynchronously unless subsequently forced by UpdateLayout().

> InvalidateMeasure()	

Invalidates the measurement state (layout) for the element.

> InvalidateProperty(DependencyProperty)	

Re-evaluates the effective value for the specified dependency property.

> InvalidateVisual()		(Inherited from DependencyObject)

Invalidates the rendering of the element, and forces a complete new layout pass. OnRender(DrawingContext) is called after the layout cycle is completed.

> IsAncestorOf(DependencyObject)	

Determines whether the visual object is an ancestor of the descendant visual object.

> IsDescendantOf(DependencyObject)	(Inherited from Visual)

Determines whether the visual object is a descendant of the ancestor visual object.

> Measure(Size)	(Inherited from Visual)

Updates the DesiredSize of a UIElement. Parent elements call this method from their own MeasureCore(Size) implementations to form a recursive layout update. Calling this method constitutes the first pass (the "Measure" pass) of a layout update.

> MeasureCore(Size)	

When overridden in a derived class, provides measurement logic for sizing this element properly, with consideration of the size of any child element content.

> MemberwiseClone()	

Creates a shallow copy of the current Object.(Inherited from Object)

> MoveFocus(TraversalRequest)	

Attempts to move focus from this element to another element. The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.

> OnAccessKey(AccessKeyEventArgs)	

Provides class handling for when an access key that is meaningful for this element is invoked.

> OnChildDesiredSizeChanged(UIElement)	

Supports layout behavior when a child element is resized.

> OnCreateAutomationPeer()	

Returns class-specific AutomationPeer implementations for the Windows Presentation Foundation (WPF) infrastructure.

> OnDpiChanged(DpiScale, DpiScale)	

Called when the DPI at which this View is rendered changes.

> OnDragEnter(DragEventArgs)	(Inherited from Visual)

Invoked when an unhandled DragEnter attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnDragLeave(DragEventArgs)	

Invoked when an unhandled DragLeave attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

OnDragOver(DragEventArgs)	

Invoked when an unhandled DragOver attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnDrop(DragEventArgs)	

Invoked when an unhandled DragEnter attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnGiveFeedback(GiveFeedbackEventArgs)	

Invoked when an unhandled GiveFeedback attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnGotFocus(RoutedEventArgs)	

Raises the GotFocus routed event by using the event data provided.

> OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)	

Invoked when an unhandled GotKeyboardFocus attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnGotMouseCapture(MouseEventArgs)	

Invoked when an unhandled GotMouseCapture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnGotStylusCapture(StylusEventArgs)	

Invoked when an unhandled GotStylusCapture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnGotTouchCapture(TouchEventArgs)	

Provides class handling for the GotTouchCapture routed event that occurs when a touch is captured to this element.

> OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsKeyboardFocusedChanged event is raised on this element. Implement this method to add class handling for this event.

> OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)	

Invoked just before the IsKeyboardFocusWithinChanged event is raised by this element. Implement this method to add class handling for this event.

> OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsMouseCapturedChanged event is raised on this element. Implement this method to add class handling for this event.

> OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsMouseCaptureWithinChanged event is raised on this element. Implement this method to add class handling for this event.

> OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsMouseDirectlyOverChanged event is raised on this element. Implement this method to add class handling for this event.

> OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsStylusCapturedChanged event is raised on this element. Implement this method to add class handling for this event.

> OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsStylusCaptureWithinChanged event is raised on this element. Implement this method to add class handling for this event.

> OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsStylusDirectlyOverChanged event is raised on this element. Implement this method to add class handling for this event.

> OnKeyDown(KeyEventArgs)	

Invoked when an unhandled KeyDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnKeyUp(KeyEventArgs)	

Invoked when an unhandled KeyUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnLostFocus(RoutedEventArgs)	

Raises the LostFocus routed event by using the event data that is provided.

> OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)	

Invoked when an unhandled LostKeyboardFocus attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnLostMouseCapture(MouseEventArgs)	

Invoked when an unhandled LostMouseCapture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnLostStylusCapture(StylusEventArgs)	

Invoked when an unhandled LostStylusCapture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnLostTouchCapture(TouchEventArgs)	

Provides class handling for the LostTouchCapture routed event that occurs when this element loses a touch capture.

> OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)	

Called when the ManipulationBoundaryFeedback event occurs.

> OnManipulationCompleted(ManipulationCompletedEventArgs)	

Called when the ManipulationCompleted event occurs.

> OnManipulationDelta(ManipulationDeltaEventArgs)	

Called when the ManipulationDelta event occurs.

> OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs)	

Called when the ManipulationInertiaStarting event occurs.

> OnManipulationStarted(ManipulationStartedEventArgs)	

Called when the ManipulationStarted event occurs.

> OnManipulationStarting(ManipulationStartingEventArgs)	

Provides class handling for the ManipulationStarting routed event that occurs when the manipulation processor is first created.

> OnMouseDown(MouseButtonEventArgs)	

Invoked when an unhandled MouseDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnMouseEnter(MouseEventArgs)	

Invoked when an unhandled MouseEnter attached event is raised on this element. Implement this method to add class handling for this event.

> OnMouseLeave(MouseEventArgs)	

Invoked when an unhandled MouseLeave attached event is raised on this element. Implement this method to add class handling for this event.

> OnMouseLeftButtonDown(MouseButtonEventArgs)	

Invoked when an unhandled MouseLeftButtonDown routed event is raised on this element. Implement this method to add class handling for this event.

> OnMouseLeftButtonUp(MouseButtonEventArgs)	

Invoked when an unhandled MouseLeftButtonUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnMouseMove(MouseEventArgs)	

Invoked when an unhandled MouseMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnMouseRightButtonDown(MouseButtonEventArgs)	

Invoked when an unhandled MouseRightButtonDown routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnMouseRightButtonUp(MouseButtonEventArgs)	

Invoked when an unhandled MouseRightButtonUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnMouseUp(MouseButtonEventArgs)	

Invoked when an unhandled MouseUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnMouseWheel(MouseWheelEventArgs)	

Invoked when an unhandled MouseWheel attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewDragEnter(DragEventArgs)	

Invoked when an unhandled PreviewDragEnter attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewDragLeave(DragEventArgs)	

Invoked when an unhandled PreviewDragLeave attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewDragOver(DragEventArgs)	

Invoked when an unhandled PreviewDragOver attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewDrop(DragEventArgs)	

Invoked when an unhandled PreviewDrop attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewGiveFeedback(GiveFeedbackEventArgs)	

Invoked when an unhandled PreviewGiveFeedback attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)	

Invoked when an unhandled PreviewGotKeyboardFocus attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewKeyDown(KeyEventArgs)	

Invoked when an unhandled PreviewKeyDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewKeyUp(KeyEventArgs)	

Invoked when an unhandled PreviewKeyUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)	

Invoked when an unhandled PreviewKeyDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewMouseDown(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseDown attached routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseLeftButtonDown routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseLeftButtonUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewMouseMove(MouseEventArgs)	

Invoked when an unhandled PreviewMouseMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewMouseRightButtonDown(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseRightButtonDown routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewMouseRightButtonUp(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseRightButtonUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewMouseUp(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewMouseWheel(MouseWheelEventArgs)	

Invoked when an unhandled PreviewMouseWheel attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)	

Invoked when an unhandled PreviewQueryContinueDrag attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewStylusButtonDown(StylusButtonEventArgs)	

Invoked when an unhandled PreviewStylusButtonDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewStylusButtonUp(StylusButtonEventArgs)	

Invoked when an unhandled PreviewStylusButtonUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewStylusDown(StylusDownEventArgs)	

Invoked when an unhandled PreviewStylusDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewStylusInAirMove(StylusEventArgs)	

Invoked when an unhandled PreviewStylusInAirMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewStylusInRange(StylusEventArgs)	

Invoked when an unhandled PreviewStylusInRange attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewStylusMove(StylusEventArgs)	

Invoked when an unhandled PreviewStylusMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewStylusOutOfRange(StylusEventArgs)	

Invoked when an unhandled PreviewStylusOutOfRange attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)	

Invoked when an unhandled PreviewStylusSystemGesture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewStylusUp(StylusEventArgs)	

Invoked when an unhandled PreviewStylusUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewTextInput(TextCompositionEventArgs)	

Invoked when an unhandled PreviewTextInput attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnPreviewTouchDown(TouchEventArgs)	

Provides class handling for the PreviewTouchDown routed event that occurs when a touch presses this element.

> OnPreviewTouchMove(TouchEventArgs)	

Provides class handling for the PreviewTouchMove routed event that occurs when a touch moves while inside this element.

> OnPreviewTouchUp(TouchEventArgs)	

Provides class handling for the PreviewTouchUp routed event that occurs when a touch is released inside this element.

> OnPropertyChanged(DependencyPropertyChangedEventArgs)	

Invoked whenever the effective value of any dependency property on this DependencyObject has been updated. The specific dependency property that changed is reported in the event data.

> OnQueryContinueDrag(QueryContinueDragEventArgs)		(Inherited from DependencyObject)

Invoked when an unhandled QueryContinueDrag attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnQueryCursor(QueryCursorEventArgs)	

Invoked when an unhandled QueryCursor attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnRender(DrawingContext)	

When overridden in a derived class, participates in rendering operations that are directed by the layout system. The rendering instructions for this element are not used directly when this method is invoked, and are instead preserved for later asynchronous use by layout and drawing.

> OnRenderSizeChanged(SizeChangedInfo)	

When overridden in a derived class, participates in rendering operations that are directed by the layout system. This method is invoked after layout update, and before rendering, if the element's RenderSize has changed as a result of layout update.

> OnStylusButtonDown(StylusButtonEventArgs)	

Invoked when an unhandled StylusButtonDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnStylusButtonUp(StylusButtonEventArgs)	

Invoked when an unhandled StylusButtonUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnStylusDown(StylusDownEventArgs)	

Invoked when an unhandled StylusDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnStylusEnter(StylusEventArgs)	

Invoked when an unhandled StylusEnter attached event is raised by this element. Implement this method to add class handling for this event.

> OnStylusInAirMove(StylusEventArgs)	

Invoked when an unhandled StylusInAirMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnStylusInRange(StylusEventArgs)	

Invoked when an unhandled StylusInRange attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnStylusLeave(StylusEventArgs)	

Invoked when an unhandled StylusLeave attached event is raised by this element. Implement this method to add class handling for this event.

> OnStylusMove(StylusEventArgs)	

Invoked when an unhandled StylusMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnStylusOutOfRange(StylusEventArgs)	

Invoked when an unhandled StylusOutOfRange attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnStylusSystemGesture(StylusSystemGestureEventArgs)	

Invoked when an unhandled StylusSystemGesture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnStylusUp(StylusEventArgs)	

Invoked when an unhandled StylusUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnTextInput(TextCompositionEventArgs)	

Invoked when an unhandled TextInput attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.

> OnTouchDown(TouchEventArgs)	

Provides class handling for the TouchDown routed event that occurs when a touch presses inside this element.

> OnTouchEnter(TouchEventArgs)	

Provides class handling for the TouchEnter routed event that occurs when a touch moves from outside to inside the bounds of this element.

> OnTouchLeave(TouchEventArgs)	

Provides class handling for the TouchLeave routed event that occurs when a touch moves from inside to outside the bounds of this UIElement.

> OnTouchMove(TouchEventArgs)	

Provides class handling for the TouchMove routed event that occurs when a touch moves while inside this element.

> OnTouchUp(TouchEventArgs)	

Provides class handling for the TouchUp routed event that occurs when a touch is released inside this element.

> OnVisualChildrenChanged(DependencyObject, DependencyObject)	

Called when the VisualCollection of the visual object is modified.

> OnVisualParentChanged(DependencyObject)	(Inherited from Visual)

Invoked when the parent element of this UIElement reports a change to its underlying visual parent.

> PointFromScreen(Point)	

Converts a Point in screen coordinates into a Point that represents the current coordinate system of the Visual.

> PointToScreen(Point)	(Inherited from Visual)

Converts a Point that represents the current coordinate system of the Visual into a Point in screen coordinates.

> PredictFocus(FocusNavigationDirection)	(Inherited from Visual)

When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.

> RaiseEvent(RoutedEventArgs)	

Raises a specific routed event. The RoutedEvent to be raised is identified within the RoutedEventArgs instance that is provided (as the RoutedEvent property of that event data).

> ReadLocalValue(DependencyProperty)	

Returns the local value of a dependency property, if it exists.

> ReleaseAllTouchCaptures()		(Inherited from DependencyObject)

Releases all captured touch devices from this element.

> ReleaseMouseCapture()	

Releases the mouse capture, if this element held the capture.

> ReleaseStylusCapture()	

Releases the stylus device capture, if this element held the capture.

> ReleaseTouchCapture(TouchDevice)	

Attempts to release the specified touch device from this element.

> RemoveHandler(RoutedEvent, Delegate)	

Removes the specified routed event handler from this element.

> RemoveVisualChild(Visual)	

Removes the parent-child relationship between two visuals.

> SetCurrentValue(DependencyProperty, Object)	(Inherited from Visual)

Sets the value of a dependency property without changing its value source.

> SetValue(DependencyProperty, Object)		(Inherited from DependencyObject)

Sets the local value of a dependency property, specified by its dependency property identifier.

> SetValue(DependencyPropertyKey, Object)		(Inherited from DependencyObject)

Sets the local value of a read-only dependency property, specified by the DependencyPropertyKey identifier of the dependency property.

> ShouldSerializeCommandBindings()		(Inherited from DependencyObject)

Returns whether serialization processes should serialize the contents of the CommandBindings property on instances of this class.

> ShouldSerializeInputBindings()	

Returns whether serialization processes should serialize the contents of the InputBindings property on instances of this class.

> ShouldSerializeProperty(DependencyProperty)	

Returns a value that indicates whether serialization processes should serialize the value for the provided dependency property.

> ToString()		(Inherited from DependencyObject)

Returns a string that represents the current object.(Inherited from Object)

> TransformToAncestor(Visual)	

Returns a transform that can be used to transform coordinates from the Visual to the specified Visual ancestor of the visual object.

> TransformToAncestor(Visual3D)	(Inherited from Visual)

Returns a transform that can be used to transform coordinates from the Visual to the specified Visual3D ancestor of the visual object.

> TransformToDescendant(Visual)	(Inherited from Visual)

Returns a transform that can be used to transform coordinates from the Visual to the specified visual object descendant.

> TransformToVisual(Visual)	(Inherited from Visual)

Returns a transform that can be used to transform coordinates from the Visual to the specified visual object.

> TranslatePoint(Point, UIElement)	(Inherited from Visual)

Translates a point relative to this element to coordinates that are relative to the specified element.

> UpdateLayout()	

Ensures that all visual child elements of this element are properly updated for layout.

> VerifyAccess()	

Enforces that the calling thread has access to this DispatcherObject.(Inherited from DispatcherObject)

##### Events

> DragEnter	

Occurs when the input system reports an underlying drag event with this element as the drag target.

> DragLeave	

Occurs when the input system reports an underlying drag event with this element as the drag origin.

> DragOver	

Occurs when the input system reports an underlying drag event with this element as the potential drop target.

> Drop	

Occurs when the input system reports an underlying drop event with this element as the drop target.

> FocusableChanged	

Occurs when the value of the Focusable property changes.

> GiveFeedback	

Occurs when the input system reports an underlying drag-and-drop event that involves this element.

> GotFocus	

Occurs when this element gets logical focus.

> GotKeyboardFocus	

Occurs when the keyboard is focused on this element.

> GotMouseCapture	

Occurs when this element captures the mouse.

> GotStylusCapture	

Occurs when this element captures the stylus.

> GotTouchCapture	

Occurs when a touch is captured to this element.

> IsEnabledChanged	

Occurs when the value of the IsEnabled property on this element changes.

> IsHitTestVisibleChanged	

Occurs when the value of the IsHitTestVisible dependency property changes on this element.

> IsKeyboardFocusedChanged	

Occurs when the value of the IsKeyboardFocused property changes on this element.

> IsKeyboardFocusWithinChanged	

Occurs when the value of the IsKeyboardFocusWithin property changes on this element.

> IsMouseCapturedChanged	

Occurs when the value of the IsMouseCaptured property changes on this element.

> IsMouseCaptureWithinChanged	

Occurs when the value of the IsMouseCaptureWithinProperty changes on this element.

> IsMouseDirectlyOverChanged	

Occurs when the value of the IsMouseDirectlyOver property changes on this element.

> IsStylusCapturedChanged	

Occurs when the value of the IsStylusCaptured property changes on this element.

> IsStylusCaptureWithinChanged	

Occurs when the value of the IsStylusCaptureWithin property changes on this element.

> IsStylusDirectlyOverChanged	

Occurs when the value of the IsStylusDirectlyOver property changes on this element.

> IsVisibleChanged	

Occurs when the value of the IsVisible property changes on this element.

> KeyDown	

Occurs when a key is pressed while focus is on this element.

> KeyUp	

Occurs when a key is released while focus is on this element.

> LayoutUpdated	

Occurs when the layout of the various visual elements associated with the current Dispatcher changes.

> LostFocus	

Occurs when this element loses logical focus.

> LostKeyboardFocus	

Occurs when the keyboard is no longer focused on this element.

> LostMouseCapture	

Occurs when this element loses mouse capture.

> LostStylusCapture	

Occurs when this element loses stylus capture.

> LostTouchCapture	

Occurs when this element loses a touch capture.

> ManipulationBoundaryFeedback	

Occurs when the manipulation encounters a boundary.

> ManipulationCompleted	

Occurs when a manipulation and inertia on the UIElement object is complete.

> ManipulationDelta	

Occurs when the input device changes position during a manipulation.

> ManipulationInertiaStarting	

Occurs when the input device loses contact with the UIElement object during a manipulation and inertia begins.

> ManipulationStarted	

Occurs when an input device begins a manipulation on the UIElement object.

> ManipulationStarting	

Occurs when the manipulation processor is first created.

> MouseDown	

Occurs when any mouse button is pressed while the pointer is over this element.

> MouseEnter	

Occurs when the mouse pointer enters the bounds of this element.

> MouseLeave	

Occurs when the mouse pointer leaves the bounds of this element.

> MouseLeftButtonDown	

Occurs when the left mouse button is pressed while the mouse pointer is over this element.

> MouseLeftButtonUp	

Occurs when the left mouse button is released while the mouse pointer is over this element.

> MouseMove	

Occurs when the mouse pointer moves while over this element.

> MouseRightButtonDown	

Occurs when the right mouse button is pressed while the mouse pointer is over this element.

> MouseRightButtonUp	

Occurs when the right mouse button is released while the mouse pointer is over this element.

> MouseUp	

Occurs when any mouse button is released over this element.

> MouseWheel	

Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.

> PreviewDragEnter	

Occurs when the input system reports an underlying drag event with this element as the drag target.

> PreviewDragLeave	

Occurs when the input system reports an underlying drag event with this element as the drag origin.

> PreviewDragOver	

Occurs when the input system reports an underlying drag event with this element as the potential drop target.

> PreviewDrop	

Occurs when the input system reports an underlying drop event with this element as the drop target.

> PreviewGiveFeedback	

Occurs when a drag-and-drop operation is started.

> PreviewGotKeyboardFocus	

Occurs when the keyboard is focused on this element.

> PreviewKeyDown	

Occurs when a key is pressed while focus is on this element.

> PreviewKeyUp	

Occurs when a key is released while focus is on this element.

> PreviewLostKeyboardFocus	

Occurs when the keyboard is no longer focused on this element.

> PreviewMouseDown	

Occurs when any mouse button is pressed while the pointer is over this element.

> PreviewMouseLeftButtonDown	

Occurs when the left mouse button is pressed while the mouse pointer is over this element.

> PreviewMouseLeftButtonUp	

Occurs when the left mouse button is released while the mouse pointer is over this element.

> PreviewMouseMove	

Occurs when the mouse pointer moves while the mouse pointer is over this element.

> PreviewMouseRightButtonDown	

Occurs when the right mouse button is pressed while the mouse pointer is over this element.

> PreviewMouseRightButtonUp	

Occurs when the right mouse button is released while the mouse pointer is over this element.

> PreviewMouseUp	

Occurs when any mouse button is released while the mouse pointer is over this element.

> PreviewMouseWheel	

Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.

> PreviewQueryContinueDrag	

Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.

> PreviewStylusButtonDown	

Occurs when the stylus button is pressed while the pointer is over this element.

> PreviewStylusButtonUp	

Occurs when the stylus button is released while the pointer is over this element.

> PreviewStylusDown	

Occurs when the stylus touches the digitizer while it is over this element.

> PreviewStylusInAirMove	

Occurs when the stylus moves over an element without actually touching the digitizer.

> PreviewStylusInRange	

Occurs when the stylus is close enough to the digitizer to be detected, while over this element.

> PreviewStylusMove	

Occurs when the stylus moves while over the element. The stylus must move while being detected by the digitizer to raise this event, otherwise, PreviewStylusInAirMove is raised instead.

> PreviewStylusOutOfRange	

Occurs when the stylus is too far from the digitizer to be detected.

> PreviewStylusSystemGesture	

Occurs when a user performs one of several stylus gestures.

> PreviewStylusUp	

Occurs when the user raises the stylus off the digitizer while the stylus is over this element.

> PreviewTextInput	

Occurs when this element gets text in a device-independent manner.

> PreviewTouchDown	

Occurs when a finger touches the screen while the finger is over this element.

> PreviewTouchMove	

Occurs when a finger moves on the screen while the finger is over this element.

> PreviewTouchUp	

Occurs when a finger is raised off of the screen while the finger is over this element.

> QueryContinueDrag	

Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.

> QueryCursor	

Occurs when the cursor is requested to display. This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.

> StylusButtonDown	

Occurs when the stylus button is pressed while the pointer is over this element.

> StylusButtonUp	

Occurs when the stylus button is released while the pointer is over this element.

> StylusDown	

Occurs when the stylus touches the digitizer while the stylus is over this element.

> StylusEnter	

Occurs when the stylus enters the bounds of this element.

> StylusInAirMove	

Occurs when the stylus moves over an element without actually touching the digitizer.

> StylusInRange	

Occurs when the stylus is close enough to the digitizer to be detected, while over this element.

> StylusLeave	

Occurs when the stylus leaves the bounds of the element.

> StylusMove	

Occurs when the stylus moves over this element. The stylus must move while on the digitizer to raise this event. Otherwise, StylusInAirMove is raised instead.

> StylusOutOfRange	

Occurs when the stylus is too far from the digitizer to be detected, while over this element.

> StylusSystemGesture	

Occurs when a user performs one of several stylus gestures.

> StylusUp	

Occurs when the user raises the stylus off the digitizer while it is over this element.

> TextInput	

Occurs when this element gets text in a device-independent manner.

> TouchDown	

Occurs when a finger touches the screen while the finger is over this element.

> TouchEnter	

Occurs when a touch moves from outside to inside the bounds of this element.

> TouchLeave	

Occurs when a touch moves from inside to outside the bounds of this element.

> TouchMove	

Occurs when a finger moves on the screen while the finger is over this element.

> TouchUp	

Occurs when a finger is raised off of the screen while the finger is over this element.

##### 属性:

> AllowDrop	

Gets or sets a value indicating whether this element can be used as the target of a drag-and-drop operation. This is a dependency property.

> AreAnyTouchesCaptured	

Gets a value that indicates whether at least one touch is captured to this element.

> AreAnyTouchesCapturedWithin	

Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.

> AreAnyTouchesDirectlyOver	

Gets a value that indicates whether at least one touch is pressed over this element.

> AreAnyTouchesOver	

Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.

> BitmapEffect	

Obsolete.

Gets or sets a bitmap effect that applies directly to the rendered content for this element. This is a dependency property.

> BitmapEffectInput	

Obsolete.

Gets or sets an input source for the bitmap effect that applies directly to the rendered content for this element. This is a dependency property.

> CacheMode	

Gets or sets a cached representation of the UIElement.

> Clip	

Gets or sets the geometry used to define the outline of the contents of an element. This is a dependency property.

> ClipToBounds	

Gets or sets a value indicating whether to clip the content of this element (or content coming from the child elements of this element) to fit into the size of the containing element. This is a dependency property.

> CommandBindings	

Gets a collection of CommandBinding objects associated with this element. A CommandBinding enables command handling for this element, and declares the linkage between a command, its events, and the handlers attached by this element.

> DependencyObjectType	

Gets the DependencyObjectType that wraps the CLR type of this instance.

> DesiredSize		(Inherited from DependencyObject)

Gets the size that this element computed during the measure pass of the layout process.

> Dispatcher	

Gets the Dispatcher this DispatcherObject is associated with.(Inherited from DispatcherObject)

> Effect	

Gets or sets the bitmap effect to apply to the UIElement. This is a dependency property.

> Focusable	

Gets or sets a value that indicates whether the element can receive focus. This is a dependency property.

> HasAnimatedProperties	

Gets a value indicating whether this element has any animated properties.

> HasEffectiveKeyboardFocus	

Gets a value that indicates whether the UIElement has focus.

> InputBindings	

Gets the collection of input bindings associated with this element.

> IsArrangeValid	

Gets a value indicating whether the computed size and position of child elements in this element's layout are valid.

> IsEnabled	

Gets or sets a value indicating whether this element is enabled in the user interface (UI). This is a dependency property.

> IsEnabledCore	

Gets a value that becomes the return value of IsEnabled in derived classes.

> IsFocused	

Gets a value that determines whether this element has logical focus. This is a dependency property.

> IsHitTestVisible	

Gets or sets a value that declares whether this element can possibly be returned as a hit test result from some portion of its rendered content. This is a dependency property.

> IsInputMethodEnabled	

Gets a value indicating whether an input method system, such as an Input Method Editor (IME), is enabled for processing the input to this element.

> IsKeyboardFocused	

Gets a value indicating whether this element has keyboard focus. This is a dependency property.

> IsKeyboardFocusWithin	

Gets a value indicating whether keyboard focus is anywhere within the element or its visual tree child elements. This is a dependency property.

> IsManipulationEnabled	

Gets or sets a value that indicates whether manipulation events are enabled on this UIElement.

> IsMeasureValid	

Gets a value indicating whether the current size returned by layout measure is valid.

> IsMouseCaptured	

Gets a value indicating whether the mouse is captured to this element. This is a dependency property.

> IsMouseCaptureWithin	

Gets a value that determines whether mouse capture is held by this element or by child elements in its visual tree. This is a dependency property.

> IsMouseDirectlyOver	

Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account. This is a dependency property.

> IsMouseOver	

Gets a value indicating whether the mouse pointer is located over this element (including child elements in the visual tree). This is a dependency property.

> IsSealed	

Gets a value that indicates whether this instance is currently sealed (read-only).

> IsStylusCaptured		(Inherited from DependencyObject)

Gets a value indicating whether the stylus is captured by this element. This is a dependency property.

> IsStylusCaptureWithin	

Gets a value that determines whether stylus capture is held by this element, or an element within the element bounds and its visual tree. This is a dependency property.

> IsStylusDirectlyOver	

Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account. This is a dependency property.

> IsStylusOver	

Gets a value indicating whether the stylus cursor is located over this element (including visual child elements). This is a dependency property.

> IsVisible	

Gets a value indicating whether this element is visible in the user interface (UI). This is a dependency property.

> Opacity	

Gets or sets the opacity factor applied to the entire UIElement when it is rendered in the user interface (UI). This is a dependency property.

> OpacityMask	

Gets or sets an opacity mask, as a Brush implementation that is applied to any alpha-channel masking for the rendered content of this element. This is a dependency property.

> PersistId	

Obsolete.

Gets a value that uniquely identifies this element.

> RenderSize	

Gets (or sets) the final render size of this element.

> RenderTransform	

Gets or sets transform information that affects the rendering position of this element. This is a dependency property.

> RenderTransformOrigin	

Gets or sets the center point of any possible render transform declared by RenderTransform, relative to the bounds of the element. This is a dependency property.

> SnapsToDevicePixels	

Gets or sets a value that determines whether rendering for this element should use device-specific pixel settings during rendering. This is a dependency property.

> StylusPlugIns	

Gets a collection of all stylus plug-in (customization) objects associated with this element.

> TouchesCaptured	

Gets all touch devices that are captured to this element.

> TouchesCapturedWithin	

Gets all touch devices that are captured to this element or any child elements in its visual tree.

> TouchesDirectlyOver	

Gets all touch devices that are over this element.

> TouchesOver	

Gets all touch devices that are over this element or any child elements in its visual tree.

> Uid	

Gets or sets the unique identifier (for localization) for this element. This is a dependency property.

> Visibility	

Gets or sets the user interface (UI) visibility of this element. This is a dependency property.

> VisualBitmapEffect	

Obsolete.

Gets or sets the BitmapEffect value for the Visual.

> VisualBitmapEffectInput	(Inherited from Visual)

Obsolete.

Gets or sets the BitmapEffectInput value for the Visual.

> VisualBitmapScalingMode	(Inherited from Visual)

Gets or sets the BitmapScalingMode for the Visual.

> VisualCacheMode	(Inherited from Visual)

Gets or sets a cached representation of the Visual.

> VisualChildrenCount	(Inherited from Visual)

Gets the number of child elements for the Visual.

> VisualClearTypeHint	(Inherited from Visual)

Gets or sets the ClearTypeHint that determines how ClearType is rendered in the Visual.

> VisualClip	(Inherited from Visual)

Gets or sets the clip region of the Visual as a Geometry value.

> VisualEdgeMode	(Inherited from Visual)

Gets or sets the edge mode of the Visual as an EdgeMode value.

> VisualEffect	(Inherited from Visual)

Gets or sets the bitmap effect to apply to the Visual.

> VisualOffset	(Inherited from Visual)

Gets or sets the offset value of the visual object.

> VisualOpacity	(Inherited from Visual)

Gets or sets the opacity of the Visual.

> VisualOpacityMask	(Inherited from Visual)

Gets or sets the Brush value that represents the opacity mask of the Visual.

> VisualParent	(Inherited from Visual)

Gets the visual tree parent of the visual object.

> VisualScrollableAreaClip	(Inherited from Visual)

Gets or sets a clipped scrollable area for the Visual.

> VisualTextHintingMode	(Inherited from Visual)

Gets or sets the TextHintingMode of the Visual.

> VisualTextRenderingMode	(Inherited from Visual)

Gets or sets the TextRenderingMode of the Visual.

> VisualTransform	(Inherited from Visual)

Gets or sets the Transform value for the Visual.

> VisualXSnappingGuidelines	(Inherited from Visual)

Gets or sets the x-coordinate (vertical) guideline collection.

> VisualYSnappingGuidelines	(Inherited from Visual)

Gets or sets the y-coordinate (horizontal) guideline collection.

##### FiFileds:FIELDS:

> AllowDropProperty	

Identifies the AllowDrop dependency property.

> AreAnyTouchesCapturedProperty	

Identifies the AreAnyTouchesCaptured dependency property.

> AreAnyTouchesCapturedWithinProperty	

Identifies the AreAnyTouchesCapturedWithin dependency property.

> AreAnyTouchesDirectlyOverProperty	

Identifies the AreAnyTouchesDirectlyOver dependency property.

> AreAnyTouchesOverProperty	

Identifies the AreAnyTouchesOver dependency property.

> BitmapEffectInputProperty	

Identifies the BitmapEffectInput dependency property.

> BitmapEffectProperty	

Identifies the BitmapEffect dependency property.

> CacheModeProperty	

Identifies the CacheMode dependency property.

> ClipProperty	

Identifies the Clip dependency property.

> ClipToBoundsProperty	

Identifies the ClipToBounds dependency property.

> DragEnterEvent	

Identifies the DragEnter routed event.

> DragLeaveEvent	

Identifies the DragLeave routed event.

> DragOverEvent	

Identifies the DragOver routed event.

> DropEvent	

Identifies the Drop routed event.

> EffectProperty	

Identifies the Effect dependency property.

> FocusableProperty	

Identifies the Focusable dependency property.

> GiveFeedbackEvent	

Identifies the GiveFeedback routed event.

> GotFocusEvent	

Identifies the GotFocus routed event.

> GotKeyboardFocusEvent	

Identifies the GotKeyboardFocus routed event.

> GotMouseCaptureEvent	

Identifies the GotMouseCapture routed event.

> GotStylusCaptureEvent	

Identifies the GotStylusCapture routed event.

> GotTouchCaptureEvent	

Identifies the GotTouchCapture routed event.

> IsEnabledProperty	

Identifies the IsEnabled dependency property.

> IsFocusedProperty	

Identifies the IsFocused dependency property.

> IsHitTestVisibleProperty	

Identifies the IsHitTestVisible dependency property.

> IsKeyboardFocusedProperty	

Identifies the IsKeyboardFocused dependency property.

> IsKeyboardFocusWithinProperty	

Identifies the IsKeyboardFocusWithin dependency property.

> IsManipulationEnabledProperty	

Identifies the IsManipulationEnabled dependency property.

> IsMouseCapturedProperty	

Identifies the IsMouseCaptured dependency property.

> IsMouseCaptureWithinProperty	

Identifies the IsMouseCaptureWithin dependency property.

> IsMouseDirectlyOverProperty	

Identifies the IsMouseDirectlyOver dependency property.

> IsMouseOverProperty	

Identifies the IsMouseOver dependency property.

> IsStylusCapturedProperty	

Identifies the IsStylusCaptured dependency property.

> IsStylusCaptureWithinProperty	

Identifies the IsStylusCaptureWithin dependency property.

> IsStylusDirectlyOverProperty	

Identifies the IsStylusDirectlyOver dependency property.

> IsStylusOverProperty	

Identifies the IsStylusOver dependency property.

> IsVisibleProperty	

Identifies the IsVisible dependency property.

> KeyDownEvent	

Identifies the KeyDown routed event.

> KeyUpEvent	

Identifies the KeyUp routed event.

> LostFocusEvent	

Identifies the LostFocus routed event.

> LostKeyboardFocusEvent	

Identifies the LostKeyboardFocus routed event.

> LostMouseCaptureEvent	

Identifies the LostMouseCapture routed event.

> LostStylusCaptureEvent	

Identifies the LostStylusCapture routed event.

> LostTouchCaptureEvent	

Identifies the LostTouchCapture routed event.

> ManipulationBoundaryFeedbackEvent	

Identifies the ManipulationBoundaryFeedback event.

> ManipulationCompletedEvent	

Identifies the ManipulationCompleted routed event.

> ManipulationDeltaEvent	

Identifies the ManipulationDelta routed event.

> ManipulationInertiaStartingEvent	

Identifies the ManipulationInertiaStarting routed event.

> ManipulationStartedEvent	

Identifies the ManipulationStarted routed event.

> ManipulationStartingEvent	

Identifies the ManipulationStarting routed event.

> MouseDownEvent	

Identifies the MouseDown routed event.

> MouseEnterEvent	

Identifies the MouseEnter routed event.

> MouseLeaveEvent	

Identifies the MouseLeave routed event.

> MouseLeftButtonDownEvent	

Identifies the MouseLeftButtonDown routed event.

> MouseLeftButtonUpEvent	

Identifies the MouseLeftButtonUp routed event.

> MouseMoveEvent	

Identifies the MouseMove routed event.

> MouseRightButtonDownEvent	

Identifies the MouseRightButtonDown routed event.

> MouseRightButtonUpEvent	

Identifies the MouseRightButtonUp routed event.

> MouseUpEvent	

Identifies the MouseUp routed event.

> MouseWheelEvent	

Identifies the MouseWheel routed event.

> OpacityMaskProperty	

Identifies the OpacityMask dependency property.

> OpacityProperty	

Identifies the Opacity dependency property.

> PreviewDragEnterEvent	

Identifies the PreviewDragEnter routed event.

> PreviewDragLeaveEvent	

Identifies the PreviewDragLeave routed event.

> PreviewDragOverEvent	

Identifies the PreviewDragOver routed event.

> PreviewDropEvent	

Identifies the PreviewDrop routed event.

> PreviewGiveFeedbackEvent	

Identifies the PreviewGiveFeedback routed event.

> PreviewGotKeyboardFocusEvent	

Identifies the PreviewGotKeyboardFocus routed event.

> PreviewKeyDownEvent	

Identifies the PreviewKeyDown routed event.

> PreviewKeyUpEvent	

Identifies the PreviewKeyUp routed event.

> PreviewLostKeyboardFocusEvent	

Identifies the PreviewLostKeyboardFocus routed event.

> PreviewMouseDownEvent	

Identifies the PreviewMouseDown routed event.

> PreviewMouseLeftButtonDownEvent	

Identifies the PreviewMouseLeftButtonDown routed event.

> PreviewMouseLeftButtonUpEvent	

Identifies the PreviewMouseLeftButtonUp routed event.

> PreviewMouseMoveEvent	

Identifies the PreviewMouseMove routed event.

> PreviewMouseRightButtonDownEvent	

Identifies the PreviewMouseRightButtonDown routed event.

> PreviewMouseRightButtonUpEvent	

Identifies the PreviewMouseRightButtonUp routed event.

> PreviewMouseUpEvent	

Identifies the PreviewMouseUp routed event.

> PreviewMouseWheelEvent	

Identifies the PreviewMouseWheel routed event.

> PreviewQueryContinueDragEvent	

Identifies the PreviewQueryContinueDrag routed event.

> PreviewStylusButtonDownEvent	

Identifies the PreviewStylusButtonDown routed event.

> PreviewStylusButtonUpEvent	

Identifies the PreviewStylusButtonUp routed event.

> PreviewStylusDownEvent	

Identifies the PreviewStylusDown routed event.

> PreviewStylusInAirMoveEvent	

Identifies the PreviewStylusInAirMove routed event.

> PreviewStylusInRangeEvent	

Identifies the PreviewStylusInRange routed event.

> PreviewStylusMoveEvent	

Identifies the PreviewStylusMove routed event.

> PreviewStylusOutOfRangeEvent	

Identifies the PreviewStylusOutOfRange routed event.

> PreviewStylusSystemGestureEvent	

Identifies the PreviewStylusSystemGesture routed event.

> PreviewStylusUpEvent	

Identifies the PreviewStylusUp routed event.

> PreviewTextInputEvent	

Identifies the PreviewTextInput routed event.

> PreviewTouchDownEvent	

Identifies the PreviewTouchDown routed event.

> PreviewTouchMoveEvent	

Identifies the PreviewTouchMove routed event.

> PreviewTouchUpEvent	

Identifies the PreviewTouchUp routed event.

> QueryContinueDragEvent	

Identifies the QueryContinueDrag routed event.

> QueryCursorEvent	

Identifies the QueryCursor routed event.

> RenderTransformOriginProperty	

Identifies the RenderTransformOrigin dependency property.

> RenderTransformProperty	

Identifies the RenderTransform dependency property.

> SnapsToDevicePixelsProperty	

Identifies the SnapsToDevicePixels dependency property.

> StylusButtonDownEvent	

Identifies the StylusButtonDown routed event.

> StylusButtonUpEvent	

Identifies the StylusButtonUp routed event.

> StylusDownEvent	

Identifies the StylusDown routed event.

> StylusEnterEvent	

Identifies the StylusEnter routed event.

> StylusInAirMoveEvent	

Identifies the StylusInAirMove routed event.

> StylusInRangeEvent	

Identifies the StylusInRange routed event.

> StylusLeaveEvent	

Identifies the StylusLeave routed event.

> StylusMoveEvent	

Identifies the StylusMove routed event.

> StylusOutOfRangeEvent	

Identifies the StylusOutOfRange routed event.

> StylusSystemGestureEvent	

Identifies the StylusSystemGesture routed event.

> StylusUpEvent	

Identifies the StylusUp routed event.

> TextInputEvent	

Identifies the TextInput routed event.

> TouchDownEvent	

Identifies the TouchDown routed event.

> TouchEnterEvent	

Identifies the TouchEnter routed event.

> TouchLeaveEvent	

Identifies the TouchLeave routed event.

> TouchMoveEvent	

Identifies the TouchMove routed event.

> TouchUpEvent	

Identifies the TouchUp routed event.

> UidProperty	

Identifies the Uid dependency property.

> VisibilityProperty	

Identifies the Visibility dependency property. EXPLICIT INTERFACE IMPLEMENTATIONS

> IQueryAmbient.IsAmbientPropertyAvailable(String)	

For a description of this member, see the IsAmbientPropertyAvailable(String) method.

#### Visual

##### 方法:METHODS

> AddVisualChild(Visual)	

Defines the parent-child relationship between two visuals.

> CheckAccess()	

Determines whether the calling thread has access to this DispatcherObject.(Inherited from DispatcherObject)

> ClearValue(DependencyProperty)	

Clears the local value of a property. The property to be cleared is specified by a DependencyProperty identifier.

> ClearValue(DependencyPropertyKey)		(Inherited from DependencyObject)

Clears the local value of a read-only property. The property to be cleared is specified by a DependencyPropertyKey.

> CoerceValue(DependencyProperty)		(Inherited from DependencyObject)

Coerces the value of the specified dependency property. This is accomplished by invoking any CoerceValueCallback function specified in property metadata for the dependency property as it exists on the calling DependencyObject.

> Equals(Object)		(Inherited from DependencyObject)

Determines whether a provided DependencyObject is equivalent to the current DependencyObject.

> FindCommonVisualAncestor(DependencyObject)		(Inherited from DependencyObject)

Returns the common ancestor of two visual objects.

> GetHashCode()	

Gets a hash code for this DependencyObject.

> GetLocalValueEnumerator()		(Inherited from DependencyObject)

Creates a specialized enumerator for determining which dependency properties have locally set values on this DependencyObject.

> GetType()		(Inherited from DependencyObject)

Gets the Type of the current instance.(Inherited from Object)

> GetValue(DependencyProperty)	

Returns the current effective value of a dependency property on this instance of a DependencyObject.

> GetVisualChild(Int32)		(Inherited from DependencyObject)

Returns the specified Visual in the parent VisualCollection.

> HitTestCore(GeometryHitTestParameters)	

Determines whether a geometry value is within the bounds of the visual object.

> HitTestCore(PointHitTestParameters)	

Determines whether a point coordinate value is within the bounds of the visual object.

> InvalidateProperty(DependencyProperty)	

Re-evaluates the effective value for the specified dependency property.

> IsAncestorOf(DependencyObject)		(Inherited from DependencyObject)

Determines whether the visual object is an ancestor of the descendant visual object.

> IsDescendantOf(DependencyObject)	

Determines whether the visual object is a descendant of the ancestor visual object.

> MemberwiseClone()	

Creates a shallow copy of the current Object.(Inherited from Object)

> OnDpiChanged(DpiScale, DpiScale)	

Called when the DPI at which this View is rendered changes.

> OnPropertyChanged(DependencyPropertyChangedEventArgs)	

Invoked whenever the effective value of any dependency property on this DependencyObject has been updated. The specific dependency property that changed is reported in the event data.

> OnVisualChildrenChanged(DependencyObject, DependencyObject)		(Inherited from DependencyObject)

Called when the VisualCollection of the visual object is modified.

> OnVisualParentChanged(DependencyObject)	

Called when the parent of the visual object is changed.

> PointFromScreen(Point)	

Converts a Point in screen coordinates into a Point that represents the current coordinate system of the Visual.

PointToScreen(Point)	

Converts a Point that represents the current coordinate system of the Visual into a Point in screen coordinates.

> ReadLocalValue(DependencyProperty)	

Returns the local value of a dependency property, if it exists.

> RemoveVisualChild(Visual)		(Inherited from DependencyObject)

Removes the parent-child relationship between two visuals.

> SetCurrentValue(DependencyProperty, Object)	

Sets the value of a dependency property without changing its value source.

> SetValue(DependencyProperty, Object)		(Inherited from DependencyObject)

Sets the local value of a dependency property, specified by its dependency property identifier.

> SetValue(DependencyPropertyKey, Object)		(Inherited from DependencyObject)

Sets the local value of a read-only dependency property, specified by the DependencyPropertyKey identifier of the dependency property.

> ShouldSerializeProperty(DependencyProperty)		(Inherited from DependencyObject)

Returns a value that indicates whether serialization processes should serialize the value for the provided dependency property.

> ToString()		(Inherited from DependencyObject)

Returns a string that represents the current object.(Inherited from Object)

> TransformToAncestor(Visual)	

Returns a transform that can be used to transform coordinates from the Visual to the specified Visual ancestor of the visual object.

> TransformToAncestor(Visual3D)	

Returns a transform that can be used to transform coordinates from the Visual to the specified Visual3D ancestor of the visual object.

> TransformToDescendant(Visual)	

Returns a transform that can be used to transform coordinates from the Visual to the specified visual object descendant.

> TransformToVisual(Visual)	

Returns a transform that can be used to transform coordinates from the Visual to the specified visual object.

> VerifyAccess()	

Enforces that the calling thread has access to this DispatcherObject.(Inherited from DispatcherObject)

##### 属性:

> DependencyObjectType	

Gets the DependencyObjectType that wraps the CLR type of this instance.

> Dispatcher		(Inherited from DependencyObject)

Gets the Dispatcher this DispatcherObject is associated with.(Inherited from DispatcherObject)

> IsSealed	

Gets a value that indicates whether this instance is currently sealed (read-only).

> VisualBitmapEffect		(Inherited from DependencyObject)

Obsolete.

Gets or sets the BitmapEffect value for the Visual.

> VisualBitmapEffectInput	

Obsolete.

Gets or sets the BitmapEffectInput value for the Visual.

> VisualBitmapScalingMode	

Gets or sets the BitmapScalingMode for the Visual.

> VisualCacheMode	

Gets or sets a cached representation of the Visual.

> VisualChildrenCount	

Gets the number of child elements for the Visual.

> VisualClearTypeHint	

Gets or sets the ClearTypeHint that determines how ClearType is rendered in the Visual.

> VisualClip	

Gets or sets the clip region of the Visual as a Geometry value.

> VisualEdgeMode	

Gets or sets the edge mode of the Visual as an EdgeMode value.

> VisualEffect	

Gets or sets the bitmap effect to apply to the Visual.

> VisualOffset	

Gets or sets the offset value of the visual object.

> VisualOpacity	

Gets or sets the opacity of the Visual.

> VisualOpacityMask	

Gets or sets the Brush value that represents the opacity mask of the Visual.

> VisualParent	

Gets the visual tree parent of the visual object.

> VisualScrollableAreaClip	

Gets or sets a clipped scrollable area for the Visual.

> VisualTextHintingMode	

Gets or sets the TextHintingMode of the Visual.

> VisualTextRenderingMode	

Gets or sets the TextRenderingMode of the Visual.

> VisualTransform	

Gets or sets the Transform value for the Visual.

> VisualXSnappingGuidelines	

Gets or sets the x-coordinate (vertical) guideline collection.

> VisualYSnappingGuidelines	

Gets or sets the y-coordinate (horizontal) guideline collection.

> [System.Windows.Markup.UidProperty("Uid")]

##### 方法: METHODS

> AddHandler(RoutedEvent, Delegate)	

Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.(Inherited from UIElement)

> AddHandler(RoutedEvent, Delegate, Boolean)	

Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element. Specify handledEventsToo as true to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.(Inherited from UIElement)

> AddLogicalChild(Object)	

Adds the provided object to the logical tree of this element.

AddToEventRoute(EventRoute, RoutedEventArgs)	

Adds handlers to the specified EventRoute for the current UIElement event handler collection.(Inherited from UIElement)

> AddVisualChild(Visual)	

Defines the parent-child relationship between two visuals.

> ApplyAnimationClock(DependencyProperty, AnimationClock)	(Inherited from Visual)

Applies an animation to a specified dependency property on this element. Any existing animations are stopped and replaced with the new animation.(Inherited from UIElement)

> ApplyAnimationClock(DependencyProperty, AnimationClock, HandoffBehavior)	

Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.(Inherited from UIElement)

> ApplyTemplate()	

Builds the current template's visual tree if necessary, and returns a value that indicates whether the visual tree was rebuilt by this call.

Arrange(Rect)	

Positions child elements and determines a size for a UIElement. Parent elements call this method from their ArrangeCore(Rect) implementation (or a WPF framework-level equivalent) to form a recursive layout update. This method constitutes the second pass of a layout update.(Inherited from UIElement)

> ArrangeCore(Rect)	

Implements ArrangeCore(Rect) (defined as virtual in UIElement) and seals the implementation.

ArrangeOverride(Size)	

When overridden in a derived class, positions child elements and determines a size for a FrameworkElement derived class.

BeginAnimation(DependencyProperty, AnimationTimeline)	

Starts an animation for a specified animated property on this element.(Inherited from UIElement)

> BeginAnimation(DependencyProperty, AnimationTimeline, HandoffBehavior)	

Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.(Inherited from UIElement)

> BeginInit()	

Starts the initialization process for this element.

BeginStoryboard(Storyboard)	

Begins the sequence of actions that are contained in the provided storyboard.

BeginStoryboard(Storyboard, HandoffBehavior)	

Begins the sequence of actions contained in the provided storyboard, with options specified for what should happen if the property is already animated.

BeginStoryboard(Storyboard, HandoffBehavior, Boolean)	

Begins the sequence of actions contained in the provided storyboard, with specified state for control of the animation after it is started.

BringIntoView()	

Attempts to bring this element into view, within any scrollable regions it is contained within.

BringIntoView(Rect)	

Attempts to bring the provided region size of this element into view, within any scrollable regions it is contained within.

CaptureMouse()	

Attempts to force capture of the mouse to this element.(Inherited from UIElement)

> CaptureStylus()	

Attempts to force capture of the stylus to this element.(Inherited from UIElement)

> CaptureTouch(TouchDevice)	

Attempts to force capture of a touch to this element.(Inherited from UIElement)

> CheckAccess()	

Determines whether the calling thread has access to this DispatcherObject.(Inherited from DispatcherObject)

> ClearValue(DependencyProperty)	

Clears the local value of a property. The property to be cleared is specified by a DependencyProperty identifier.

> ClearValue(DependencyPropertyKey)		(Inherited from DependencyObject)

Clears the local value of a read-only property. The property to be cleared is specified by a DependencyPropertyKey.

> CoerceValue(DependencyProperty)		(Inherited from DependencyObject)

Coerces the value of the specified dependency property. This is accomplished by invoking any CoerceValueCallback function specified in property metadata for the dependency property as it exists on the calling DependencyObject.

> EndInit()	(Inherited from DependencyObject)

Indicates that the initialization process for the element is complete.

Equals(Object)	

Determines whether a provided DependencyObject is equivalent to the current DependencyObject.

> FindCommonVisualAncestor(DependencyObject)		(Inherited from DependencyObject)

Returns the common ancestor of two visual objects.

> FindName(String)	(Inherited from Visual)

Finds an element that has the provided identifier name.

FindResource(Object)	

Searches for a resource with the specified key, and throws an exception if the requested resource is not found.

Focus()	

Attempts to set focus to this element.(Inherited from UIElement)

> GetAnimationBaseValue(DependencyProperty)	

Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.(Inherited from UIElement)

> GetBindingExpression(DependencyProperty)	

Returns the BindingExpression that represents the binding on the specified property.

GetFlowDirection(DependencyObject)	

Gets the value of the FlowDirection attached property for the specified DependencyObject.

GetHashCode()	

Gets a hash code for this DependencyObject.

> GetLayoutClip(Size)		(Inherited from DependencyObject)

Returns a geometry for a clipping mask. The mask applies if the layout system attempts to arrange an element that is larger than the available display space.

GetLocalValueEnumerator()	

Creates a specialized enumerator for determining which dependency properties have locally set values on this DependencyObject.

> GetTemplateChild(String)		(Inherited from DependencyObject)

Returns the named element in the visual tree of an instantiated ControlTemplate.

GetType()	

Gets the Type of the current instance.(Inherited from Object)

> GetUIParentCore()	

Returns an alternative logical parent for this element if there is no visual parent.

GetValue(DependencyProperty)	

Returns the current effective value of a dependency property on this instance of a DependencyObject.

> GetVisualChild(Int32)		(Inherited from DependencyObject)

Overrides GetVisualChild(Int32), and returns a child at the specified index from a collection of child elements.

HitTestCore(GeometryHitTestParameters)	

Implements HitTestCore(GeometryHitTestParameters) to supply base element hit testing behavior (returning GeometryHitTestResult).(Inherited from UIElement)

> HitTestCore(PointHitTestParameters)	

Implements HitTestCore(PointHitTestParameters) to supply base element hit testing behavior (returning HitTestResult).(Inherited from UIElement)

> InputHitTest(Point)	

Returns the input element within the current element that is at the specified coordinates, relative to the current element's origin.(Inherited from UIElement)

> InvalidateArrange()	

Invalidates the arrange state (layout) for the element. After the invalidation, the element will have its layout updated, which will occur asynchronously unless subsequently forced by UpdateLayout().(Inherited from UIElement)

> InvalidateMeasure()	

Invalidates the measurement state (layout) for the element.(Inherited from UIElement)

> InvalidateProperty(DependencyProperty)	

Re-evaluates the effective value for the specified dependency property.

> InvalidateVisual()		(Inherited from DependencyObject)

Invalidates the rendering of the element, and forces a complete new layout pass. OnRender(DrawingContext) is called after the layout cycle is completed.(Inherited from UIElement)

> IsAncestorOf(DependencyObject)	

Determines whether the visual object is an ancestor of the descendant visual object.

> IsDescendantOf(DependencyObject)	(Inherited from Visual)

Determines whether the visual object is a descendant of the ancestor visual object.

> Measure(Size)	(Inherited from Visual)

Updates the DesiredSize of a UIElement. Parent elements call this method from their own MeasureCore(Size) implementations to form a recursive layout update. Calling this method constitutes the first pass (the "Measure" pass) of a layout update.(Inherited from UIElement)

> MeasureCore(Size)	

Implements basic measure-pass layout system behavior for FrameworkElement.

MeasureOverride(Size)	

When overridden in a derived class, measures the size in layout required for child elements and determines a size for the FrameworkElement-derived class.

MemberwiseClone()	

Creates a shallow copy of the current Object.(Inherited from Object)

> MoveFocus(TraversalRequest)	

Moves the keyboard focus away from this element and to another element in a provided traversal direction.

OnAccessKey(AccessKeyEventArgs)	

Provides class handling for when an access key that is meaningful for this element is invoked.(Inherited from UIElement)

> OnApplyTemplate()	

When overridden in a derived class, is invoked whenever application code or internal processes call ApplyTemplate().

OnChildDesiredSizeChanged(UIElement)	

Supports layout behavior when a child element is resized.(Inherited from UIElement)

> OnContextMenuClosing(ContextMenuEventArgs)	

Invoked whenever an unhandled ContextMenuClosing routed event reaches this class in its route. Implement this method to add class handling for this event.

OnContextMenuOpening(ContextMenuEventArgs)	

Invoked whenever an unhandled ContextMenuOpening routed event reaches this class in its route. Implement this method to add class handling for this event.

OnCreateAutomationPeer()	

Returns class-specific AutomationPeer implementations for the Windows Presentation Foundation (WPF) infrastructure.(Inherited from UIElement)

> OnDpiChanged(DpiScale, DpiScale)	

Called when the DPI at which this View is rendered changes.

> OnDragEnter(DragEventArgs)	(Inherited from Visual)

Invoked when an unhandled DragEnter attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnDragLeave(DragEventArgs)	

Invoked when an unhandled DragLeave attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnDragOver(DragEventArgs)	

Invoked when an unhandled DragOver attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnDrop(DragEventArgs)	

Invoked when an unhandled DragEnter attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnGiveFeedback(GiveFeedbackEventArgs)	

Invoked when an unhandled GiveFeedback attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnGotFocus(RoutedEventArgs)	

Invoked whenever an unhandled GotFocus event reaches this element in its route.

OnGotKeyboardFocus(KeyboardFocusChangedEventArgs)	

Invoked when an unhandled GotKeyboardFocus attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnGotMouseCapture(MouseEventArgs)	

Invoked when an unhandled GotMouseCapture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnGotStylusCapture(StylusEventArgs)	

Invoked when an unhandled GotStylusCapture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnGotTouchCapture(TouchEventArgs)	

Provides class handling for the GotTouchCapture routed event that occurs when a touch is captured to this element.(Inherited from UIElement)

> OnInitialized(EventArgs)	

Raises the Initialized event. This method is invoked whenever IsInitialized is set to true internally.

OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsKeyboardFocusedChanged event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs)	

Invoked just before the IsKeyboardFocusWithinChanged event is raised by this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsMouseCapturedChanged event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsMouseCaptureWithinChanged event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsMouseDirectlyOverChanged event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsStylusCapturedChanged event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsStylusCaptureWithinChanged event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs)	

Invoked when an unhandled IsStylusDirectlyOverChanged event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnKeyDown(KeyEventArgs)	

Invoked when an unhandled KeyDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnKeyUp(KeyEventArgs)	

Invoked when an unhandled KeyUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnLostFocus(RoutedEventArgs)	

Raises the LostFocus routed event by using the event data that is provided.(Inherited from UIElement)

> OnLostKeyboardFocus(KeyboardFocusChangedEventArgs)	

Invoked when an unhandled LostKeyboardFocus attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnLostMouseCapture(MouseEventArgs)	

Invoked when an unhandled LostMouseCapture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnLostStylusCapture(StylusEventArgs)	

Invoked when an unhandled LostStylusCapture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnLostTouchCapture(TouchEventArgs)	

Provides class handling for the LostTouchCapture routed event that occurs when this element loses a touch capture.(Inherited from UIElement)

> OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)	

Called when the ManipulationBoundaryFeedback event occurs.(Inherited from UIElement)

> OnManipulationCompleted(ManipulationCompletedEventArgs)	

Called when the ManipulationCompleted event occurs.(Inherited from UIElement)

> OnManipulationDelta(ManipulationDeltaEventArgs)	

Called when the ManipulationDelta event occurs.(Inherited from UIElement)

> OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs)	

Called when the ManipulationInertiaStarting event occurs.(Inherited from UIElement)

> OnManipulationStarted(ManipulationStartedEventArgs)	

Called when the ManipulationStarted event occurs.(Inherited from UIElement)

> OnManipulationStarting(ManipulationStartingEventArgs)	

Provides class handling for the ManipulationStarting routed event that occurs when the manipulation processor is first created.(Inherited from UIElement)

> OnMouseDown(MouseButtonEventArgs)	

Invoked when an unhandled MouseDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnMouseEnter(MouseEventArgs)	

Invoked when an unhandled MouseEnter attached event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnMouseLeave(MouseEventArgs)	

Invoked when an unhandled MouseLeave attached event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnMouseLeftButtonDown(MouseButtonEventArgs)	

Invoked when an unhandled MouseLeftButtonDown routed event is raised on this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnMouseLeftButtonUp(MouseButtonEventArgs)	

Invoked when an unhandled MouseLeftButtonUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnMouseMove(MouseEventArgs)	

Invoked when an unhandled MouseMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnMouseRightButtonDown(MouseButtonEventArgs)	

Invoked when an unhandled MouseRightButtonDown routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnMouseRightButtonUp(MouseButtonEventArgs)	

Invoked when an unhandled MouseRightButtonUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnMouseUp(MouseButtonEventArgs)	

Invoked when an unhandled MouseUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnMouseWheel(MouseWheelEventArgs)	

Invoked when an unhandled MouseWheel attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewDragEnter(DragEventArgs)	

Invoked when an unhandled PreviewDragEnter attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewDragLeave(DragEventArgs)	

Invoked when an unhandled PreviewDragLeave attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewDragOver(DragEventArgs)	

Invoked when an unhandled PreviewDragOver attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewDrop(DragEventArgs)	

Invoked when an unhandled PreviewDrop attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewGiveFeedback(GiveFeedbackEventArgs)	

Invoked when an unhandled PreviewGiveFeedback attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs)	

Invoked when an unhandled PreviewGotKeyboardFocus attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewKeyDown(KeyEventArgs)	

Invoked when an unhandled PreviewKeyDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewKeyUp(KeyEventArgs)	

Invoked when an unhandled PreviewKeyUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs)	

Invoked when an unhandled PreviewKeyDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewMouseDown(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseDown attached routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewMouseLeftButtonDown(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseLeftButtonDown routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewMouseLeftButtonUp(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseLeftButtonUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewMouseMove(MouseEventArgs)	

Invoked when an unhandled PreviewMouseMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewMouseRightButtonDown(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseRightButtonDown routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewMouseRightButtonUp(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseRightButtonUp routed event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewMouseUp(MouseButtonEventArgs)	

Invoked when an unhandled PreviewMouseUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewMouseWheel(MouseWheelEventArgs)	

Invoked when an unhandled PreviewMouseWheel attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewQueryContinueDrag(QueryContinueDragEventArgs)	

Invoked when an unhandled PreviewQueryContinueDrag attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewStylusButtonDown(StylusButtonEventArgs)	

Invoked when an unhandled PreviewStylusButtonDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewStylusButtonUp(StylusButtonEventArgs)	

Invoked when an unhandled PreviewStylusButtonUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewStylusDown(StylusDownEventArgs)	

Invoked when an unhandled PreviewStylusDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewStylusInAirMove(StylusEventArgs)	

Invoked when an unhandled PreviewStylusInAirMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewStylusInRange(StylusEventArgs)	

Invoked when an unhandled PreviewStylusInRange attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewStylusMove(StylusEventArgs)	

Invoked when an unhandled PreviewStylusMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewStylusOutOfRange(StylusEventArgs)	

Invoked when an unhandled PreviewStylusOutOfRange attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs)	

Invoked when an unhandled PreviewStylusSystemGesture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewStylusUp(StylusEventArgs)	

Invoked when an unhandled PreviewStylusUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewTextInput(TextCompositionEventArgs)	

Invoked when an unhandled PreviewTextInput attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnPreviewTouchDown(TouchEventArgs)	

Provides class handling for the PreviewTouchDown routed event that occurs when a touch presses this element.(Inherited from UIElement)

> OnPreviewTouchMove(TouchEventArgs)	

Provides class handling for the PreviewTouchMove routed event that occurs when a touch moves while inside this element.(Inherited from UIElement)

> OnPreviewTouchUp(TouchEventArgs)	

Provides class handling for the PreviewTouchUp routed event that occurs when a touch is released inside this element.(Inherited from UIElement)

> OnPropertyChanged(DependencyPropertyChangedEventArgs)	

Invoked whenever the effective value of any dependency property on this FrameworkElement has been updated. The specific dependency property that changed is reported in the arguments parameter. Overrides OnPropertyChanged(DependencyPropertyChangedEventArgs).

OnQueryContinueDrag(QueryContinueDragEventArgs)	

Invoked when an unhandled QueryContinueDrag attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnQueryCursor(QueryCursorEventArgs)	

Invoked when an unhandled QueryCursor attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnRender(DrawingContext)	

When overridden in a derived class, participates in rendering operations that are directed by the layout system. The rendering instructions for this element are not used directly when this method is invoked, and are instead preserved for later asynchronous use by layout and drawing.(Inherited from UIElement)

> OnRenderSizeChanged(SizeChangedInfo)	

Raises the SizeChanged event, using the specified information as part of the eventual event data.

OnStyleChanged(Style, Style)	

Invoked when the style in use on this element changes, which will invalidate the layout.

OnStylusButtonDown(StylusButtonEventArgs)	

Invoked when an unhandled StylusButtonDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusButtonUp(StylusButtonEventArgs)	

Invoked when an unhandled StylusButtonUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusDown(StylusDownEventArgs)	

Invoked when an unhandled StylusDown attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusEnter(StylusEventArgs)	

Invoked when an unhandled StylusEnter attached event is raised by this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusInAirMove(StylusEventArgs)	

Invoked when an unhandled StylusInAirMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusInRange(StylusEventArgs)	

Invoked when an unhandled StylusInRange attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusLeave(StylusEventArgs)	

Invoked when an unhandled StylusLeave attached event is raised by this element. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusMove(StylusEventArgs)	

Invoked when an unhandled StylusMove attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusOutOfRange(StylusEventArgs)	

Invoked when an unhandled StylusOutOfRange attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusSystemGesture(StylusSystemGestureEventArgs)	

Invoked when an unhandled StylusSystemGesture attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnStylusUp(StylusEventArgs)	

Invoked when an unhandled StylusUp attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnTextInput(TextCompositionEventArgs)	

Invoked when an unhandled TextInput attached event reaches an element in its route that is derived from this class. Implement this method to add class handling for this event.(Inherited from UIElement)

> OnToolTipClosing(ToolTipEventArgs)	

Invoked whenever an unhandled ToolTipClosing routed event reaches this class in its route. Implement this method to add class handling for this event.

OnToolTipOpening(ToolTipEventArgs)	

Invoked whenever the ToolTipOpening routed event reaches this class in its route. Implement this method to add class handling for this event.

OnTouchDown(TouchEventArgs)	

Provides class handling for the TouchDown routed event that occurs when a touch presses inside this element.(Inherited from UIElement)

> OnTouchEnter(TouchEventArgs)	

Provides class handling for the TouchEnter routed event that occurs when a touch moves from outside to inside the bounds of this element.(Inherited from UIElement)

> OnTouchLeave(TouchEventArgs)	

Provides class handling for the TouchLeave routed event that occurs when a touch moves from inside to outside the bounds of this UIElement.(Inherited from UIElement)

> OnTouchMove(TouchEventArgs)	

Provides class handling for the TouchMove routed event that occurs when a touch moves while inside this element.(Inherited from UIElement)

> OnTouchUp(TouchEventArgs)	

Provides class handling for the TouchUp routed event that occurs when a touch is released inside this element.(Inherited from UIElement)

> OnVisualChildrenChanged(DependencyObject, DependencyObject)	(Inherited from UIElement)

> Called when the VisualCollection of the visual object is modified.

> OnVisualParentChanged(DependencyObject)	(Inherited from Visual)

Invoked when the parent of this element in the visual tree is changed. Overrides OnVisualParentChanged(DependencyObject).

ParentLayoutInvalidated(UIElement)	

Supports incremental layout implementations in specialized subclasses of FrameworkElement. ParentLayoutInvalidated(UIElement) is invoked when a child element has invalidated a property that is marked in metadata as affecting the parent's measure or arrange passes during layout.

PointFromScreen(Point)	

Converts a Point in screen coordinates into a Point that represents the current coordinate system of the Visual.

> PointToScreen(Point)	(Inherited from Visual)

Converts a Point that represents the current coordinate system of the Visual into a Point in screen coordinates.

> PredictFocus(FocusNavigationDirection)	(Inherited from Visual)

Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.

RaiseEvent(RoutedEventArgs)	

Raises a specific routed event. The RoutedEvent to be raised is identified within the RoutedEventArgs instance that is provided (as the RoutedEvent property of that event data).

> ReadLocalValue(DependencyProperty)	(Inherited from UIElement)

> Returns the local value of a dependency property, if it exists.

> RegisterName(String, Object)		(Inherited from DependencyObject)

Provides an accessor that simplifies access to the NameScope registration method.

ReleaseAllTouchCaptures()	

Releases all captured touch devices from this element.

> ReleaseMouseCapture()	(Inherited from UIElement)

> Releases the mouse capture, if this element held the capture.

> ReleaseStylusCapture()	(Inherited from UIElement)

> Releases the stylus device capture, if this element held the capture.

> ReleaseTouchCapture(TouchDevice)	(Inherited from UIElement)

> Attempts to release the specified touch device from this element.

> RemoveHandler(RoutedEvent, Delegate)	(Inherited from UIElement)

> Removes the specified routed event handler from this element.

> RemoveLogicalChild(Object)	(Inherited from UIElement)

> Removes the provided object from this element's logical tree. FrameworkElement updates the affected logical tree parent pointers to keep in sync with this deletion.

RemoveVisualChild(Visual)	

Removes the parent-child relationship between two visuals.

> SetBinding(DependencyProperty, BindingBase)	(Inherited from Visual)

Attaches a binding to this element, based on the provided binding object.

SetBinding(DependencyProperty, String)	

Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.

SetCurrentValue(DependencyProperty, Object)	

Sets the value of a dependency property without changing its value source.

> SetFlowDirection(DependencyObject, FlowDirection)		(Inherited from DependencyObject)

Sets the value of the FlowDirection attached property for the provided element.

SetResourceReference(DependencyProperty, Object)	

Searches for a resource with the specified name and sets up a resource reference to it for the specified property.

SetValue(DependencyProperty, Object)	

Sets the local value of a dependency property, specified by its dependency property identifier.

> SetValue(DependencyPropertyKey, Object)		(Inherited from DependencyObject)

Sets the local value of a read-only dependency property, specified by the DependencyPropertyKey identifier of the dependency property.

> ShouldSerializeCommandBindings()		(Inherited from DependencyObject)

Returns whether serialization processes should serialize the contents of the CommandBindings property on instances of this class.

> ShouldSerializeInputBindings()	(Inherited from UIElement)

> Returns whether serialization processes should serialize the contents of the InputBindings property on instances of this class.

> ShouldSerializeProperty(DependencyProperty)	(Inherited from UIElement)

> Returns a value that indicates whether serialization processes should serialize the value for the provided dependency property.

> ShouldSerializeResources()		(Inherited from DependencyObject)

Returns whether serialization processes should serialize the contents of the Resources property.

ShouldSerializeStyle()	

Returns whether serialization processes should serialize the contents of the Style property.

ShouldSerializeTriggers()	

Returns whether serialization processes should serialize the contents of the Triggers property.

ToString()	

Returns a string that represents the current object.(Inherited from Object)

> TransformToAncestor(Visual)	

Returns a transform that can be used to transform coordinates from the Visual to the specified Visual ancestor of the visual object.

> TransformToAncestor(Visual3D)	(Inherited from Visual)

Returns a transform that can be used to transform coordinates from the Visual to the specified Visual3D ancestor of the visual object.

> TransformToDescendant(Visual)	(Inherited from Visual)

Returns a transform that can be used to transform coordinates from the Visual to the specified visual object descendant.

> TransformToVisual(Visual)	(Inherited from Visual)

Returns a transform that can be used to transform coordinates from the Visual to the specified visual object.

> TranslatePoint(Point, UIElement)	(Inherited from Visual)

Translates a point relative to this element to coordinates that are relative to the specified element.(Inherited from UIElement)

> TryFindResource(Object)	(Inherited from UIElement)

> Searches for a resource with the specified key, and returns that resource if found.

UnregisterName(String)	

Simplifies access to the NameScope de-registration method.

UpdateDefaultStyle()	

Reapplies the default style to the current FrameworkElement.

UpdateLayout()	

Ensures that all visual child elements of this element are properly updated for layout.(Inherited from UIElement)

> VerifyAccess()	(Inherited from UIElement)

> Enforces that the calling thread has access to this DispatcherObject.(Inherited from DispatcherObject)

> Events

EVENTS

ContextMenuClosing	

Occurs just before any context menu on the element is closed.

ContextMenuOpening	

Occurs when any context menu on the element is opened.

DataContextChanged	

Occurs when the data context for this element changes.

DragEnter	

Occurs when the input system reports an underlying drag event with this element as the drag target.(Inherited from UIElement)

> DragLeave	(Inherited from UIElement)

> Occurs when the input system reports an underlying drag event with this element as the drag origin.(Inherited from UIElement)

> DragOver	(Inherited from UIElement)

> Occurs when the input system reports an underlying drag event with this element as the potential drop target.(Inherited from UIElement)

> Drop	(Inherited from UIElement)

> Occurs when the input system reports an underlying drop event with this element as the drop target.(Inherited from UIElement)

> FocusableChanged	(Inherited from UIElement)

> Occurs when the value of the Focusable property changes.(Inherited from UIElement)

> GiveFeedback	(Inherited from UIElement)

> Occurs when the input system reports an underlying drag-and-drop event that involves this element.(Inherited from UIElement)

> GotFocus	(Inherited from UIElement)

> Occurs when this element gets logical focus.(Inherited from UIElement)

> GotKeyboardFocus	(Inherited from UIElement)

> Occurs when the keyboard is focused on this element.(Inherited from UIElement)

> GotMouseCapture	(Inherited from UIElement)

> Occurs when this element captures the mouse.(Inherited from UIElement)

> GotStylusCapture	(Inherited from UIElement)

> Occurs when this element captures the stylus.(Inherited from UIElement)

> GotTouchCapture	

Occurs when a touch is captured to this element.(Inherited from UIElement)

> Initialized	

Occurs when this FrameworkElement is initialized. This event coincides with cases where the value of the IsInitialized property changes from false (or undefined) to true.

IsEnabledChanged	

Occurs when the value of the IsEnabled property on this element changes.(Inherited from UIElement)

> IsHitTestVisibleChanged	

Occurs when the value of the IsHitTestVisible dependency property changes on this element.(Inherited from UIElement)

> IsKeyboardFocusedChanged	

Occurs when the value of the IsKeyboardFocused property changes on this element.(Inherited from UIElement)

> IsKeyboardFocusWithinChanged	

Occurs when the value of the IsKeyboardFocusWithin property changes on this element.(Inherited from UIElement)

> IsMouseCapturedChanged	

Occurs when the value of the IsMouseCaptured property changes on this element.(Inherited from UIElement)

> IsMouseCaptureWithinChanged	

Occurs when the value of the IsMouseCaptureWithinProperty changes on this element.(Inherited from UIElement)

> IsMouseDirectlyOverChanged	

Occurs when the value of the IsMouseDirectlyOver property changes on this element.(Inherited from UIElement)

> IsStylusCapturedChanged	

Occurs when the value of the IsStylusCaptured property changes on this element.(Inherited from UIElement)

> IsStylusCaptureWithinChanged	

Occurs when the value of the IsStylusCaptureWithin property changes on this element.(Inherited from UIElement)

> IsStylusDirectlyOverChanged	

Occurs when the value of the IsStylusDirectlyOver property changes on this element.(Inherited from UIElement)

> IsVisibleChanged	

Occurs when the value of the IsVisible property changes on this element.(Inherited from UIElement)

> KeyDown	

Occurs when a key is pressed while focus is on this element.(Inherited from UIElement)

> KeyUp	

Occurs when a key is released while focus is on this element.(Inherited from UIElement)

> LayoutUpdated	

Occurs when the layout of the various visual elements associated with the current Dispatcher changes.(Inherited from UIElement)

> Loaded	

Occurs when the element is laid out, rendered, and ready for interaction.

LostFocus	

Occurs when this element loses logical focus.(Inherited from UIElement)

> LostKeyboardFocus	

Occurs when the keyboard is no longer focused on this element.(Inherited from UIElement)

> LostMouseCapture	

Occurs when this element loses mouse capture.(Inherited from UIElement)

> LostStylusCapture	

Occurs when this element loses stylus capture.(Inherited from UIElement)

> LostTouchCapture	

Occurs when this element loses a touch capture.(Inherited from UIElement)

> ManipulationBoundaryFeedback	

Occurs when the manipulation encounters a boundary.(Inherited from UIElement)

> ManipulationCompleted	

Occurs when a manipulation and inertia on the UIElement object is complete.(Inherited from UIElement)

> ManipulationDelta	

Occurs when the input device changes position during a manipulation.(Inherited from UIElement)

> ManipulationInertiaStarting	

Occurs when the input device loses contact with the UIElement object during a manipulation and inertia begins.(Inherited from UIElement)

> ManipulationStarted	

Occurs when an input device begins a manipulation on the UIElement object.(Inherited from UIElement)

> ManipulationStarting	

Occurs when the manipulation processor is first created.(Inherited from UIElement)

> MouseDown	

Occurs when any mouse button is pressed while the pointer is over this element.(Inherited from UIElement)

> MouseEnter	

Occurs when the mouse pointer enters the bounds of this element.(Inherited from UIElement)

> MouseLeave	

Occurs when the mouse pointer leaves the bounds of this element.(Inherited from UIElement)

> MouseLeftButtonDown	

Occurs when the left mouse button is pressed while the mouse pointer is over this element.(Inherited from UIElement)

> MouseLeftButtonUp	

Occurs when the left mouse button is released while the mouse pointer is over this element.(Inherited from UIElement)

> MouseMove	

Occurs when the mouse pointer moves while over this element.(Inherited from UIElement)

> MouseRightButtonDown	

Occurs when the right mouse button is pressed while the mouse pointer is over this element.(Inherited from UIElement)

> MouseRightButtonUp	

Occurs when the right mouse button is released while the mouse pointer is over this element.(Inherited from UIElement)

> MouseUp	

Occurs when any mouse button is released over this element.(Inherited from UIElement)

> MouseWheel	

Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.(Inherited from UIElement)

> PreviewDragEnter	

Occurs when the input system reports an underlying drag event with this element as the drag target.(Inherited from UIElement)

> PreviewDragLeave	

Occurs when the input system reports an underlying drag event with this element as the drag origin.(Inherited from UIElement)

> PreviewDragOver	

Occurs when the input system reports an underlying drag event with this element as the potential drop target.(Inherited from UIElement)

> PreviewDrop	

Occurs when the input system reports an underlying drop event with this element as the drop target.(Inherited from UIElement)

> PreviewGiveFeedback	

Occurs when a drag-and-drop operation is started.(Inherited from UIElement)

> PreviewGotKeyboardFocus	

Occurs when the keyboard is focused on this element.(Inherited from UIElement)

> PreviewKeyDown	

Occurs when a key is pressed while focus is on this element.(Inherited from UIElement)

> PreviewKeyUp	

Occurs when a key is released while focus is on this element.(Inherited from UIElement)

> PreviewLostKeyboardFocus	

Occurs when the keyboard is no longer focused on this element.(Inherited from UIElement)

> PreviewMouseDown	

Occurs when any mouse button is pressed while the pointer is over this element.(Inherited from UIElement)

> PreviewMouseLeftButtonDown	

Occurs when the left mouse button is pressed while the mouse pointer is over this element.(Inherited from UIElement)

> PreviewMouseLeftButtonUp	

Occurs when the left mouse button is released while the mouse pointer is over this element.(Inherited from UIElement)

> PreviewMouseMove	

Occurs when the mouse pointer moves while the mouse pointer is over this element.(Inherited from UIElement)

> PreviewMouseRightButtonDown	

Occurs when the right mouse button is pressed while the mouse pointer is over this element.(Inherited from UIElement)

> PreviewMouseRightButtonUp	

Occurs when the right mouse button is released while the mouse pointer is over this element.(Inherited from UIElement)

> PreviewMouseUp	

Occurs when any mouse button is released while the mouse pointer is over this element.(Inherited from UIElement)

> PreviewMouseWheel	

Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.(Inherited from UIElement)

> PreviewQueryContinueDrag	

Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.(Inherited from UIElement)

> PreviewStylusButtonDown	

Occurs when the stylus button is pressed while the pointer is over this element.(Inherited from UIElement)

> PreviewStylusButtonUp	

Occurs when the stylus button is released while the pointer is over this element.(Inherited from UIElement)

> PreviewStylusDown	

Occurs when the stylus touches the digitizer while it is over this element.(Inherited from UIElement)

> PreviewStylusInAirMove	

Occurs when the stylus moves over an element without actually touching the digitizer.(Inherited from UIElement)

> PreviewStylusInRange	

Occurs when the stylus is close enough to the digitizer to be detected, while over this element.(Inherited from UIElement)

> PreviewStylusMove	

Occurs when the stylus moves while over the element. The stylus must move while being detected by the digitizer to raise this event, otherwise, PreviewStylusInAirMove is raised instead.(Inherited from UIElement)

> PreviewStylusOutOfRange	

Occurs when the stylus is too far from the digitizer to be detected.(Inherited from UIElement)

> PreviewStylusSystemGesture	

Occurs when a user performs one of several stylus gestures.(Inherited from UIElement)

> PreviewStylusUp	

Occurs when the user raises the stylus off the digitizer while the stylus is over this element.(Inherited from UIElement)

> PreviewTextInput	

Occurs when this element gets text in a device-independent manner.(Inherited from UIElement)

> PreviewTouchDown	

Occurs when a finger touches the screen while the finger is over this element.(Inherited from UIElement)

> PreviewTouchMove	

Occurs when a finger moves on the screen while the finger is over this element.(Inherited from UIElement)

> PreviewTouchUp	

Occurs when a finger is raised off of the screen while the finger is over this element.(Inherited from UIElement)

> QueryContinueDrag	

Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.(Inherited from UIElement)

> QueryCursor	

Occurs when the cursor is requested to display. This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.(Inherited from UIElement)

> RequestBringIntoView	

Occurs when BringIntoView(Rect) is called on this element.

SizeChanged	

Occurs when either the ActualHeight or the ActualWidth properties change value on this element.

SourceUpdated	

Occurs when the source value changes for any existing property binding on this element.

StylusButtonDown	

Occurs when the stylus button is pressed while the pointer is over this element.(Inherited from UIElement)

> StylusButtonUp	

Occurs when the stylus button is released while the pointer is over this element.(Inherited from UIElement)

> StylusDown	

Occurs when the stylus touches the digitizer while the stylus is over this element.(Inherited from UIElement)

> StylusEnter	

Occurs when the stylus enters the bounds of this element.(Inherited from UIElement)

> StylusInAirMove	

Occurs when the stylus moves over an element without actually touching the digitizer.(Inherited from UIElement)

> StylusInRange	

Occurs when the stylus is close enough to the digitizer to be detected, while over this element.(Inherited from UIElement)

> StylusLeave	

Occurs when the stylus leaves the bounds of the element.(Inherited from UIElement)

> StylusMove	

Occurs when the stylus moves over this element. The stylus must move while on the digitizer to raise this event. Otherwise, StylusInAirMove is raised instead.(Inherited from UIElement)

> StylusOutOfRange	

Occurs when the stylus is too far from the digitizer to be detected, while over this element.(Inherited from UIElement)

> StylusSystemGesture	

Occurs when a user performs one of several stylus gestures.(Inherited from UIElement)

> StylusUp	

Occurs when the user raises the stylus off the digitizer while it is over this element.(Inherited from UIElement)

> TargetUpdated	

Occurs when the target value changes for any property binding on this element.

> TextInput	

Occurs when this element gets text in a device-independent manner.(Inherited from UIElement)

> ToolTipClosing	

Occurs just before any tooltip on the element is closed.

> ToolTipOpening	

Occurs when any tooltip on the element is opened.

> TouchDown	

Occurs when a finger touches the screen while the finger is over this element.(Inherited from UIElement)

> TouchEnter	

Occurs when a touch moves from outside to inside the bounds of this element.(Inherited from UIElement)

> TouchLeave	

Occurs when a touch moves from inside to outside the bounds of this element.(Inherited from UIElement)

> TouchMove	

Occurs when a finger moves on the screen while the finger is over this element.(Inherited from UIElement)

> TouchUp	

Occurs when a finger is raised off of the screen while the finger is over this element.(Inherited from UIElement)

> Unloaded	

Occurs when the element is removed from within an element tree of loaded elements.

#### DependencyObject 

> 构建WPF/Silverlight的一个主要思想是属性优先于方法和事件。WPF/Silverlight 提供了丰富的属性系统，其核心是DependencyObject。

##### 方法:METHODS

> CheckAccess()	

Determines whether the calling thread has access to this DispatcherObject.(Inherited from DispatcherObject)

> ClearValue(DependencyProperty)	

Clears the local value of a property. The property to be cleared is specified by a DependencyProperty identifier.

> ClearValue(DependencyPropertyKey)	

Clears the local value of a read-only property. The property to be cleared is specified by a DependencyPropertyKey.

> CoerceValue(DependencyProperty)	

Coerces the value of the specified dependency property. This is accomplished by invoking any CoerceValueCallback function specified in property metadata for the dependency property as it exists on the calling DependencyObject.

> Equals(Object)	

Determines whether a provided DependencyObject is equivalent to the current DependencyObject.

> GetHashCode()	

Gets a hash code for this DependencyObject.

> GetLocalValueEnumerator()	

Creates a specialized enumerator for determining which dependency properties have locally set values on this DependencyObject.

> GetType()	

Gets the Type of the current instance.(Inherited from Object)

> GetValue(DependencyProperty)	

Returns the current effective value of a dependency property on this instance of a DependencyObject.

> InvalidateProperty(DependencyProperty)	

Re-evaluates the effective value for the specified dependency property.

> MemberwiseClone()	

Creates a shallow copy of the current Object.(Inherited from Object)

> OnPropertyChanged(DependencyPropertyChangedEventArgs)	

Invoked whenever the effective value of any dependency property on this DependencyObject has been updated. The specific dependency property that changed is reported in the event data.

> ReadLocalValue(DependencyProperty)	

Returns the local value of a dependency property, if it exists.

> SetCurrentValue(DependencyProperty, Object)	

Sets the value of a dependency property without changing its value source.

> SetValue(DependencyProperty, Object)	

Sets the local value of a dependency property, specified by its dependency property identifier.

> SetValue(DependencyPropertyKey, Object)	

Sets the local value of a read-only dependency property, specified by the DependencyPropertyKey identifier of the dependency property.

> ShouldSerializeProperty(DependencyProperty)	

Returns a value that indicates whether serialization processes should serialize the value for the provided dependency property.

> ToString()	

Returns a string that represents the current object.(Inherited from Object)

> VerifyAccess()	

Enforces that the calling thread has access to this DispatcherObject.(Inherited from DispatcherObject)

##### 属性:PROPERTIES

> DependencyObjectType	

Gets the DependencyObjectType that wraps the CLR type of this instance.

> Dispatcher	

Gets the Dispatcher this DispatcherObject is associated with.(Inherited from DispatcherObject)

> IsSealed	

Gets a value that indicates whether this instance is currently sealed (read-only).

> 主要作用是为WPF/Silverlight 提供２D呈现支持，主要包括输出显示，坐标转换，区域剪切等。

#### DispatcherObject

> WPF/Silverlight 中有许多类继承自DispatcherObject，DispatcherObject提供了处理同步和并发的基本构造。

##### 属性:

> Dispatcher	Gets the Dispatcher this DispatcherObject is associated with.

##### 方法:

> CheckAccess()	Determines whether the calling thread has access to this DispatcherObject.

> Equals(Object)	

Determines whether the specified object is equal to the current object.(Inherited from Object)

 

> GetHashCode()	

Serves as the default hash function.(Inherited from Object)

 

> GetType()	

Gets the Type of the current instance.(Inherited from Object)

 

> MemberwiseClone()	

Creates a shallow copy of the current Object.(Inherited from Object)

 

> ToString()	

Returns a string that represents the current object.(Inherited from Object)

 

> VerifyAccess()	

Enforces that the calling thread has access to this DispatcherObject.

#### System.Object

#### FrameworkElement

##### Page

##### Control

##### Image

##### Panel

> 而且还添加了一些功能，例如，布局定义、逻辑树、对象生命周期事件、支持数据绑定和动态资源引用、支持样式和动画。

##### 属性:

> ActualHeight	

Gets the rendered height of this element.

> ActualWidth	

Gets the rendered width of this element.

> AllowDrop	

Gets or sets a value indicating whether this element can be used as the target of a drag-and-drop operation. This is a dependency property.

> AreAnyTouchesCaptured	(Inherited from UIElement)

> Gets a value that indicates whether at least one touch is captured to this element.

> AreAnyTouchesCapturedWithin	(Inherited from UIElement)

> Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.

> AreAnyTouchesDirectlyOver	(Inherited from UIElement)

> Gets a value that indicates whether at least one touch is pressed over this element.

> AreAnyTouchesOver	(Inherited from UIElement)

> Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.

> BindingGroup	(Inherited from UIElement)

> Gets or sets the BindingGroup that is used for the element.

> BitmapEffect	

Obsolete.

Gets or sets a bitmap effect that applies directly to the rendered content for this element. This is a dependency property.

> BitmapEffectInput	(Inherited from UIElement)

> Obsolete.

Gets or sets an input source for the bitmap effect that applies directly to the rendered content for this element. This is a dependency property.

> CacheMode	(Inherited from UIElement)

> Gets or sets a cached representation of the UIElement.

> Clip	(Inherited from UIElement)

> Gets or sets the geometry used to define the outline of the contents of an element. This is a dependency property.

> ClipToBounds	(Inherited from UIElement)

> Gets or sets a value indicating whether to clip the content of this element (or content coming from the child elements of this element) to fit into the size of the containing element. This is a dependency property.

> CommandBindings	(Inherited from UIElement)

> Gets a collection of CommandBinding objects associated with this element. A CommandBinding enables command handling for this element, and declares the linkage between a command, its events, and the handlers attached by this element.

> ContextMenu	(Inherited from UIElement)

> Gets or sets the context menu element that should appear whenever the context menu is requested through user interface (UI) from within this element.

> Cursor	

Gets or sets the cursor that displays when the mouse pointer is over this element.

> DataContext	

Gets or sets the data context for an element when it participates in data binding.

> DefaultStyleKey	

Gets or sets the key to use to reference the style for this control, when theme styles are used or defined.

> DependencyObjectType	

Gets the DependencyObjectType that wraps the CLR type of this instance.

DesiredSize	(Inherited from DependencyObject)

Gets the size that this element computed during the measure pass of the layout process.

Dispatcher	(Inherited from UIElement)

> Gets the Dispatcher this DispatcherObject is associated with.(Inherited from DispatcherObject)

> Effect	

Gets or sets the bitmap effect to apply to the UIElement. This is a dependency property.

FlowDirection	(Inherited from UIElement)

> Gets or sets the direction that text and other user interface (UI) elements flow within any parent element that controls their layout.

Focusable	

Gets or sets a value that indicates whether the element can receive focus. This is a dependency property.(Inherited from UIElement)

> FocusVisualStyle	(Inherited from UIElement)

> Gets or sets a property that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.

> ForceCursor	

Gets or sets a value that indicates whether this FrameworkElement should force the user interface (UI) to render the cursor as declared by the Cursor property.

HasAnimatedProperties	

Gets a value indicating whether this element has any animated properties.(Inherited from UIElement)

> HasEffectiveKeyboardFocus	(Inherited from UIElement)

> Gets a value that indicates whether the UIElement has focus.(Inherited from UIElement)

> Height	(Inherited from UIElement)

> Gets or sets the suggested height of the element.

> HorizontalAlignment	

Gets or sets the horizontal alignment characteristics applied to this element when it is composed within a parent element, such as a panel or items control.

> InheritanceBehavior	

Gets or sets the scope limits for property value inheritance, resource key lookup, and RelativeSource FindAncestor lookup.

> InputBindings	

Gets the collection of input bindings associated with this element.(Inherited from UIElement)

> InputScope	(Inherited from UIElement)

> Gets or sets the context for input used by this FrameworkElement.

> IsArrangeValid	

Gets a value indicating whether the computed size and position of child elements in this element's layout are valid.(Inherited from UIElement)

> IsEnabled	(Inherited from UIElement)

> Gets or sets a value indicating whether this element is enabled in the user interface (UI). This is a dependency property.(Inherited from UIElement)

> IsEnabledCore	(Inherited from UIElement)

> Gets a value that becomes the return value of IsEnabled in derived classes.(Inherited from UIElement)

> IsFocused	(Inherited from UIElement)

> Gets a value that determines whether this element has logical focus. This is a dependency property.(Inherited from UIElement)

> IsHitTestVisible	(Inherited from UIElement)

> Gets or sets a value that declares whether this element can possibly be returned as a hit test result from some portion of its rendered content. This is a dependency property.(Inherited from UIElement)

> IsInitialized	(Inherited from UIElement)

> Gets a value that indicates whether this element has been initialized, either during processing by a XAML processor, or by explicitly having its EndInit() method called.

> IsInputMethodEnabled	

Gets a value indicating whether an input method system, such as an Input Method Editor (IME), is enabled for processing the input to this element.(Inherited from UIElement)

> IsKeyboardFocused	(Inherited from UIElement)

> Gets a value indicating whether this element has keyboard focus. This is a dependency property.(Inherited from UIElement)

> IsKeyboardFocusWithin	

Gets a value indicating whether keyboard focus is anywhere within the element or its visual tree child elements. This is a dependency property.(Inherited from UIElement)

> IsLoaded	(Inherited from UIElement)

> Gets a value that indicates whether this element has been loaded for presentation.

> IsManipulationEnabled	

Gets or sets a value that indicates whether manipulation events are enabled on this UIElement.(Inherited from UIElement)

> IsMeasureValid	(Inherited from UIElement)

> Gets a value indicating whether the current size returned by layout measure is valid.(Inherited from UIElement)

> IsMouseCaptured	(Inherited from UIElement)

> Gets a value indicating whether the mouse is captured to this element. This is a dependency property.(Inherited from UIElement)

> IsMouseCaptureWithin	(Inherited from UIElement)

> Gets a value that determines whether mouse capture is held by this element or by child elements in its visual tree. This is a dependency property.(Inherited from UIElement)

> IsMouseDirectlyOver	(Inherited from UIElement)

> Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account. This is a dependency property.(Inherited from UIElement)

> IsMouseOver	(Inherited from UIElement)

> Gets a value indicating whether the mouse pointer is located over this element (including child elements in the visual tree). This is a dependency property.(Inherited from UIElement)

> IsSealed	(Inherited from UIElement)

> Gets a value that indicates whether this instance is currently sealed (read-only).

> IsStylusCaptured		(Inherited from DependencyObject)

Gets a value indicating whether the stylus is captured by this element. This is a dependency property.(Inherited from UIElement)

> IsStylusCaptureWithin	(Inherited from UIElement)

> Gets a value that determines whether stylus capture is held by this element, or an element within the element bounds and its visual tree. This is a dependency property.(Inherited from UIElement)

> IsStylusDirectlyOver	(Inherited from UIElement)

> Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account. This is a dependency property.(Inherited from UIElement)

> IsStylusOver	(Inherited from UIElement)

> Gets a value indicating whether the stylus cursor is located over this element (including visual child elements). This is a dependency property.(Inherited from UIElement)

> IsVisible	(Inherited from UIElement)

> Gets a value indicating whether this element is visible in the user interface (UI). This is a dependency property.(Inherited from UIElement)

> Language	(Inherited from UIElement)

> Gets or sets localization/globalization language information that applies to an element.

> LayoutTransform	

Gets or sets a graphics transformation that should apply to this element when layout is performed.

> LogicalChildren	

Gets an enumerator for logical child elements of this element.

> Margin	

Gets or sets the outer margin of an element.

> MaxHeight	

Gets or sets the maximum height constraint of the element.

> MaxWidth	

Gets or sets the maximum width constraint of the element.

> MinHeight	

Gets or sets the minimum height constraint of the element.

> MinWidth	

Gets or sets the minimum width constraint of the element.

> Name	

Gets or sets the identifying name of the element. The name provides a reference so that code-behind, such as event handler code, can refer to a markup element after it is constructed during processing by a XAML processor.

> Opacity	

Gets or sets the opacity factor applied to the entire UIElement when it is rendered in the user interface (UI). This is a dependency property.(Inherited from UIElement)

> OpacityMask	(Inherited from UIElement)

> Gets or sets an opacity mask, as a Brush implementation that is applied to any alpha-channel masking for the rendered content of this element. This is a dependency property.(Inherited from UIElement)

> OverridesDefaultStyle	(Inherited from UIElement)

> Gets or sets a value that indicates whether this element incorporates style properties from theme styles.

> Parent	

Gets the logical parent element of this element.

> PersistId	

Obsolete.

Gets a value that uniquely identifies this element.(Inherited from UIElement)

> RenderSize	(Inherited from UIElement)

> Gets (or sets) the final render size of this element.(Inherited from UIElement)

> RenderTransform	(Inherited from UIElement)

> Gets or sets transform information that affects the rendering position of this element. This is a dependency property.(Inherited from UIElement)

> RenderTransformOrigin	(Inherited from UIElement)

> Gets or sets the center point of any possible render transform declared by RenderTransform, relative to the bounds of the element. This is a dependency property.(Inherited from UIElement)

> Resources	(Inherited from UIElement)

> Gets or sets the locally-defined resource dictionary.

SnapsToDevicePixels	

Gets or sets a value that determines whether rendering for this element should use device-specific pixel settings during rendering. This is a dependency property.(Inherited from UIElement)

> Style	(Inherited from UIElement)

> Gets or sets the style used by this element when it is rendered.

StylusPlugIns	

Gets a collection of all stylus plug-in (customization) objects associated with this element.(Inherited from UIElement)

> Tag	(Inherited from UIElement)

> Gets or sets an arbitrary object value that can be used to store custom information about this element.

> TemplatedParent	

Gets a reference to the template parent of this element. This property is not relevant if the element was not created through a template.

> ToolTip	

Gets or sets the tool-tip object that is displayed for this element in the user interface (UI).

> TouchesCaptured	

Gets all touch devices that are captured to this element.(Inherited from UIElement)

> TouchesCapturedWithin	(Inherited from UIElement)

> Gets all touch devices that are captured to this element or any child elements in its visual tree.(Inherited from UIElement)

> TouchesDirectlyOver	(Inherited from UIElement)

> Gets all touch devices that are over this element.(Inherited from UIElement)

> TouchesOver	(Inherited from UIElement)

> Gets all touch devices that are over this element or any child elements in its visual tree.(Inherited from UIElement)

> Triggers	(Inherited from UIElement)

> Gets the collection of triggers established directly on this element, or in child elements.

> Uid	

Gets or sets the unique identifier (for localization) for this element. This is a dependency property.(Inherited from UIElement)

> UseLayoutRounding	(Inherited from UIElement)

> Gets or sets a value that indicates whether layout rounding should be applied to this element's size and position during layout.

> VerticalAlignment	

Gets or sets the vertical alignment characteristics applied to this element when it is composed within a parent element such as a panel or items control.

> Visibility	

Gets or sets the user interface (UI) visibility of this element. This is a dependency property.(Inherited from UIElement)

> VisualBitmapEffect	(Inherited from UIElement)

> Obsolete.

Gets or sets the BitmapEffect value for the Visual.

> VisualBitmapEffectInput	(Inherited from Visual)

Obsolete.

Gets or sets the BitmapEffectInput value for the Visual.

> VisualBitmapScalingMode	(Inherited from Visual)

Gets or sets the BitmapScalingMode for the Visual.

> VisualCacheMode	(Inherited from Visual)

Gets or sets a cached representation of the Visual.

> VisualChildrenCount	(Inherited from Visual)

Gets the number of visual child elements within this element.

> VisualClearTypeHint	

Gets or sets the ClearTypeHint that determines how ClearType is rendered in the Visual.

> VisualClip	(Inherited from Visual)

Gets or sets the clip region of the Visual as a Geometry value.

> VisualEdgeMode	(Inherited from Visual)

Gets or sets the edge mode of the Visual as an EdgeMode value.

> VisualEffect	(Inherited from Visual)

Gets or sets the bitmap effect to apply to the Visual.

> VisualOffset	(Inherited from Visual)

Gets or sets the offset value of the visual object.

> VisualOpacity	(Inherited from Visual)

Gets or sets the opacity of the Visual.

> VisualOpacityMask	(Inherited from Visual)

Gets or sets the Brush value that represents the opacity mask of the Visual.

> VisualParent	(Inherited from Visual)

Gets the visual tree parent of the visual object.

> VisualScrollableAreaClip	(Inherited from Visual)

Gets or sets a clipped scrollable area for the Visual.

> VisualTextHintingMode	

Gets or sets the TextHintingMode of the Visual.

> VisualTextRenderingMode	(Inherited from Visual)

Gets or sets the TextRenderingMode of the Visual.

> VisualTransform	(Inherited from Visual)

Gets or sets the Transform value for the Visual.

> VisualXSnappingGuidelines	(Inherited from Visual)

Gets or sets the x-coordinate (vertical) guideline collection.

> VisualYSnappingGuidelines	(Inherited from Visual)

Gets or sets the y-coordinate (horizontal) guideline collection.

> Width	(Inherited from Visual)

Gets or sets the width of the element.

##### Fielsds:

> ActualHeightProperty	

Identifies the ActualHeight dependency property.

> ActualWidthProperty	

Identifies the ActualWidth dependency property.

> BindingGroupProperty	

Identifies the BindingGroup dependency property.

> ContextMenuClosingEvent	

Identifies the ContextMenuClosing routed event.

> ContextMenuOpeningEvent	

Identifies the ContextMenuOpening routed event.

> ContextMenuProperty	

Identifies the ContextMenu dependency property.

> CursorProperty	

Identifies the Cursor dependency property.

> DataContextProperty	

Identifies the DataContext dependency property.

> DefaultStyleKeyProperty	

Identifies the DefaultStyleKey dependency property.

> FlowDirectionProperty	

Identifies the FlowDirection dependency property.

> FocusVisualStyleProperty	

Identifies the FocusVisualStyle dependency property.

> ForceCursorProperty	

Identifies the ForceCursor dependency property.

> HeightProperty	

Identifies the Height dependency property.

> HorizontalAlignmentProperty	

Identifies the HorizontalAlignment dependency property.

> InputScopeProperty	

Identifies the InputScope dependency property.

> LanguageProperty	

Identifies the Language dependency property.

> LayoutTransformProperty	

Identifies the LayoutTransform dependency property.

> LoadedEvent	

Identifies the Loaded routed event.

> MarginProperty	

Identifies the Margin dependency property.

> MaxHeightProperty	

Identifies the MaxHeight dependency property.

> MaxWidthProperty	

Identifies the MaxWidth dependency property.

> MinHeightProperty	

Identifies the MinHeight dependency property.

> MinWidthProperty	

Identifies the MinWidth dependency property.

> NameProperty	

Identifies the Name dependency property.

> OverridesDefaultStyleProperty	

Identifies the OverridesDefaultStyle dependency property.

> RequestBringIntoViewEvent	

Identifies the RequestBringIntoView routed event.

> SizeChangedEvent	

Identifies the SizeChanged routed event.

> StyleProperty	

Identifies the Style dependency property.

> TagProperty	

Identifies the Tag dependency property.

> ToolTipClosingEvent	

Identifies the ToolTipClosing routed event.

> ToolTipOpeningEvent	

Identifies the ToolTipOpening routed event.

> ToolTipProperty	

Identifies the ToolTip dependency property.

> UnloadedEvent	

Identifies the Unloaded routed event.

> UseLayoutRoundingProperty	

Identifies the UseLayoutRounding dependency property.

> VerticalAlignmentProperty	

Identifies the VerticalAlignment dependency property.

> WidthProperty	

Identifies the Width dependency property.

### 属性

#### 普通属性

#### 附加属性

> 与依赖项属性区别

> > 一。附加属性使用的RegisterAttached方法，而依赖属性使用的是Register方法

> > 二。附加属性使用两个方法进行包装，依赖属性使用CLR属性对GetValue和SetValue两个方法进行包装

> 主要用途，附加项属性值修改时可以获取到被修改对象，

> > 然后去修改该对象的属性，

> > 例如可以绑定附加项属性去修改被附加对象的非依赖项属性等

```

        public static readonly DependencyProperty AngleProperty =

            DependencyProperty.RegisterAttached("Angle", typeof(double), typeof(RotationManager), new PropertyMetadata(0.0,OnAngleChanged));

        private static void OnAngleChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e)

        {

            var element = obj as UIElement;

            if (element != null)

            {

                element.RenderTransformOrigin = new Point(0.5, 0.5);

                element.RenderTransform = new RotateTransform((double)e.NewValue);

            }

        }

```

#### 依赖项属性dependency property

> 使用效率更高的保存机制

> 附加功能

> 更改通知

> 属性值继承

> 使用

> > 注册依赖项属性

> > 添加属性包装器

> 特征

> > 依赖属性提供用来扩展属性功能的功能，这与字段支持的属性相反。 通常，此类功能代表或支持以下特定功能之一：

> > 资源

> > 数据绑定

> > 样式

> > 动画

> > 元数据重写

> > 在从最初注册依赖属性的类派生时，可以通过重写依赖属性的元数据来更改该属性的某些行为。 重写元数据依赖于 DependencyProperty 标识符。 重写元数据不需要重新实现 属性。 元数据的更改由属性系统在本机处理；对于所有从基类继承的属性，每个类都有可能基于每个类型保留元数据。

以下示例重写依赖属性 DefaultStyleKey 的元数据。 重写此特定依赖属性的元数据是某个实现模式的一部分，该模式创建可以使用主题中的默认样式的控件。

```

public class SpinnerControl : ItemsControl

{

    static SpinnerControl()

    {

        DefaultStyleKeyProperty.OverrideMetadata(

            typeof(SpinnerControl),

            new FrameworkPropertyMetadata(typeof(SpinnerControl))

        );

    }

}

```

> > 属性值继承

> > 下面的示例演示一个绑定，并设置指定绑定（在前面的绑定示例中未显示出来）的源的 DataContext 属性。 子对象中的任何后续绑定都无需指定源，它们可以使用父对象 StackPanel 中 DataContext 的继承值。 （或者，子对象可以选择直接在 Binding 中指定自己的 DataContext 或 Source，并且有意不将继承值用于其绑定的数据上下文。）

```

<StackPanel Canvas.Top="50" DataContext="{Binding Source={StaticResource XmlTeamsSource}}">

  <Button Content="{Binding XPath=Team/@TeamName}"/>

</StackPanel>

```

####  WPF 设计器集成

> 如何自定义依赖属性

> > 1、声明依赖属性变量。依赖属性的声明都是通过public static来公开一个静态变量，变量的类型必须是DependencyProperty

> > 2、在属性系统中进行注册。使用DependencyProperty.Register方法来注册依赖属性，或者是使用DependencyProperty.RegisterReadOnly方法来注册

> > 3、使用.NET属性包装依赖属性

```

 public static DependencyProperty TextProperty;

       TextProperty =

       DependencyProperty.Register("Text", //属性名称

       typeof(string), //属性类型

       typeof(TestDependencyPropertyWindow), //该属性所有者，即将该属性注册到那个类上

       new PropertyMetadata("")); //属性默认值

public string Text

{

   get { return (string)GetValue(TextProperty); }

   set { SetValue(TextProperty, value); }

}

```

> 依赖属性的特点

> > 1、属性变更通知

> > 无论什么时候，只要依赖属性的值发生改变，wpf就会自动根据属性的元数据触发一系列的动作，这些动作可以重新呈现UI元素，也可以更新当前的布局，刷新数据绑定等等，这种变更的通知最有趣的特点之一就是属性触发器，它可以在属性值改变的时候，执行一系列自定义的动作，而不需要更改任何其他的代码来实现。通过下面的示例来演示属性变更通知

> > 2、属性值继承

> > 是指属性值自顶向下沿着元素树进行传递。

> > 3、节省内存空间

> > 依赖属性和CLR属性在内存的使用上是截然不同的，每个CLR属性都包含一个非static的字段，因此当我们实例化一个类型的时候，就会创建该类型所拥有的所有CLR属性，也就是说一个对象所占用的内存在调用new操作进行实例化的时候就已经决定了、而wpf允许对象在创建的时候并不包含用于存储数据的空间，只保留在需要用到数据的时候能够获得该默认值，即用其他对象数据或者实时分配空间的能力。

> 共享依赖项属性

### 事件

#### 普通事件

##### 生命周期事件

> > 在元素被初始化，加载或卸载时发生。

> a.Initialized 元素被实例化，但是窗口的其他部分可能还没有初始化。还没有应用样式和数据绑定。

> b.Loaded 事件 ，应用了样式和数据绑定时，

> c.Unloaded 当元素被释放时，窗口被关闭或特定的元素被从窗口中删除

> FrameworkElement类实现了ISuppertInitialize接口，调用BeginInit()方法，XAML解析器设置所有元素的属性。调用EndInit（），引发Initalized事件。

> 包含其他所有元素的窗口首先引发Loaded事件，都引发了Loaded事件之后，窗口就变的可见了。

##### 鼠标事件

> > 鼠标动作的结果。

##### 键盘事件

> > 键盘动作的结果。

> PreviewKeyDown事件：隧道事件，按键触发

> KeyDown事件：冒泡事件，按键触发

> PreviewTextInput事件：隧道事件，按键完成接受文本输入触发。

> TextInput事件：冒泡事件，按键完成接受文本输入触发。

> PreviewKeyUp事件：隧道事件，释放键触发

> KeyUp事件：冒泡事件，释放键触发

##### 手写笔事件

> > 类似铅笔的手写笔的结果

##### 多点触控事件

#### 路由事件

> > （向上冒泡或者向下隧道传播（Preview开始的事件））

> 定义 注册 封装路由事件（RoutedEvent）

> 共享  引发 处理路由事件

> 分类

> > 冒泡：由事件源向上传递一直到根元素

> > 直接：只有事件源才有机会响应事件

> > 隧道：从元素树的根部调用事件处理程序并依次向下深入直到事件源

#### 附加事件

#### VisualStateManager

### 资源

#### 样式

> 样式基础

> > 样式(Style)是组织和重用格式化选项的重要工具。不是使用重复的标记填充XAML,以便设置外边距、内边距、颜色以及字体等细节，而是创建一系列封装所有这些细节的样式，然后再需要之处通过属性来应用样式。样式是可应用于元素的属性值集合。使用资源的最常见原因之一就是保存样式。使按钮具有统一格式的实现方式一：资源

> 设置属性

```

<Setter Property="FontFamily" Value="Times New Roman"/>

```

> 创建只应用按钮的样式  

```

<Style x:Key="BigFontButtonStyle" TargetType="Button">

    <Setter Property="FontFamily" Value="Times New Roman"/>

    <Setter Property="FontSize" Value="18"/>

    <Setter Property="FontWeight" Value="Bold"/>

</Style>

```

> 关联事件处理程序

```

 <Window.Resources>

        <Style x:Key="MouseOverHighlightStyle">

            <EventSetter Event="TextBlock.MouseEnter" Handler="element_MouseEnter"></EventSetter>

            <EventSetter Event="TextBlock.MouseLeave" Handler="element_MouseLeave"></EventSetter>

        </Style>

    </Window.Resources>

    <Grid Name="gird1" ShowGridLines="True">

        <TextBlock Style="{StaticResource MouseOverHighlightStyle}"></TextBlock>

    </Grid>

```

> 多层样式

```

 <Window.Resources>

        <Style x:Key="BigFontButtonStyle">

            <Setter Property="Control.FontFamily" Value="Times New Roman"/>

            <Setter Property="Control.FontSize" Value="18"/>

            <Setter Property="Control.FontWeight" Value="Bold"/>

        </Style>

        <Style x:Key="NewBigButtonBigFontStyle" BasedOn="{StaticResource BigFontButtonStyle}">

            <Setter Property="Control.Foreground" Value="Red"/>

            <Setter Property="Control.Background" Value="DarkBlue"/>

        </Style>

    </Window.Resources>

    <Grid Name="gird1" ShowGridLines="True">

        <TextBlock Style="{StaticResource NewBigButtonBigFontStyle}">test</TextBlock>

    </Grid>

```

> 通过类型自动应用样式

```

 <Window.Resources>

        <Style TargetType="Button">

            <Setter Property="Control.FontFamily" Value="Times New Roman"/>

            <Setter Property="Control.FontSize" Value="18"/>

            <Setter Property="Control.FontWeight" Value="Bold"/>

        </Style>

    </Window.Resources>

    <Grid Name="gird1" ShowGridLines="True">

        <Button>one</Button>

        <Button Style="{x:Null}">two</Button>

        <Button>three</Button>

    </Grid>

```

#### 触发器

> Trigger	这是一种最简单的触发器。可以监测依赖项属性的变化，然后设置器改变样式。

```

   <Window.Resources>

        <Style x:Key="BigFontButton">

            <Style.Setters>

                <Setter Property="Control.FontFamily" Value="Times New Roman"/>

                <Setter Property="Control.FontSize" Value="18"/>

                <Setter Property="Control.FontWeight" Value="Bold"/>

            </Style.Setters>

            <Style.Triggers>

                <Trigger Property="Control.IsFocused" Value="True">

                    <Setter Property="Control.Foreground" Value="DarkRed"/>

                </Trigger>

            </Style.Triggers>

        </Style>

    </Window.Resources>

```

> MultiTrigger	与Trigger类似，但这种触发器联合了多个条件。只有满足了所有这些条件，才会启动触发器。

    <Style.Triggers>

                <MultiDataTrigger>

                    <MultiDataTrigger.Conditions>

                        <Condition Property="Control.IsFocused" Value="true"/>

                        <Condition Property="Control.IsMouseOver" Value="true"/>

                    </MultiDataTrigger.Conditions>

                    <MultiDataTrigger.Setters>

                        <Setter Property="Control.Foreground" Value="DarkRed"/>

                    </MultiDataTrigger.Setters>

                </MultiDataTrigger>

            </Style.Triggers>

> DataTrigger	这种触发器使用数据绑定，与Trigger类似，只不过监视的是任意绑定数据的变化。

```

 <Window.Resources>

        <Style x:Key="BigFontButton">

            <Style.Setters>

                <Setter Property="Control.FontFamily" Value="Times New Roman"/>

                <Setter Property="Control.FontSize" Value="18"/>

                <Setter Property="Control.FontWeight" Value="Bold"/>

            </Style.Setters>

            <Style.Triggers>

                <EventTrigger RoutedEvent="Mouse.MouseEnter">

                    <EventTrigger.Actions>

                        <BeginStoryboard>

                            <Storyboard>

                                <DoubleAnimation Duration="0:0:3" Storyboard.TargetProperty="FontSize"

                                                 To="50"/>

                            </Storyboard>

                        </BeginStoryboard>

                    </EventTrigger.Actions>

                </EventTrigger>

                <EventTrigger RoutedEvent="Mouse.MouseLeave">

                    <EventTrigger.Actions>

                        <BeginStoryboard>

                            <Storyboard>

                                <DoubleAnimation Duration="0:0:3" Storyboard.TargetProperty="FontSize"/>

                            </Storyboard>

                        </BeginStoryboard>

                    </EventTrigger.Actions>

                </EventTrigger>

            </Style.Triggers>

        </Style>

    </Window.Resources>

    <Grid Name="gird1" ShowGridLines="True">

        <Button HorizontalAlignment="Center" VerticalAlignment="Center" Style="{StaticResource BigFontButton}">onesfsfsfsfsdfsdf</Button>

    </Grid>

```

> MultiDataTrigger	联合多个数据触发器。

> EventTrigger	这是最复杂的触发器。当事件发生时，这种触发器应用动画。

#### 模板

> 资源是保存在可执行文件中的一种不可执行数据。在WPF的资源中，几乎可以包含图像、字符串等所有的任意CLR对象，只要对象有一个默认的构造函数和独立的属性。也就是说，应用程序中非程序代码的内容，比如点阵图、颜色、字型、动画/影片档以及字符串常量值，可将它们从程序中独立出来，单独包装成"资源(Resource)"。

#### 使用资源的优势：

> 1. 由于不用写在程序代码中，方便管理：便于更新。

> 2. 优化资源，节省空间。资源一旦定义，便可重复利用。还记得FLASH中的将物体转换为元件吗？一旦将物体转换为元件，就可以重复利用了。在WPF中，似乎与之有共通之处。所不同的是，WPF将资源保存在XAML中，对我们而言是“可见的”。

#### 资源的范围（层级）：

> WPF提供一个封装和存取资源(resource)的机制，我们可将资源建立在应用程序的不同范围上。WPF中，资源定义的位置决定了该资源的可用范围。资源可以定义在如下范围中：

> (1)物件级：此时，资源只能套用在这个Object物件，或套用至该物件的子物件。

> (2)文件级：如果将资源定义在Window或Page层级的XAML档中，那么可以套用到这个文件中的所有物件。

> (3)应用程序级：如果我们将资源定义在App.xaml 中，那么，就可以将资源套用到应用程序内的任何地方。

> (4)字典级：当我们把资源封装成一个资源字典, 定义到一个ResourceDictionary的XAML文件时,就可以在另一个应用程序中重复使用。

### WPF 体系结构

#### milcore 

> 是以非托管代码编写的，实现与 DirectX 的紧密集成。性能敏感

> milcore.dll是WPF渲染系统的核心，也是媒体集成层的基础。

#### WindowsCodes.dll

> 提供图像支持的低级API(处理、显示以及缩放位图与JPEG图像)

#### Direct3D是图形渲染

#### User32

> 决定实际占有桌面部分。

> 注意：不管拖动，缩放，milcore负责绘制程序恰当部分。

### CopyPaste(WPF)

> 需要拦截WIndows消息处理 IPasteAble，ICopyAble由相应控件实现,如果不实现则使用默认机制处理。

#### ICopyAble

```

 public interface ICopyAble

    {

        /// <summary>

        /// 复制操作

        /// </summary>

        /// <param name="IsDeleteSource">是否删除源</param>

        /// <returns></returns>

        CopyPasteData Copy(bool IsDeleteSource);

        /// <summary>

        /// 剪贴版的清空操作

        /// </summary>

        /// <param name="Data"></param>

        void Remove(CopyPasteData Data);

    }

```

####  IPasteAble

```

    /// <summary>

    /// 复制粘贴服务接口

    /// 可以根据用户自己实现具体支持的数据类型所以定义为泛型类

    /// </summary>

    /// <typeparam name="T"></typeparam>

    public interface IPasteAble

    {

        /// <summary>

        /// 粘贴操作

        /// </summary>

        void Paste(CopyPasteData Data);

    }

```

#### CopyPasteProxy

```

    public class CopyPasteProxy

    {

        public CopyPasteData Data { get; set; }

        public ICopyAble Source { get; set; }

        public void Copy(ICopyAble Source,bool IsDeleteSource)

        {

            this.Source = Source;

            if (Source != null)

            {

                Data = Source.Copy(IsDeleteSource);

            }

            else

            {

                Data = new CopyPasteData();

            }

        }

        public void Paste(IPasteAble Destination, bool IsDeleteSource)

        {

            if (Destination != null)

            {

                Destination.Paste(Data);

                if (IsDeleteSource)

                {

                    Source.Remove(Data);

                }

            }

        }

        public void OnCopy(bool IsDeleteSource)

        {

            if (Keyboard.FocusedElement is DependencyObject)

            {

                var c = GetParent<ICopyAble>(Keyboard.FocusedElement as DependencyObject);

                if (c != null && c is ICopyAble)

                {

                    Copy(c as ICopyAble, IsDeleteSource);

                }

            }

        }

        public void OnPaste(bool IsDeleteSource)

        {

            if (Keyboard.FocusedElement is DependencyObject)

            {

                var p = GetParent<IPasteAble>(Keyboard.FocusedElement as DependencyObject);

                if (p != null && p is IPasteAble)

                {

                    Paste(p as IPasteAble, IsDeleteSource);

                }

            }

        }

        private DependencyObject GetParent<T>(DependencyObject o)

        {

            if (o != null && o is DependencyObject)

            {

                var p = VisualTreeHelper.GetParent(o as UIElement);

                if (p != null && p is T)

                {

                    return p;

                }

                else if(p != null)

                {

                    return GetParent<T>(p);

                }

                {

                    return null;

                }

            }

            return null;

        }

    }

```

#### CopyPasteData

```

  public class CopyPasteData

    {

        /// <summary>

        /// 数据类型

        /// </summary>

        public string DataType { get; set; } = "ClipboardDataFromMemo";

        /// <summary>

        /// 数据是否从系统剪贴版获取

        /// </summary>

        public bool IsFromClipboard { get; set; } = true;

        /// <summary>

        /// 数据对象 IsFromClipboard为true则此值无效需要直接获取剪贴板数据

        /// </summary>

        public object Data { get; set; } = null;

        /// <summary>

        /// 获取剪贴板数据

        /// 数据对象 IsFromClipboard为true则此值有效 当然客户可以直接从系统剪贴板直接获取数据

        /// </summary>

        public IDataObject ClipboardData

        {   get

            {

                return Clipboard.GetDataObject();

            } 

        }

    }

```

### Behavior

> 其实就是对通用的事件作一些封装成为行为Behavior 使之通用减少代码量，大多是业务无关的，比如触发一些鼠标移动的动态效果等。

> 老版引用System.Windows.Interactivity.dll

> 新版.net 引用 Microsoft.Xaml.Behaviors;

> 重写Behavior里面的两个函数OnAttached（附加后）与OnDetaching（分离时）

```

using Microsoft.Xaml.Behaviors;

using System;

using System.Collections.Generic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows;

using System.Windows.Media;

using System.Windows.Media.Effects;

namespace Inovance.FA.FAOutTest.Behaviors

{

    public class EffectBehavior : Behavior<FrameworkElement>

    {

        //使用 Behavior 必须重写以下两个虚方法

        protected override void OnAttached()

        {

            base.OnAttached();

            //AssociatedObject为关联对象， 是Behavior<T>中的T

            AssociatedObject.MouseMove += AssociatedObject_MouseMove;

            AssociatedObject.MouseLeave += AssociatedObject_MouseLeave;

        }

        private void AssociatedObject_MouseLeave(object sender, System.Windows.Input.MouseEventArgs e)

        {

            var element = sender as FrameworkElement;

            element.Effect = (Effect)new DropShadowEffect() { Color = Colors.Transparent, ShadowDepth = 0 };

        }

        private void AssociatedObject_MouseMove(object sender, System.Windows.Input.MouseEventArgs e)

        {

            var element = sender as FrameworkElement;

            element.Effect = (Effect)new DropShadowEffect() { Color = Colors.Red, ShadowDepth = 0 };

        }

        protected override void OnDetaching()

        {

            base.OnDetaching();

            AssociatedObject.MouseMove -= AssociatedObject_MouseMove;

            AssociatedObject.MouseLeave -= AssociatedObject_MouseLeave;

        }

    }

}

```

### Command

> WPF的命令系统由几个基本要素构成，它们是：

#### 命令(Command)

> WPF的命令实际上就是实现了ICommand接口的类，平时使用最多的就是RoutedCommand类。我们还会学习使用自定义命令。

> ICommand接口与RoutedCommand

> WPF中的命令是实现了ICommand接口的类。ICommand接口非常简单，只包含两个方法和一个事件：

> Execute方法：命令执行，或者说命令执行于命令目标之上。需要注意的是，现实世界中的命令是不会自己执行的，而这里，执行变成了命令的方法，有点拟人化的味道。

> CanExecute方法：在执行之前探知命令是否可以执行。

> CanExecuteChanged事件：当命令的可执行状态改变的时候，可激发此事件通知其它对象。

> RoutedCommand就是一个实现了ICommand接口的类。RoutedCommand在实现ICommand接口时，并未向Execute和CanExecute方法中添加任何逻辑，也就是说，它是通用的、与具体的业务逻辑无关的。怎么理解“与具体的业务逻辑无关这句话呢”？我们从外部和内部两部分来理解。

#### 命令源(Command Source)

> 即命令的发送者，是实现了ICommandSource接口的类。很多界面元素都实现了这个接口，其中包括Button,ListBoxItem,MenuItem等。

#### 命令目标(Command Target)

> 即命令发送给谁，或者说命令作用在谁的身上。命令目标必须是实现了IInputElement接口的类。

#### 命令关联(Command Binding)

> 负责把一些外围逻辑和命令关联起来，比如执行之前对命令是否可以执行进行判断、命令执行之后还有哪些后续工作等。

### MVVM

#### Model

#### View

#### ViewModel

> INotifyPropertyChanged ViwModel

```

public abstract class ViewModel : INotifyPropertyChanged

    {

        public ILogger Logger { get; set; }

        public IMessageBox MessageBox { get; set; }

        public ViewModel()

        {

            Logger = StaticData.Container.GetExportedValue<ILogger>();

            MessageBox = StaticData.Container.GetExportedValue<IMessageBox>();

        }

        public string Name

        {

            get

            {

                return this.GetType().Name;

            }

        }

        public bool? dialogResult;

        public bool? DialogResult

        {

            get

            {

                return dialogResult;

            }

            set

            {

                dialogResult = value;

                RaisePropertyChanged("DialogResult");

            }

        }

        protected virtual void RaisePropertyChanged(string propertyName)

        {

            if (PropertyChanged != null)

                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));

        }

        public event PropertyChangedEventHandler PropertyChanged;

        public bool SetProperty<T>(ref T Source, T NewValue, [CallerMemberName] string? propertyName = null) where T : IComparable

        {

            if (EqualityComparer<T>.Default.Equals(Source, NewValue))

            {

                return false;

            }

            else

            {

                Source = NewValue;

                RaisePropertyChanged(propertyName);

            }

            return true;

        }

    }

```

> 屬性就可以簡寫成為一下方法：

```

public List<DataNode> projectNodes;

               public List<DataNode> ProjectNodes{

            get => projectNodes;

            set => SetProperty(ref projectNodes, value);

        }

```

### Application類

#### 应用程序事件

> Startup：该事件在调用Application.Run()方法之后，并且在主窗口显示之前执行。

> > （1）、处理命令行参数。

> > （2）、打开主窗口。

> > （3）、初始化应用程序范围的资源。

> > （4）、初始化应用程序范围的属性。

> Exit：该事件在应用程序关闭时(不管什么原因)

> SessionEnding：该事件在Windows对话结束时发生

> Activated：当激活应用程序中的窗口时发生该事件，当切换到另外一个window程序时也会触发。

> > 1、  应用程序打开第一个窗口。

> > 2、  用户使用Alt+Tab组合件或者使用任务管理器切换到该应用程序。

> > 3、  用户单击应用程序中一个窗口的任务栏按钮。

> Deactivated：当取消激活应用程序中的窗口时发生该事件，当切换到另外一个window程序时也会触发。

> DispatcherUnhandledException：应用程序只要发生未处理的异常，都会进入该事件。还可将Handled属性设置为true，继续运行应用程序。

### Prism

Prism框架 如何在主程序中合理的弹出子窗体

说起子窗体，大家都会想到ChildWindow，多熟悉的一个控件。不错，Sliverlight中已经提供了子窗体的具体实现，而在WPF中却没有这么好的事情（有的第三方控件商已经提供此控件）。最常见的实现方法就是在ViewModel中，直接New ChildWindow，然后直接Show。这样的方法也达到的要求。但是它不符合MVVM分层思想，再就是代码不美观，难以维护，今天我就给大家介绍一种美观又实用的方法。

通过Prism中提供的InteractionRequestTrigger事件触发器，实现点击按钮或者用户的某种操作弹出对话框的效果。另外，不要忘了引用此命名空间：

```

using Microsoft.Practices.Prism.Interactivity.InteractionRequest;

<Window x:Class="ChildWindowDemo.ChildWindow.ChildWindow"

        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"

        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"

        xmlns:i="http://schemas.microsoft.com/expression/2010/interactivity"  

        xmlns:ei="http://schemas.microsoft.com/expression/2010/interactions"

        Width="300" Height="150" 

        Title="{Binding Title}"

        x:Name="confirmationWindow" Topmost="True" WindowStyle="ToolWindow" WindowStartupLocation="CenterScreen">

    <Grid x:Name="LayoutRoot" Margin="2">

        <Grid.RowDefinitions>

            <RowDefinition />

            <RowDefinition Height="Auto" />

        </Grid.RowDefinitions>

        <ContentControl HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Grid.Row="0" Content="{Binding Content}"/>

        <Button Content="Cancel" Width="75" Height="23" HorizontalAlignment="Right" Margin="0,12,0,0" Grid.Row="1">

            <i:Interaction.Triggers>

                <i:EventTrigger EventName="Click">

                    <ei:CallMethodAction TargetObject="{Binding ElementName=confirmationWindow}" MethodName="Close"/>

                </i:EventTrigger>

            </i:Interaction.Triggers>

        </Button>

        <Button Content="OK" Width="75" Height="23" HorizontalAlignment="Right" Margin="0,12,79,0" Grid.Row="1">

            <i:Interaction.Triggers>

                <i:EventTrigger EventName="Click">

                    <ei:ChangePropertyAction PropertyName="Confirmed" TargetObject="{Binding}" Value="True"/>

                    <ei:CallMethodAction TargetObject="{Binding ElementName=confirmationWindow}" MethodName="Close"/>

                </i:EventTrigger>

            </i:Interaction.Triggers>

        </Button>

    </Grid>

</Window>

```

创建ChildWindow的基类

新建类：ChildWindowActionBase 并从TriggerAction<T>派生，代码如下：

 

```

public class ChildWindowActionBase : TriggerAction<FrameworkElement>

    {

        protected override void Invoke(object parameter)

        {

            var arg = parameter as InteractionRequestedEventArgs;

            if (arg == null)

                return;

            var windows = this.GetChildWindow(arg.Context);

            var callback = arg.Callback;

            EventHandler handler = null;

            handler =

                (o, e) =>

                {

                    windows.Closed -= handler;

                    callback();

                };

            windows.Closed += handler;

            windows.ShowDialog();

        }

        Window GetChildWindow(Notification notification)

        {

            var childWindow = this.CreateDefaultWindow(notification);

            childWindow.DataContext = notification;

            return childWindow;

        }

        Window CreateDefaultWindow(Notification notification)

        {

            return (Window)new ChildWindow.ChildWindow();

        }

    }

```

到此子窗体已经完成

```

<Window x:Class="ChildWindowDemo.MainWindow"

        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"

        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"

        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"

        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"

        xmlns:prism="http://www.codeplex.com/prism"

        xmlns:i="http://schemas.microsoft.com/expression/2010/interactivity"

        xmlns:local="clr-namespace:ChildWindowDemo"

        Title="MainWindow" Height="200" Width="300">

    <i:Interaction.Triggers>

        <prism:InteractionRequestTrigger SourceObject="{Binding ConfirmationRequest, Mode=OneWay}">

            <local:ChildWindowActionBase/>

        </prism:InteractionRequestTrigger>

    </i:Interaction.Triggers>

    <Grid>

        <Button Command="{Binding RaiseConfirmation}" Content="Click Me !" HorizontalAlignment="Left" Margin="29,31,0,0" VerticalAlignment="Top" Width="217" Height="55"/>

        <TextBlock HorizontalAlignment="Left" Margin="29,106,0,0" TextWrapping="Wrap" Text="{Binding ConfirmationResult}" VerticalAlignment="Top"/>

    </Grid>

</Window>

```

对之对应的ViewModel：

```

public class MainWindowViewModel : NotificationObject

    {

        public MainWindowViewModel()

        {

            this.RaiseConfirmation = new DelegateCommand(this.OnRaiseConfirmation);

            this.ConfirmationRequest = new InteractionRequest<Confirmation>();

        }

        public InteractionRequest<Confirmation> ConfirmationRequest { get; private set; }

        public DelegateCommand RaiseConfirmation { get; private set; }

        private string result;

        public string ConfirmationResult

        {

            get { return result; }

            set

            {

                result = value;

                this.RaisePropertyChanged(() => this.ConfirmationResult);

            }

        }

        private void OnRaiseConfirmation()

        {

            this.ConfirmationRequest.Raise(

                new Confirmation { Content = "是否确认", Title = "子窗体" },

                (cb) => { ConfirmationResult = cb.Confirmed ? "确认" : "取消"; });

        }      

    }

```

这样的写法比较符合MVVM的分层思想，子窗体可以随心定制，而不需要去改逻辑层的代码。

http://www.cnblogs.com/sunthx/p/3539900.html

#### Prism框架 如何在主程序中合理的弹出子窗体

￿﻿[{"data":{"id":"cf4vho08ndk0","created":1634797901390,"text":"https://www.cnblogs.com/tianciliangen/p/4961045.html","richText":{"ops":[{"attributes":{},"insert":"https://www.cnblogs.com/tianciliangen/p/4961045.html"},{"insert":"\n","attributes":{}}]},"background":"transparent"},"children":[]}]

#### Prism框架中一些非常重要的概念

#####  Modules

> Modules是能够独立开发、测试、部署的功能单元，

> Modules可以被设计成实现特定业务逻辑的模块（如Profile Management），也可以被设计成实现通用基础设施或服务的模块  　（如Logging、Exception Management）。

##### Module Catalog：

> 在Prism中，Module Catalog指明了要Load哪些Module，和用什么样的顺序去Load这些Module。

##### Shell

> Shell是宿主应用程序（host application），modules将会被load到Shell中。

> Shell定义了应用程序的整体布局和结构，而不关心寄宿其中的Module，Shell通常实现通用的application service和infrastructure，而应用的逻辑则实现在具体的Module中，同时，Shell也提供了应用程序的顶层窗口。

##### Views：

> Views是应用中展现特定功能的视图，它展现UI、定义交互行为，并且通过数据绑定的方式与ViewModel进行交互。

##### View Model和Presenters

> View Model用来封装应用程序的UI逻辑及其状态。

###### Model

> Model被用来封装数据和相应的验证，以及相关的业务规则来保证数据的一致性和正确性。

###### Commands

> Command被用来封装应用程序功能，Prism提供了Delegate Command和CompositeCommand两个类。

###### Regions：

> Regions是应用程序UI的逻辑区域，它很像一个PlaceHolder，Views在Regions中展现，很多种控件可以被用作Region：ContentControl、ItemsControl、ListBox、TabControl。Views能在Regions编程或者自动呈现，Prism也提供了Region导航的支持。

##### Navigation

> Prism支持两种导航：state-based导航和view-switching导航。

##### EventAggregator

> 组件通常要和其它的组件或者服务进行通信。为此，Prism提供了EventAggregator组件，这个组件实现pub-sub事件机制，允许一些组件发布事件，另一些组件去订阅事件而无需两个组件之间的引用。

##### Dependency Injection container

> Prism使用依赖注入模式来管理组件之间的依赖，Prism被设计使用Unity、Mef等依赖注入容器。

##### Services：

> Services是用来实现非UI相关功能的逻辑，例如logging、exception management、data access。Services可以被定义在应用程序中或者是Module中，Services通常被注册在依赖注入容器中，使得其它的组件可以很容易的定位这个服务。

##### Controllers

> Controller被用来控制在Region中哪个View将会被呈现，同时控制这个View的创建和初始化。

##### Bootstrapper：

> Bootstrapper用来初始化应用程序级别的组件和服务， 它也被用来配置和初始化module catalog和Shell 的View和View Model。

#### Prism 简介#

> Prism 是一个用于构建松耦合、可维护和可测试的 XAML 应用的框架，它支持所有还活着的基于 XAML 的平台，包括 WPF、Xamarin Forms、WinUI 和 Uwp Uno。Prism 提供了一组设计模式的实现，这些模式有助于编写结构良好且可维护的 XAML 应用程序，包括 MVVM、依赖项注入、命令、事件聚合器等。

> Prism 是一个有10年以上历史的框架，而上个月才刚发布了它的 8.0 版本，这意味着现在网上能找到的大部分 Prism 的资料都已经有点过时，连 官方文档 也不例外。如果你需要详细的文档，除了官方文档，我会推荐 RyzenAdorer 的 Prism 系列文章：

> NET Core 3 WPF MVVM框架 Prism系列文章索引 - RyzenAdorer -

> 如果你不需要那么详细的文档，只需要一个入门的教程，那么我希望我写的这两篇文章可以帮到你。

#### Prism.Core、Prism.Wpf 和 Prism.Unity#

> 从很久以前开始，臃肿 就是 Prism 被提起最多的标签。毕竟比起 MVVMLight，Prism 实现的功能更多；对于初学者来说，刚打开 Prism 的文档很可能会马上选择放弃。Prism 的文档详细到让人望而却步，例如多年前的旧版官方文档的 其中一篇：

> 不是 6 分钟，不是 16 分账，是整整 60 分钟，Prism 的旧文档随便打开一篇都吓死人。而 Prism 的各种包更是多到离谱。例如几年前的 Prism 6.3，其中 WPF 平台的项目有这么多个：

> Prism.Wpf

> Prism.Autofac

> Prism.DryIoc

> Prism.Mef

> Prism.Ninject

> Prism.StructureMap

> Prism.Unity

> 所以臃肿是很多人对 Prism 的印象。

> 减肥是一个永恒的受欢迎的话题，对 Prism 也是一样。相比 Prism 6.3，刚刚发布的 8.0 已经好很多了（虽然还是有很多个项目），例如 WPF 平台的项目已经大幅删减，只保留了 Prism.Wpf、Prism.DryIoc 和 Prism.Unity，也就是说现在 Prism 只支持 DryIoc 和 Unity 两种 IOC 容器。这样一来 Prism 项目的结构就很清晰了。

> 以 WPF 为例，核心的项目是 Prism.Core，它提供实现 MVVM 模式的核心功能以及部分各平台公用的类。然后是 Prism.Wpf，它提供针对 Wpf 平台的功能，包括导航、弹框等。最后由 Prism.Unity 指定 Unity 作为 IOC 容器。

> 即使已精简了这么多，Prism 还是有很多功能，两篇文章也不足以讲解全部内容，所以我只会介绍最常用到的入门知识。这篇文章首先介绍 Prism.Core 的主要功能。

#### Prism.Core#

> Prism.Core 可以单独安装，目前最新的版本是 8.0.0.1909：

> Install-Package Prism.Core -Version 8.0.0.1909

> 除了一些各个平台都用到的零零碎碎的公用类，作为一个 MVVM 库 Prism.Core 主要提供了下面三方面的功能：

> BindableBase 和 ErrorsContainer

> Commanding

> Event Aggregator

> 这些功能已经覆盖了 MVVM 的核心功能，如果只需要与具体平台无关的 MVVM 功能，可以只安装 Prism.Core。

#### BindableBase 和 ErrorsContainer#

> 数据绑定是 MVVM 的核心元素之一，为了使绑定的数据可以和 UI 交互，数据类型必须继承 INotifyPropertyChanged。 BindableBase 实现了 INotifyPropertyChanged 最简单的封装，它的使用如下：

```

public class MockViewModel : BindableBase

{

    private string _myProperty;

    public string MyProperty

    {

        get { return _myProperty; }

        set { SetProperty(ref _myProperty, value); }

    }

}

```

> 其中 SetProperty 判断 _myProperty 和 value 是否相等，如果不相等就为 _myProperty 赋值并触发 OnPropertyChanged 事件。

> 除了 INotifyPropertyChanged，绑定机制中另一个十分有用的接口是 INotifyDataErrorInfo，它用于公开数据验证的结果。Prism 提供了 ErrorsContainer 以便管理及通知数据验证的错误信息。要使用 ErrorsContainer，可以先写一个类似这样的基类：

```

public class DomainObject : BindableBase, INotifyDataErrorInfo

{

    public ErrorsContainer<string> _errorsContainer;

    protected ErrorsContainer<string> ErrorsContainer

    {

        get

        {

            if (_errorsContainer == null)

                _errorsContainer = new ErrorsContainer<string>(s => OnErrorsChanged(s));

            return _errorsContainer;

        }

    }

    public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

    public void OnErrorsChanged(string propertyName)

    {

        ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));

    }

    public IEnumerable GetErrors(string propertyName)

    {

        return ErrorsContainer.GetErrors(propertyName);

    }

    public bool HasErrors

    {

        get { return ErrorsContainer.HasErrors; }

    }

}

```

> 然后就可以在派生类中通过 ErrorsContainer.SetErrors 和 ErrorsContainer.ClearErrors 管理数据验证的错误信息：

```

public class MockValidatingViewModel : DomainObject

{

    private int mockProperty;

    public int MockProperty

    {

        get

        {

            return mockProperty;

        }

        set

        {

            SetProperty(ref mockProperty, value);

            if (mockProperty < 0)

                ErrorsContainer.SetErrors(() => MockProperty, new string[] { "value cannot be less than 0" });

            else

                ErrorsContainer.ClearErrors(() => MockProperty);

        }

    }

}

```

#### Commanding

> ICommand 同样是 MVVM 模式的核心元素，DelegateCommand 实现了 ICommand 接口，它最基本的使用形式如下，其中 DelegateCommand 构造函数中的第二个参数 canExecuteMethod 是可选的：

```

public DelegateCommand SubmitCommand { get; private set; }

public CheckUserViewModel()

{

    SubmitCommand = new DelegateCommand(Submit, CanSubmit);

}

private void Submit()

{

    //implement logic

}

private bool CanSubmit()

{

    return true;

}

```

> 另外它还有泛型的版本：

```

public DelegateCommand<string> SubmitCommand { get; private set; }

public CheckUserViewModel()

{

    SubmitCommand = new DelegateCommand<string>(Submit, CanSubmit);

}

private void Submit(string parameter)

{

    //implement logic

}

private bool CanSubmit(string parameter)

{

    return true;

}

```

> 通常 UI 会根据 ICommand 的 CanExecute 函数的返回值来判断触发此 Command 的 UI 元素是否可用。CanExecute 返回 DelegateCommand 构造函数中的第二个参数 canExecuteMethod 的返回值。如果不传入这个参数，则 CanExecute 一直返回 True。

> 如果 CanExecute 的返回值有变化，可以调用 RaiseCanExecuteChanged 函数，它会触发 CanExecuteChanged 事件并通知 UI 元素重新判断绑定的 ICommand 是否可用。除了主动调用 RaiseCanExecuteChanged，DelegateCommand 还可以用 ObservesProperty 和 ObservesCanExecute 两种形式监视属性，定于属性的 PropertyChanged 事件并改变 CanExecute：

```

private bool _isEnabled;

public bool IsEnabled

{

    get { return _isEnabled; }

    set { SetProperty(ref _isEnabled, value); }

}

private bool _canSave;

public bool CanSave

{

    get { return _canSave; }

    set { SetProperty(ref _canSave, value); }

}

public CheckUserViewModel()

{

    SubmitCommand = new DelegateCommand(Submit, CanSubmit).ObservesProperty(() => IsEnabled);

    //也可以写成串联方式

    SubmitCommand = new DelegateCommand(Submit, CanSubmit).ObservesProperty(() => IsEnabled).ObservesProperty<bool>(() => CanSave);

    SubmitCommand = new DelegateCommand(Submit).ObservesCanExecute(() => IsEnabled);

}

```

#### Event Aggregator

> 本来Event Aggregator（事件聚合器）或 Messenger 之类的组件本来并不是 MVVM 的一部分，不过现在也成了 MVVM 框架的一个重要元素。解耦是 MVVM 的一个重要目标，'EventAggregator' 则是实现解耦的重要工具。在 MVVM 中，对于 View 和与他匹配的 ViewModel 之间的交互，可以使用 INotifyProperty 和 Icommand；而对于必须通信的不同 ViewModel 或模块，为了使它们之间实现低耦合，可以使用 Prism 中的 EventAggregator。如下图所示，Publisher 和 Scbscriber 之间没有直接关联，它们通过 Event Aggregator 获取 PubSubEvent 并发送及接收消息：

> 要使用 EventAggregator，首先需要定义 PubSubEvent：

> public class TickerSymbolSelectedEvent : PubSubEvent<string>{}

> 发布方和订阅方都通过 EventAggregator 索取 PubSubEvent，在 ViewModel中通常都是通过依赖注入获取一个 IEventAggregator：

```

public class MainPageViewModel

{

    IEventAggregator _eventAggregator;

    public MainPageViewModel(IEventAggregator ea)

    {

        _eventAggregator = ea;

    }

}

```

> 发送方的操作很简单，只需要 通过 GetEvent 拿到 PubSubEvent，把消息发布出去，然后拍拍屁股走人，其它的责任都不用管：

> eventAggregator.GetEvent<TickerSymbolSelectedEvent>().Publish("STOCK0");

> 订阅方是真正使用这些消息并负责任的人，下面是最简单的通过 Subscribe 订阅事件的代码：

```

public class MainPageViewModel

{

    public MainPageViewModel(IEventAggregator ea)

    {

        ea.GetEvent<TickerSymbolSelectedEvent>().Subscribe(ShowNews);

    }

    void ShowNews(string companySymbol)

    {

        //implement logic

    }

}

```

> 除了基本的调用方式，Subscribe 函数还有其它可选的参数：

> public virtual SubscriptionToken Subscribe(Action action, ThreadOption threadOption, bool keepSubscriberReferenceAlive)

> 其中 threadOption 指示收到消息后在哪个线程上执行第一个参数定义的 action，它有三个选项：

> PublisherThread，和发布者保持在同一个线程上执行。

> UIThread，在 UI 线程上执行。

> BackgroundThread，在后台线程上执行。

> 第三个参数 keepSubscriberReferenceAlive 默认为 false，它指示该订阅是否为强引用。

> 设置为 false 时，引用为弱引用，用完可以不用管。

> 设置为 true 时，引用为强引用，用完需要使用 Unsubscribe 取消订阅。

> 下面代码是一段订阅及取消订阅的示例：

```

public class MainPageViewModel

{

    TickerSymbolSelectedEvent _event;

    public MainPageViewModel(IEventAggregator ea)

    {

        _event = ea.GetEvent<TickerSymbolSelectedEvent>();

        _event.Subscribe(ShowNews);

    }

    void Unsubscribe()

    {

        _event.Unsubscribe(ShowNews);

    }

    void ShowNews(string companySymbol)

    {

        //implement logic

    }

}

```

#### Productivity Tools

####  Prism.Wpf 和 Prism.Unity

这篇是 Prism 8.0 入门的第二篇文章，上一篇介绍了 Prism.Core，这篇文章主要介绍 Prism.Wpf 和 Prism.Unity。

以前做 WPF 和 Silverlight/Xamarin 项目的时候，我有时会把 ViewModel 和 View 放在不同的项目，ViewModel 使用 可移植类库项目，这样 ViewModel 就与 UI 平台无关，实现了代码复用。这样做还可以强制 View 和 ViewModel 解耦。

现在，即使在只写 WPF 项目的情况下，但为了强制 ViewModel 和 View 假装是陌生人，做到不留后路，我也倾向于把 View 和 ViewModel 放到不同项目，并且 ViewModel 使用 .Net Standard 作为目标框架。我还会假装下个月 UWP 就要崛起了，我手头的 WPF 项目中的 ViewModel 要做到平台无关，方便我下个月把项目移植到 UWP 项目中。

但如果要使用 Prism 构建 MVVM 程序的话，上面这些根本不现实。首先，Prism 做不到平台无关，它针对不同的平台提供了不同的包，分别是：

针对 WPF 的 Prism.Wpf

针对 Xamarin Forms 的 Prism.Forms

针对 Uno 平台的 Prism.Uno

其次，根本就没有针对 UWP 的 Prism.Windows（UWP 还有未来，忍住别哭）。

所以，除非只使用 Prism.Core，否则要将 ViewModel 项目共享给多个平台有点困难，毕竟用在 WPF 项目的 Prism.Wpf 本身就是个 Wpf 类库。

现在“编写平台无关的 ViewModel 项目”这个话题就与 Prism 无关了，再把 Prism.Unity 和 Prism.Wpf 选为代表（毕竟这个组合比其它组合下载量多些），这篇文章就只用它们作为 Prism 入门的学习对象。

Prism.Core、Prism.Wpf 和 Prism.Unity 的依赖关系如上所示。其中 Prism.Core 实现了 MVVM 的核心功能，它是一个与平台无关的项目。Prism.Wpf 里包含了 Dialog Service、Region、Module 和导航等几个模块，都是些用在 WPF 的功能。Prism.Unity 本身没几行代码，它表示为 Prism.Wpf 选择了 UnityContainer 作为 IOC 容器。（另外还有 Prism.DryIoc 可以选择，但从下载量看 Prism.Unity 是主流。）

就算只学习 Prism.Wpf，可它的模块很多，一篇文章实在塞不下。我选择了 Dialog Service 作为代表，因为它的实现思想和其它的差不多，而且弹窗还是 WPF 最常见的操作。这篇文章将通过以下内容讲解如何使用 Prism.Wpf 构建一个 WPF 程序：

PrismApplication

RegisterTypes

XAML ContainerProvider

ViewModelLocator

Dialog Service

Prism 的最新版本是 8.0.0.1909。由于 Prism.Unity 依赖 Prism.Wpf，所以只需安装 Prism.Unity：

Install-Package Prism.Unity -Version 8.0.0.1909

#### PrismApplication#

安装好 Prism.Wpf 和 Prism.Unity 后，下一步要做的是将 App.xaml 的类型替换为 PrismApplication。

Copy

<prism:PrismApplication x:Class="PrismTest.App"

                        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"

                        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"

                        xmlns:prism="http://prismlibrary.com/">

    <Application.Resources>

    </Application.Resources>

</prism:PrismApplication>

上面是修改过的 App.xaml，将 Application 改为 prism:PrismApplication，并且移除了 StartupUri="MainWindow.xaml"。

接下来不要忘记修改 App.xaml.cs：

Copy

public partial class App : PrismApplication

{

    public App()

    {

    }

    protected override Window CreateShell()

        => Container.Resolve<ShellWindow>();

}

PrismApplication 不使用 StartupUri ，而是使用 CreateShell 方法创建主窗口。CreateShell 是必须实现的抽象函数。PrismApplication 提供了 Container 属性，CreateShell 函数里通常使用 Container 创建主窗口。

#### RegisterTypes

其实在使用 CreateShell 函数前，首先必须实现另一个抽象函数 RegisterTypes。由于 Prism.Wpf 相当依赖于 IOC，所以要现在 PrismApplication 里注册必须的类型或依赖。PrismApplication 里已经预先注册了 DialogService、EventAggregator、RegionManager 等必须的类型（在 RegisterRequiredTypes 函数里），其它类型可以在 RegisterTypes 里注册。它看起来像这样：

Copy

protected override void RegisterTypes(IContainerRegistry containerRegistry)

{

    // Core Services

    // App Services

    // Views

    containerRegistry.RegisterForNavigation<BlankPage, BlankViewModel>(PageKeys.Blank);

    containerRegistry.RegisterForNavigation<MainPage, MainViewModel>(PageKeys.Main);

    containerRegistry.RegisterForNavigation<ShellWindow, ShellViewModel>();

    // Configuration

    var configuration = BuildConfiguration();

    // Register configurations to IoC

    containerRegistry.RegisterInstance<IConfiguration>(configuration);

}

#### XAML ContainerProvider#

在 XAML 中直接实例化 ViewModel 并设置 DataContext 是 View 和 ViewModel 之间建立关联的最基本的方法：

Copy

<UserControl.DataContext>

    <viewmodels:MainViewModel/>

</UserControl.DataContext>

但现实中很难这样做，因为相当一部分 ViewModel 都会在构造函数中注入依赖，而 XAML 只能实例化具有无参数构造函数的类型。为了解决这个问题，Prism 提供了 ContainerProvider 这个工具，通过设置 Type 或 Name 从 Container 中解析请求的类型，它的用法如下：

Copy

<TextBlock

  Text="{Binding

    Path=Foo,

    Converter={prism:ContainerProvider {x:Type local:MyConverter}}}" />

<Window>

  <Window.DataContext>

    <prism:ContainerProvider Type="{x:Type local:MyViewModel}" />

  </Window.DataContext>

</Window>

#### ViewModelLocator

Prism 还提供了 ViewModelLocator，用于将 View 的 DataContext 设置为对应的 ViewModel：

Copy

<Window x:Class="Demo.Views.MainWindow"

    ...

    xmlns:prism="http://prismlibrary.com/"

    prism:ViewModelLocator.AutoWireViewModel="True">

在将 View 的 ViewModelLocator.AutoWireViewModel 附加属性设置为 True 的同时，Prism 会为查找这个 View 对应的 ViewModel 类型，然后从 Container 中解析这个类型并设置为 View 的 DataContext。它首先查找 ViewModelLocationProvider 中已经使用 Register 注册的类型，Register 函数的使用方式如下：

Copy

ViewModelLocationProvider.Register<MainWindow, CustomViewModel>();

如果类型未在 ViewModelLocationProvider 中注册，则根据约定好的命名方式找到 ViewModel 的类型，这是默认的查找逻辑的源码：

Copy

var viewName = viewType.FullName;

viewName = viewName.Replace(".Views.", ".ViewModels.");

var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName;

var suffix = viewName.EndsWith("View") ? "Model" : "ViewModel";

var viewModelName = String.Format(CultureInfo.InvariantCulture, "{0}{1}, {2}", viewName, suffix, viewAssemblyName);

return Type.GetType(viewModelName);

例如 PrismTest.Views.MainView 这个类，对应的 ViewModel 类型就是 PrismTest.ViewModels.MainViewModel。

当然很多项目都不符合这个命名规则，那么可以在 App.xaml.cs 中重写 ConfigureViewModelLocator 并调用 ViewModelLocationProvider.SetDefaultViewTypeToViewModelTypeResolver 改变这个查找规则：

Copy

protected override void ConfigureViewModelLocator()

{

    base.ConfigureViewModelLocator();

    ViewModelLocationProvider.SetDefaultViewTypeToViewModelTypeResolver((viewType) =>

    {

        var viewName = viewType.FullName.Replace(".ViewModels.", ".CustomNamespace.");

        var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName;

        var viewModelName = $"{viewName}ViewModel, {viewAssemblyName}";

        return Type.GetType(viewModelName);

    });

}

#### Dialog Service

Prism 7 和 8 相对于以往的版本最大的改变在于 View 和 ViewModel 的交互，现在的处理方式变得更加易于使用，这篇文章以其中的 DialogService 作为代表讲解 Prism 如何实现 View 和 ViewModel 之间的交互。

DialogService 内部会调用 ViewModelLocator.AutoWireViewModel，所以使用 DialogService 调用的 View 无需添加这个附加属性。

以往在 WPF 中需要弹出一个窗口，首先新建一个 Window，然后调用 ShowDialog，ShowDialog 阻塞当前线程，直到弹出的 Window 关闭，这时候还可以拿到一个返回值，具体代码差不多是这样：

Copy

var window = new CreateUserWindow { Owner = this };

var dialogResult = window.ShowDialog();

if (dialogResult == true)

{

    var user = window.User;

    //other code;

}

简单直接有用。但在 MVVM 模式中，开发者要假装自己不知道要调用的 View，甚至不知道要调用的 ViewModel。开发者只知道要执行的这个操作的名字，要传什么参数，拿到什么结果，至于具体由谁去执行，开发者要假装不知道（虽然很可能都是自己写的）。为了做到这种效果，Prism 提供了 IDialogService 接口。这个接口的具体实现已经在 PrismApplication 里注册了，用户通常只需要从构造函数里注入这个服务：

Copy

public MainWindowViewModel(IDialogService dialogService)

{

    _dialogService = dialogService;

}

IDialogService 提供两组函数，分别是 Show 和 ShowDialog，对应非模态和模态窗口。它们的参数都一样：弹出的对话框的名称、传入的参数、对话框关闭时调用的回调函数：

Copy

void ShowDialog(string name, IDialogParameters parameters, Action<IDialogResult> callback);

其中 IDialogResult 类型包含 ButtonResult 类型的 Result 属性和 IDialogParameters 类型的 Parameters 属性，前者用于标识关闭对话框的动作（Yes、No、Cancel等），后者可以传入任何类型的参数作为具体的返回结果。下面代码展示了一个基本的 ShowDialog 函数调用方式：

Copy

var parameters = new DialogParameters

{

    { "UserName", "Admin" }

};

_dialogService.ShowDialog("CreateUser", parameters, dialogResult =>

{

    if (dialogResult.Result == ButtonResult.OK)

    {

        var user = dialogResult.Parameters.GetValue<User>("User");

        //other code

    }

});

为了让 IDialogService 知道上面代码中 “CreateUser” 对应的 View，需要在 'App,xaml.cs' 中的 RegisterTypes 函数中注册它对应的 Dialog：

Copy

containerRegistry.RegisterDialog<CreateUserView>("CreateUser");

上面这种注册方式需要依赖 ViewModelLocator 找到对应的 ViewModel，也可以直接注册 View 和对应的 ViewModel：

Copy

containerRegistry.RegisterDialog<CreateUserView, CreateUserViewModel>("CreateUser");

有没有发现上面的 CreateUserWindow 变成了 CreateUserView？因为使用 DialogService 的时候，View 必须是一个 UserControl，DialogService 自己创建一个 Window 将 View 放进去。这样做的好处是 View 可以不清楚自己是一个弹框或者导航的页面，或者要用在拥有不同 Window 样式的其它项目中，反正只要实现逻辑就好了。由于 View 是一个 UserControl，它不能直接控制拥有它的 Window，只能通过在 View 中添加附加属性定义 Window 的样式：

Copy

<prism:Dialog.WindowStyle>

    <Style TargetType="Window">

        <Setter Property="prism:Dialog.WindowStartupLocation" Value="CenterScreen" />

        <Setter Property="ResizeMode" Value="NoResize"/>

        <Setter Property="ShowInTaskbar" Value="False"/>

        <Setter Property="SizeToContent" Value="WidthAndHeight"/>

    </Style>

</prism:Dialog.WindowStyle>

最后一步是实现 ViewModel。对话框的 ViewModel 必须实现 IDialogAware 接口，它的定义如下：

Copy

public interface IDialogAware

{

    /// <summary>

    /// 确定是否可以关闭对话框。

    /// </summary>

    bool CanCloseDialog();

    /// <summary>

    /// 关闭对话框时调用。

    /// </summary>

    void OnDialogClosed();

    /// <summary>

    /// 在对话框打开时调用。

    /// </summary>

    void OnDialogOpened(IDialogParameters parameters);

    /// <summary>

    /// 将显示在窗口标题栏中的对话框的标题。

    /// </summary>

    string Title { get; }

    /// <summary>

    /// 指示 IDialogWindow 关闭对话框。

    /// </summary>

    event Action<IDialogResult> RequestClose;

}

一个简单的实现如下：

Copy

public class CreateUserViewModel : BindableBase, IDialogAware

{

    public string Title => "Create User";

    public event Action<IDialogResult> RequestClose;

    private DelegateCommand _createCommand;

    public DelegateCommand CreateCommand => _createCommand ??= new DelegateCommand(Create);

    private string _userName;

    public string UserName

    {

        get { return _userName; }

        set { SetProperty(ref _userName, value); }

    }

   

    public virtual void RaiseRequestClose(IDialogResult dialogResult)

    {

        RequestClose?.Invoke(dialogResult);

    }

    public virtual bool CanCloseDialog()

    {

        return true;

    }

    public virtual void OnDialogClosed()

    {

    }

    public virtual void OnDialogOpened(IDialogParameters parameters)

    {

        UserName = parameters.GetValue<string>("UserName");

    }

    protected virtual void Create()

    {

        var parameters = new DialogParameters

        {

            { "User", new User{Name=UserName} }

        };

        RaiseRequestClose(new DialogResult(ButtonResult.OK, parameters));

    }

}

上面的代码在 OnDialogOpened 中读取传入的参数，在 RaiseRequestClose 关闭对话框并传递结果。至此就完成了弹出对话框并获取结果的整个流程。

自定义 Window 样式在 WPF 程序中很流行，DialogService 也支持自定义 Window 样式。假设 MyWindow 是一个自定义样式的 Window，自定义一个继承它的 MyPrismWindow 类型，并实现接口 IDialogWindow：

Copy

public partial class MyPrismWindow: MyWindow, IDialogWindow

{

    public IDialogResult Result { get; set; }

}

然后调用 RegisterDialogWindow 注册这个 Window 类型。

Copy

protected override void RegisterTypes(IContainerRegistry containerRegistry)

{

    containerRegistry.RegisterDialogWindow<MyPrismWindow>();

}

这样 DialogService 将会使用这个自定义的 Window 类型作为 View 的窗口。

### 拖拽

> https://github.com/punker76/gong-wpf-dragdrop

### WPF的类层次结构

> System.Threading.DispatcherObject类——继承DispatcherObject类，用户界面的元素检查是否在正确的线程，访问调度程序为用户界面线程封送代码。

> System.Windows.DependencyObject类——和屏幕上的元素进行交互主要通过属性进行。 继承DependencyObject类，获得对依赖项属性的支持。

> System.Windows.Media.Visual类——看做绘图对象，Visual类在托管的WPF库和渲染桌面的milcore.dll提供了链接

> System.Windows.UIElement类——UIElement类为WPF本质特征提供支持，如布局、输入、焦点以及事件。实现了成为路由事件的路由系统(第5章)，添加对命令的支持(第9章)

> System.Windows.FrameworkElement类——实现了全部由UIElement类定义的成员。引入数据绑定和样式。

> System.Windows.Shapes.Shape类——基本的形状类都继承自该类

> System.Windows.Controls.Control类——控件是可以和用户进行交互的元素。Control类为设置字体和前景色与背景色提供了附加功能，还有模板支持(第17章)。

> System.Windows.Controls.ContentControl类——所有具有单一内容的控件的基类。控件中的单一内容可以是从普通的字符串乃至具有其他形状和控件组合的布局面板(第6章)。

> System.Windows.Controls.ItemsControl类——是所有显示选项集合的控件的基类，如ListBox控件和TreeView控件

> System.Windows.Controls.Panel类——是所有布局器的基类，布局容器是可以包含一个或多个子元素，并根据特定的规则对子元素进行排列的元素。

### XAML

> x: 前缀：用于映射 XAML xmlns http://schemas.microsoft.com/winfx/2006/xaml。

> x:Class属性（Attribute）：编译成C#代码后对应的类名，如果手动把该属性改成其他后台代码中不包含的类名称，编译后会自动生成该类。如果与后台代码的类名称相同则进行合并（后台代码中的类要用partial修饰）。

> x:Key：为 ResourceDictionary 中的每个资源设置一个唯一的键。

> x:Name：为运行时代码中存在的实例指定运行时对象名称。

> x:Static：启用一个获取静态值的值引用，该静态值只能是一个 XAML 可设置属性。

> x:Type：根据类型名称构造Type 引用。指定采用 Type 的属性 

> XAML的树形结构：

> XAML都是一个树，有唯一根节点，通常为Window或Page。

> 提供VisualTreeHelper和LogicTreeHelper两个帮助类用来查找或操作树。

##### VisualTreeHelper

> 1、FindElementsInHostCoordinates 检索一组对象，这些对象位于某一对象的坐标空间的指定点或 Rect 内。

> 2、GetChild 使用提供的索引，通过检查可视化树获取所提供对象的特定子对象。

> 3、GetChildrenCount 返回在可视化树中在某一对象的子集合中存在的子级的数目。

> 4、GetParent 返回可视化树中某一对象的父对象。

##### LogicalTreeHelper 

> 借助逻辑树，内容模型可以方便地循环访问其可能的子对象，

> 从而实现扩展。 此外，逻辑树还为某些通知提供框架，

> 例如在加载逻辑树中的所有对象时。

> 基本上，逻辑树是框架级别的近似运行时对象图（排除了视觉对象），

> 但其足以用于对你自己的运行时应用程序组合执行多种查询操作。

###### BringIntoView(DependencyObject)	

####### 尝试使所请求的 UI 元素可见，并在目标上引发 RequestBringIntoView 事件以报告结果。

###### FindLogicalNode(DependencyObject, String)	

####### 尝试查找并返回具有指定名称的对象。 搜索从指定对象开始，并持续到逻辑树的子节点中。

###### GetChildren(DependencyObject)	

####### 通过处理逻辑树返回指定的对象的即时子对象集合。

###### GetChildren(FrameworkContentElement)	

####### 通过处理逻辑树，返回指定 FrameworkContentElement 的直接子对象的集合。

###### GetChildren(FrameworkElement)	

####### 通过处理逻辑树，返回指定 FrameworkElement 的直接子对象的集合。

###### GetParent(DependencyObject)	

####### 通过处理逻辑树，返回指定对象的父对象。

#### 合并XAMLS命名空间

##### 注意看程序集的信息，里面有一堆这样的代码：

```

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Controls")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Documents")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Shapes")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Shell")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Navigation")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Data")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Controls.Primitives")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Media.Animation")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Input")]

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation", "System.Windows.Media")]

```

> 这些代码的作用就是把那些命名空间合并到一个统一的命名空间里，方便调用。我们在自己的程序集里也可以这样用，只要修改AssemblyInfo.cs就可以了。然后我们在XAML里添加命名空间，就会看到自己定义的命名空间了。

### 资源

#### 样式

#### 模板

### 布局

> StackPanel 在纵向上或横向上排列元素，注意默认会自动充满横向空间和纵向空间，不会自动换行，通过Orientation控制排列方向。

> WrapPanel 采用流式布局，通过Orientation控制流的方向，当到达行尾或列尾时可以实现自动换行。

> DockPanel 可以设置内部元素的停靠方向，通过设置DockPanel.Dock设置子控件的停靠方向。

> Canvas 可以进行绝对定位布局，通过设置Canvas.Left和Canvas.Top等定位元素，除非确定布局不会改变，否则尽量少使用Canvas布局。

> Grid 以网格的形式对元素进行布局

> 通用设置

> > 控制尺寸

> > 1. 高度和宽度

> > FrameworkElement元素会根据内容大小调整尺寸（这里有一个例外，如果Window不设置SizeToContent的话，会根据屏幕分辨率设置自己的大小），它同时有Width（默认值Double.NaN，XAML里可以指定为Auto，意思就是和内容一样大）、Height（默认值同Width）、MinWidth（默认值0）、MinHeight（默认值0）、MaxWidth（默认值Double.PositiveInfinity，XAML里面可以写Infinity）、MaxHeight（默认值同MaxWidth）控制宽高，显然如果Width和Height在Min*和Max*范围内的时候，它们的优先级要比Min*以及Max*高

> > FrameworkElement还有一些与尺寸有关的只读属性：DesiredSize、ActualWidth和ActualHeight、RenderSize；DesiredSize是基于以上属性计算出来的，由父元素（Panel）在布局过程中使用的；RenderSize则是布局结束后元素的尺寸，ActualWidth和ActualHeight与之相同。由于布局操作是异步的，RenderSize的值会晚于Height、Width等基本属性的值，所以依赖RenderSize是不可靠的；UIElement中有一个强制完成布局的方法UpdateLayout()，但由于它会影响性能，而且不能保证正在使用的元素会被正常渲染，所以一般不用

> > 2. Margin和Padding

> > FrameworkElement.Margin：控制元素边界外的空间

> > Control.Padding：控制元素边界内的空间

> > 3. Visibility

> > Collapsed：元素不可见并且不参与布局

> > Visible：元素可见，并参与布局

> > Hidden：元素不可见但是参与布局

##### 控制位置

> 不同父元素（Panel）有不同的方法确定子元素的位置，但是有一些方法是子元素共有的

###### 1. Alignment

####### 比如Canvas就没有给它的子元素分配多余的空间，所以设置HorizontalAlignment和VerticalAlignment不起作用

####### 子元素（FrameworkElement）可以通过设置Alignment（默认值Stretch）控制怎样使用父元素分配给它的多余的空间；“多余的空间”很重要，因为如果父元素按照子元素的大小给它分配空间的话，这两个属性就不起作用了

####### 再比如StackPanel（Orientation属性值这里默认是Vertical，表示子元素垂直排列）只为子元素在水平方向上分配了多余空间，垂直方向上根据尺寸分配，所以设置HorizontalAlignment可以起作用，而设置VerticalAlignment不起作用

###### 2. Content Alignment

####### Control元素还可以通过设置HorizontalContentAlignment和VerticalContentAlignment控制自己的内容元素怎样对齐

###### 3. FlowDirection

####### FrameworkElement可以通过设置此属性改变此元素的内容流动的方向（LeftToRight和RightToLeft），可以作用在面板（Panel）或者拥有子元素的控件上

##### Panel（面板）

> Panel有一个ZIndex附加属性，ZIndex值大的元素会呈现在ZIndex值小的元素上方

> WPF内置的常用面板有：Canvas、StackPanel、WrapPanel、DockPanel、Grid，还有一些大多数时候在控件内部使用的轻量级面板

###### 1. 常用面板

> 常用面板里只记录一下GridSplitter（实际不是Panel类），Grid中可以通过GridSplitter交互改变行列尺寸，哪个单元格尺寸会被影响取决于GridSplitter的对齐值HorizontalAlignment（默认是Right）和VerticalAlignment（默认是Stretch），《WPF揭秘》里有张图，贴在这里，另外ResizeDirection和ResizeBehavior属性也会影响GridSplitter改变单元格尺寸的行为

###### 2. TabPanel

> TabControl的默认样式用它来处理TabItem的布局；TabPanel仅支持从左往右的排列，从上往下的换行，当换行发生时它会平均拉伸元素，使所有的行占据面板的全部宽度

###### 3. ToolBarOverflowPanel

> 仅支持从左往右的排列、从上往下的换行，默认样式的ToolBar就是用它来显示无法在主区域显示的元素，有一个WrapWidth属性

###### 4. ToolBarTray

> 仅支持ToolBar子元素，它会以水平的方式排列ToolBar，并且可以拖动ToolBar生成其他行，或者压缩或扩展相邻的ToolBar

###### 5. UniformGrid

> 子元素按先行后列的顺序添加，并且行列的大小都是*（平均大小）

###### 6. VirtualizingStackPanel

> > 不同于以上的轻量级面板，当绑定大量数据的时候，VirtualizingStackPanel是首选，因为它会临时抛弃显示范围之外的元素以提高性能，ListBox的默认样式使用的就是这个面板

> > 处理内容溢出

> > 当父元素不能满足子元素尺寸需求的时候，子元素可能会拒绝在过小的空间呈现，这种情况下就会发生内容溢出

> > 父元素（Panel）在处理内容溢出的时候，有以下几种策略：

> 1. Clipping（剪辑）

> > UIElement用ClipToBounds属性控制自己是否剪辑超出边界的内容，但是WPF内置面板中只有Canvas支持这个属性，其他诸如Grid等面板设置这个属性也没有用

> > 另外Grid等面板中的子元素通过变换（Transform）超出边界的部分也会被剪辑

> 2. Scrolling（滚屏）

> > 把需要滚屏的元素作为ScrollViewer的子元素即可实现滚屏，但是不要为该元素设置宽度或高度，因为ScollViewer需要根据子元素的内容大小设置合适的水平和垂直滚动范围

> 3. Scaling（缩放）

> > 为了在给定空间中缩放任意元素（ScaleTransform搞不定），可以使用Viewbox，有两个重要属性：Stretch（控制子元素怎样在Viewbox的边界内缩放）、StretchDirection（控制是需要缩小还是放大子元素）。需要注意的是，Viewbox的缩放是在布局之后发生的

> 4. 其他

> > 还有两种策略是换行（Wrapping）和截断（Trimming），换行是WrapPanel用的策略，截断则是TextBlock和AccessText中内联文本使用的策略

### 元素绑定

> 数据绑定是种关系，告诉WPF从源对象提取信息设置目标对象的属性

> 源对象是WPF元素并且源属性是依赖项属性的数据绑定，这是最简单的数据绑定。 

#### 绑定表达式 

> 数据绑定表达式使用XAML扩展标记，以Binding开头，实际上是创建了System.Windows.Data.Binding类实例，且设置两个属性：ElementName属性（源元素）和Path属性（源元素中的属性）。  

#### 绑定错误

> WPF不会引发异常带来通知与数据绑定相关的问题。指定的元素或属性不存在，只是在目标属性中不能显示数据。WPF输出了绑定失败细节的跟踪信息。当调试应用程序时，该信息显示在Visual Studio的输出窗口中。

#### 绑定模式

> 数据绑定的特性是目标会被自动更新，而不管源是被如何修改的。Binding.Mode的所有枚举值：

> OneWay：当源属性变化时更新目标属性

> TwoWay：当源属性变化时更新目标属性，并且当目标属性变化时更新源属性

> OneTime：最初根据源属性设置目标属性。然而，在此之后的所有改变都会被忽略

> OneWayToSource：当目标属性变化时更新源属性

> Default：此类绑定依赖于目标属性，他既可以是双向的，也可以是单向的。

#### 代码创建绑定

> 实例化Binding对象，指定Source，Path，Mode

> 移除：BindingOperation类的ClearBinding()，ClearAllBindings(),都使用DependencyObject的ClearValue()

> 创建动态绑定——根据其他运行时信息修改绑定，或者根据环境创建不同的绑定

> 删除绑定——借助ClearBinding()或ClearAllBindings()方法。

> 创建自定义控件——更容易的修改控件的外观，将特定的细节从标记移到代码中。

> 检索绑定：1 BindingOperations.GetBinding() 2 BindingOperations.GetBingingExpression()

> 多绑定:Mode允许改变绑定方向，（双向绑定），创建多个设置同一属性的绑定表达式。例如TextBox.Text属性创建表达式以链接到TextBlock.FontSize属性，而TextBlock.FontSize又链接到Slider.Value属性的绑定表达式。

> 绑定更新:源的变化会立即影响目标，然而反向的传递从目标到源未必会立即发生。他们的行为由Binding.UpdateSourceTrigger属性控制。

> PropertyChanged:当目标属性变化时立即更新源。

> LostFocus:当目标属性变化并且目标属性失去焦点时跟新源。

> Explicit:除非调用BindingExpression.UpdateSource()方法，否则无法更新源。

> Default:根据目标属性的元素确定更新行为。大多数属性的默认行为是PropertyChanged,但TextBox.Text属性的默认行为是LostFocus

> 绑定延迟: Binding的Delay,毫秒

> 绑定到非元素对象：

> Source:指向源对象的引用，提供数据的对象。

> RelativeSource：这是引用，使用RelativeSource对象指向源对象。有了这个附加层，在在当前元素的基础上构建引用。这似乎增加了复杂程度，当编写控件模板以及数据模板时很方便。

> DataContext：如果没有使用Source或RelativeSource属性指定源，WPF就从当前元素开始在元素树中向上查找。检查每个属性的DataContext属性，并使用第一个非空的DataContext属性。

> Source：静态资源x:Static

> RelativeSource：还要创建嵌套的RelativeSource对象，更常用是使用Binding和RelativeSource标记扩展，将其合并到一个字符串中。{RelativeSource FindAncestor, AncestorType ={x:Type Window}}

> Self：表达式绑定到同一元素的另一个属性上

> FindAncestor：表达式绑定到父元素

> PreviousData：表达式绑定到数据绑定列表中的前一个数据项。在

> TemplateParent：表达式绑定到应用模板的元素

> DataContext属性：将大量元素绑定到同一对象。设置Binding.Source属性相同的方法设置元素的DataContext属性。

> 省略源信息时，为null，继续向上在元素树中查找第一个不为null的数据。Binding Path=Source

### 第三方控件库

> Telerik RadControrls WPF

> DEVExpress

> GrapCity ComponentOne

#### 工具

> Visual Studio 

> Blend

> ILSpy

> Snoop#

> > Snoop是一个开源的WPF UI探索工具，它可以浏览正在运行的WPF程序的可视树、改变它的属性、查看Triggers、设置断点等。虽然现在Visual Studio也可以做到差不多的功能，但Snoop依然是我最喜欢使用的WPF工具之一。

> DebugView

> > DebugView是一个很古老但依然实用的工具，它可以查看应用程序或驱动程序输出的调试信息，而且不仅能查看本地机器，还可以查看远程机器的调试信息。总而言之有了它可以方便查看程序的调试信息，对调试应用很有帮助。

> ReSharper

> > XAML的错误提示

> > 增强的XAML智能感知

> > 导航和查找XAML元素

> > XAML代码重构

> Visual UI Automation Verify

###### 自动化测试的协助工具

> 1、ResXManager

> > ResXManager是用于管理resx资源文件的Visual Studio扩展，它提供了在Visual Studio中统一管理所有资源文件的用户界面。小规模的程序用不上，但一旦资源和资源文件达到一定数量管理这些资源将十分痛苦，这时候ResXManager就必不可少。

> 2、dnSpy

> > dnSpy 是用于 .NET 调试的最有用的工具之一。它是一个很好的反编译器。但是它的主要用途是作为调试器。dnSpy允许你调试任何 .NET程序你，而无需考虑符号或者源代码。

> > 该工具的外观和感觉类似于Visual Studio。当你开始调试没有符号或者源代码的.NET进程时，dnSpy将向你显示反编译的代码。现在，这里有个魔术：你可以在反编译的代码本上中放置断点。遇到这些断点时，你将看到局部变量，线程，调用堆栈，并具有完整的调试经验。这使dnSpy成为调试第三方代码和调试生产环境的首选工具。

> > 它轻巧，无需安装。只需将文件夹复制到任何生产机器上，然后开始调试。

> > 这个工具有个小窍门。如果你使用dnSpy启动进程，那么一切将正常运行。但是，如果你附加到正在运行的进程时，则已加载的模块将保持优化状态。也就是说它们是在Release模式下构建的。优化代码后，将不会遇到某些断点，也不会显示某些局部变量。这几乎破坏了调试体验。解决方案是使用dsSpy启动进程，而不是附加到进程中。

> 3、dotPeek

> > dotPeek是JetBrains的免费.NET反编译器。它们的许多工具实际上进入了该列表。与两个反编译器（如ILSpy或JustDecompile）相比，我更喜欢dotPeek，这有两个原因：

> > dotPeek提供了更好的用户体验。或至少我感到自在。它看起来和感觉都像Resharper。所以这可能是原因。

> > dotPeek可以从任何程序集中创建符号服务区，即使没有符号或源代码也是如此。它像dnSpy一样，它或反编译代码并从中创建符号。借助dotPeek，Visual Studio就像dnSpy一样调试任何第三方代码。要查看准确程度，请参阅我的文章：在Visual Studio中调试没有符号的第三方.NET代码，后续会进行翻译。

> 4、dotTrace

> > dotTrace是JetBrains的另一个出色工具。这是我最喜欢的性能分析工具。dotTrance允许你“记录”应用程序的运行，然后分析记录的性能。你将能够看到每种调用方法花费了多长时间，数据库条用，HTTP请求以及垃圾回收期间花费的时间等等。

> > 上图显示了对Visual Studio的简短记录分析。你可以看到ShowWindow花费了155毫秒，其中包括HwndSourceHook（42ms），Convert（16ms）等方法用时。此方法的执行包括42%的WPF调用，20%的用户代码，12%的GC等待，10%的Collections代码，10%的反射和5%的系统代码。太好了吧？

> > 首先，这是一个学习曲线，但是一旦习惯了，它会变得非常直观。

> 5、SciTech's .NET Memory Profiler

> > 内存分析器是解决内存问题必不可少的另一类工具。这些可能是由于GC（GC压力）引起的内存泄露或性能影响。如果你有足够大的应用程序，那么迟早会遇到内存问题。我希望为你以后着想，因为这些类型的问题可能是毁灭性的。

> > 内存探查器可以拍摄“内存快照”，并让你对器进行调查。你将看到哪些对象占用最多的内存，谁引用了它们，以及为什么未进行垃圾回收。通过比较两个快照，可以发现内存泄露。

> > 有几种可用的内存分析器，但是SciTech's .NET Memory Profiler是我的最爱。我发现它是功能最强大的产品，问题最少。

> 6、OzCode

> > OzCode是独特的Visual Studio扩展。其唯一目的是帮助你在Visual Studio中进行交互式调试。OzCode具有很多功能，可以分为4部分：

> > 1.上方显示 - OzCode在调试期间添加了一些有用的可视化功能。这包括红色/绿色突出显示并显示对象的选定属性：

> > 还有其他内容，例如将表达式分解成各个部分:

> > 2.LINQ调试 - LINQ在编写代码时很棒，但是很难调试。OzCode允许在调试过程中以几乎完美的方式研究LINQ表达式。

> > 要了解有关使用或不使用OzCode调试LINQ的更多信息，请查看我的文章：如何在C#中调试LINQ查询。

> > 3.数据提示 - 数据提示是将鼠标悬停在Visual Studio中的变量上时看到的弹出窗口。OzCode用自己的更好的数据提示替换了该窗口。它允许“收藏夹”属性，搜索，导出为JSON和其他功能。

> > 4.时间穿梭 - OzCode 4 添加了新的革命性调试功能。它可以预测未来而无需移动断点。也就是说，你将能够看到当前调试位置之后发生的代码行中发生的情况。不过，此功能并非在所有情况下都有效。例如，OzCode无法预测HTTP请求结果或SQL请求之类的事情，因为它必须为此执行它们。

> 7、SysInternals Suite

> > SysInternals是一套用于对Windows软件进行故障排除和监视的实用程序。它包括一些我们调试所需的最重要的工具。我建议下载整个套件并将其保存在易于命令行键入的位置，例如：C:\Sysinternals。有很多工具，其中一些比其他工具更有用。让我们列出一些.NET最重要的。

> > Process Explorer

> > Process Explorer就像类固醇上的Windows Task Manager。它具有许多对调试有用的功能，这里是其中的一些：

> > 查看加载的模块

> > 查看句柄

> > 创建Dump

> > 查看进程树

> > 查看性能计数器

> > Process Monitor

> > Process Monitor 也称为ProcMon，允许你监视流程活动事件。具体的说，你可以弹道注册表事件，文件事件，网络事件，线程活动和性能分析事件。如果你想找出你的过程涉及哪些文件或注册表，那么ProcMon可以为你提供帮助。

> > ProcDump

> > ProcDump是用于保存转储文件的命令行工具。它可以立即或在触发器上生成转储。例如，在崩溃或挂起时创建转储。这是我推荐的用于捕获转储的工具。以下是它的一些功能：

> > 立即创建转储

> > 创建具有特定间隔的多个转储（例如3个转储，相隔5秒）

> > 一旦超过CPU阈值，就创建转储

> > 如果进程挂起，则创建转储

> > 崩溃时创建转储

> > 若要查找有关ProcDump和Dump的更多信息，请参阅我的文章：2019年如果创建、使用和调试.NET 应用程序崩溃转储。

> 8、Performance Monitor (PerfMon)

> > Windows中有一种称为“性能计数器”的内置机制。这些计数器可让你根据计算机上发生的事情跟踪大量有用的指标。这些可能是系统范围内的指标，也可能是针对特定过程的指标。以下是一些可以使用性能计数器衡量的事情的示例：

> > CPU使用率

> > 内存使用率

> > 进程中引发的异常数

> > I/O字节的读写

> > 对你的asp.net应用程序的请求数

> > 在asp.net应用程序中请求响应时间

> > 你可能会监视成千上万种不同的计数器，它们会尽可能的具体。例如，如果你想了解进程的内存使用情况，则有以下计数器：私有字节，虚拟字节，工作集，私有工作集，Gen X 集合，GC时间百分比，大对象堆大小 等等。

> > 性能监视器是使你可以直观地看到这些计数器的工具（尽管也有其他工具）。它以在Windows设备预安装上了。要运行它，只需要在开始菜单中键入“Performance Monitor”，或在命令提示符下键入perfmon。

> 9、PerfView

> > PerfView是一个开源通用分析工具。它可以做很多事情，以下是其中一些：

> > 性能分析

> > 内存分析

> > 分析ETW事件

> > 从Linux导入性能快照

> > 有关应用程序行为的各种报告，包括JIT编译时间，垃圾回收时间等

> > 它的分析是基于Windows事件跟踪（ETW）事件。这是一个内置的日志记录系统，运行速度非常快，Windows的每个部分都可以使用它。一切都将事件记录到ETW，包括内核，Windows操作系统，CLR运行时，IIS，ASP.NEt框架，WPF等。

> > PerfView很容易成为此列表中最复杂的工具。但是它也非常强大。要开始使用PerfView，我建议在第九频道观看Vance Morrison的视频课程系统。

> 10、Fiddler

> > Fiddler是Progress Telerik的免费工具。这是我最喜欢的网络请求调试工具之一。它被称为HTTP代理服务器，仅此而已。它捕获所有HTTP请求，记录数据，并按其方式发送请求。

> > 对于每一个请求，你都可以查看流程，Headers，payload，response，status等所有的内容。

> > 对于调试，Fiddler具有两个有用功能：

> > 重新请求 - 你可以右键单击任何请求，然后单击“Replay”，这将再次发送完全相同的请求。在调试服务器端问题时非常有用。如果你要重现有问题的请求，Fiddler可以避免在客户端上重新运行方案以再次发送相同请求的麻烦。它还有助于处理难以重现的请求。

> > 编辑并重新请求 - 除了重新请求外，Fiddler允许我们修改请求。你可以更改标题，正文，甚至URL本身。你可以使用它来查看服务器端如何处理极端情况。或重现特定请求上发生的问题。

### VisualStateManager

> 要使用 VisualStateManager，需要定义 VisualState；在 VisualState 中定义控件的不同的状态以及每种状态下的样式，然后，在代码中合适的地方，我们可以使用 VisusalStateManager 类的 GoToState 来切换到对应的状态，从而实现样式的切换。

> 所以，总括地说，这里涉及了以下四个方面：

#### VisualState

> > 视图状态(Visual States)表示控件在一个特殊的逻辑状态下的样式、外观；

#### VisualStateGroup

> > 状态组由相互排斥的状态组成，状态组与状态组并不互斥；

#### VisualTransition

> > 视图转变 (Visual Transitions) 代表控件从一个视图状态向另一个状态转换时的过渡；

#### VisualStateManager

> > 由它负责在代码中来切换到不同的状态；

> 每个 VisualState 都属于一个状态组 (VisualStateGroup)，也即一个 VisualStateGroup 中可以定义多个 VisualState；并且，我们也可以定义多个 VisualStateGroup；需要再次强调的是：同一个 VisualStateGroup 中 VisualState 是互斥的，而不同的 VisualStateGroup 中的 VisualState 是在同一时刻是可以共存的。以 Button 为例：

> 我们看到，在它里面，定义了三个 VisualStateGroup，分别是 CommonStates（正常状态）、FocusStates（焦点状态）、ValidationStates（验证状态），而每个 VisualStateGroup 下又有若干个 VisualState。在 CommonStates 中，按钮可以是 Normal 、MouseOver 或 Pressed（只能是三者之一），但它却可以结合其它 VisualStateGroup 中的 VisualState 来显示，如按钮具有焦点时且鼠标移动到其上，这就结合了 MouseOver 与 Focused 两种状态。以下它的部分代码：

### 图形

#### 基本图形

> Line 直线段

> Rectangle 矩形

> Ellipse 椭圆

> Polygon 多边形

> Polyline 折线，不闭合

> Path 路径

#### 笔刷 Brush

> · SolidColorBrush：使用纯 Color 绘制区域。 

> · LinearGradientBrush：使用线性渐变绘制区域。 其中有个GradientStop属性，径向渐变也有可以查看msdn，我觉得上面说的还是比较清楚的。

> · RadialGradientBrush：使用径向渐变绘制区域。 

> · ImageBrush：使用图像（由 ImageSource 对象表示）绘制区域。

> · DrawingBrush：使用 Drawing 绘制区域。 绘图可能包含向量和位图对象。

> · VisualBrush：使用 Visual 对象绘制区域。 使用 VisualBrush 可以将内容从应用程序的一个部分复制到另一个区域，这在创建反射效果和放大局部屏幕时会非常有用。

#### 图形的效果与滤镜

> BevelBitmapEffect：斜角效果。

> BitmapEffectGroup：符合效果。

> BlurBitmapEffect:模糊效果。

> DropShadowBitmapEffect：投影效果。

> EmbossBitmapEffect：浮雕效果。

> OuterGlowBitmapEffect: 外发光效果。

### 变换

#### 图形的变形

> RenderTransform：呈现变形，定义在UIElement类中。

> LayoutTransform：布局变形，定义在FrameworkElement类中。

#### Transform 抽象类

> MatrixTransform：矩阵变形

> RotateTransform：旋转变形

> ScaleTransform：坐标变形

> SkewTransform：拉伸变形

> TranslateTransform：偏移变形

> TransformGroup：变形组

```

 <TextBlock.RenderTransform> 

    <RotateTransform Angle="0" x:Name="rt1"></RotateTransform> 

</TextBlock.RenderTransform> 

```

#### 变换（Transform）

> WPF元素还可以通过变换来改变尺寸和位置，有两种变换，RenderTransform和LayoutTransform

> RenderTransform（继承自UIElement）：在布局结束之后应用

> LayoutTransform：在布局前应用

> UIElement还有一个属性RenderTransformOrigin表示变换的原点，使用相对定位，（0,0）表示左上角，（1,1）表示右下角，显然RenderTransformOrigin只用于RenderTransform；LayoutTransform没有原点的概念是因为它要参与布局，被变换元素的位置由父元素的布局规则控制

> 1. RotateTransform

> > 控制变换的属性：Angle（旋转角度）、CenterX和CenterY（旋转中心点）；CenterX和CenterY使用的是绝对定位（像素无关单位），可以与RenderTransformOrigin组合起来使用，在缩放变换（ScaleTransform）和倾斜变换（SkewTransform）中都是这样

> 2. ScaleTransform

> > 控制变换的属性：ScaleX（水平方向的缩放因子）、ScaleY（垂直方向的缩放因子）、CenterX和CenterY（缩放的中心点）

> 3. SkewTransform

> > 控制变换的属性：AngleX（水平倾斜的角度）、AngleY（垂直倾斜的角度）、CenterX和CenterY（倾斜的中心点）

> 4. TranslateTransform

> > 控制变换的属性：X（水平偏移量）、Y（垂直偏移量）；与上面三种变换不同的是，TranslateTransform作为LayoutTransform应用时不起作用

> 5. MatrixTransform

> > 控制变换的属性：Matrix（3×3仿射变换矩阵），上面的4种变换都可以通过定义Matrix实现，并且可以直接在XAML里用一个字符串设置，比如下图的变换实现的是水平和垂直方向上放大两倍的效果

> 6. TransformGroup

> > 可以组合多个变换

### 动画

#### 动画基类

```

System.Windows.Media.Animation.BooleanAnimationBase

System.Windows.Media.Animation.ByteAnimationBase

System.Windows.Media.Animation.CharAnimationBase

System.Windows.Media.Animation.ColorAnimationBase

System.Windows.Media.Animation.DecimalAnimationBase

System.Windows.Media.Animation.DoubleAnimationBase

System.Windows.Media.Animation.Int16AnimationBase

System.Windows.Media.Animation.Int32AnimationBase

System.Windows.Media.Animation.Int64AnimationBase

System.Windows.Media.Animation.MatrixAnimationBase

System.Windows.Media.Animation.ObjectAnimationBase

System.Windows.Media.Animation.Point3DAnimationBase

System.Windows.Media.Animation.PointAnimationBase

System.Windows.Media.Animation.QuaternionAnimationBase

System.Windows.Media.Animation.RectAnimationBase

System.Windows.Media.Animation.Rotation3DAnimationBase

System.Windows.Media.Animation.SingleAnimationBase

System.Windows.Media.Animation.SizeAnimationBase

System.Windows.Media.Animation.StringAnimationBase

System.Windows.Media.Animation.ThicknessAnimationBase

System.Windows.Media.Animation.Vector3DAnimationBase

System.Windows.Media.Animation.VectorAnimationBase

```

> 以DoubleAnimationBase为基类展开，其他的再慢慢去了解和摸索。

> > 一种就是点到点的的动画DoubleAnimation，一种是可以分为帧的动画DoubleAnimationUsingKeyFrames，还有一种是按照路径来执行的DoubleAnimationUsingPath的动画。

简单动作由以下几个部分构成：变化起点（From属性），变化终点（To属性），变化幅度（By属性），变化时间（Duration属性）。

如果指定的有终点那么幅度就被忽略了，如果没有起点，就以当前元素所在位置为起点。

还是看个例子来的更易理解。下面演示一个按钮如果被点击了，在0.3s里，按钮朝着x，y轴上300个单位随机移动。下面给出代码

```

System.Windows.Media.Animation.BooleanAnimationBase

System.Windows.Media.Animation.ByteAnimationBase

System.Windows.Media.Animation.CharAnimationBase

System.Windows.Media.Animation.ColorAnimationBase

System.Windows.Media.Animation.DecimalAnimationBase

System.Windows.Media.Animation.DoubleAnimationBase

System.Windows.Media.Animation.Int16AnimationBase

System.Windows.Media.Animation.Int32AnimationBase

System.Windows.Media.Animation.Int64AnimationBase

System.Windows.Media.Animation.MatrixAnimationBase

System.Windows.Media.Animation.ObjectAnimationBase

System.Windows.Media.Animation.Point3DAnimationBase

System.Windows.Media.Animation.PointAnimationBase

System.Windows.Media.Animation.QuaternionAnimationBase

System.Windows.Media.Animation.RectAnimationBase

System.Windows.Media.Animation.Rotation3DAnimationBase

System.Windows.Media.Animation.SingleAnimationBase

System.Windows.Media.Animation.SizeAnimationBase

System.Windows.Media.Animation.StringAnimationBase

System.Windows.Media.Animation.ThicknessAnimationBase

System.Windows.Media.Animation.Vector3DAnimationBase

System.Windows.Media.Animation.VectorAnimationBase

```

```

<Grid>

<Button x:Name="btn" Content="Move!" HorizontalAlignment="Left" VerticalAlignment="top" Width="60" Height="60" Click="Button_Click">

        <Button.RenderTransform>

            <TranslateTransform x:Name="tt" X="0" Y="0"/>

        </Button.RenderTransform>

    </Button>

</Grid>

```

```

        private void Button_Click(object sender, RoutedEventArgs e)

        {

            //定义简单动画的实例

              DoubleAnimation daX = new DoubleAnimation();

            DoubleAnimation daY = new DoubleAnimation();

            //指定起点

             daX.From = 0D;

            daY.From = 0D;

            //指定终点

            Random r = new Random();

            daX.To = r.NextDouble() * 300;

            daY.To = r.NextDouble() * 300;

            //daX.By = 100D;

            //daY.By = 100D;

            //指定时长300ms

            Duration duration=new Duration(TimeSpan.FromMilliseconds(300));

            daY.Duration = duration;

            daX.Duration = duration;

            //将动画添加到偏移变形的实例上面 和Binding的格式有点像

            //this.textBox.SetBinding（TextBox.TextProperty,binding）

            

            //让按钮发生改变作为动画

            //btn.BeginAnimation(Button.WidthProperty, daX);

            //btn.BeginAnimation(Button.HeightProperty, daY);

            

            //让 位置发生改变作为动画

            this.tt.BeginAnimation(TranslateTransform.XProperty, daX);

            this.tt.BeginAnimation(TranslateTransform.YProperty, daY);

        }

```

#### 关键帧动画 ：

> 先理解一下帧的概念，帧也就每次属性改变都会产生一个新画面，新画面就是一个帧。帧的连续播放产生了动画。

> DoubleAnimationUsingKeyFrames的实例中通常是含有多个DoubleKeyFrame类的帧，具体的有下面四种：　

##### LinearDoubleKeyFrame

> 线性帧，目标属性值的变化是直线型的，匀速的。

##### DiscreteDoubleKeyFrame

> 不连续变化的帧，目标属性值是跳跃的。

##### SplineDoubleKeyFrame

> 样条函数变化帧，目标属性值的速率是一条贝赛尔曲线。

##### EasingDoubleKeyFrame

> 缓冲式帧，目标属性值以某种缓冲形式变化。

```

//定义两个DoubleAnimationUsingKeyFrames类型的实例，来控制呈现变形的横纵坐标

DoubleAnimationUsingKeyFrames dakX = new DoubleAnimationUsingKeyFrames();

DoubleAnimationUsingKeyFrames dakY = new DoubleAnimationUsingKeyFrames();

//指定时长

dakX.Duration = new Duration(TimeSpan.FromMilliseconds(900));

dakY.Duration = new Duration(TimeSpan.FromMilliseconds(900));

//纵坐标====================================================

//动画分成三段，所以有三个线性关键帧

LinearDoubleKeyFrame x_kf_1 = new LinearDoubleKeyFrame();

LinearDoubleKeyFrame x_kf_2 = new LinearDoubleKeyFrame();

LinearDoubleKeyFrame x_kf_3 = new LinearDoubleKeyFrame();

//为三段关键帧赋值（时间和属性的值），并添加到动画中

x_kf_1.KeyTime = KeyTime.FromTimeSpan(TimeSpan.FromMilliseconds(300));

x_kf_1.Value = 200;

x_kf_2.KeyTime = KeyTime.FromTimeSpan(TimeSpan.FromMilliseconds(600));

x_kf_2.Value = 0;

x_kf_3.KeyTime = KeyTime.FromTimeSpan(TimeSpan.FromMilliseconds(900));

x_kf_3.Value = 200;

dakX.KeyFrames.Add(x_kf_1);

dakX.KeyFrames.Add(x_kf_2);

dakX.KeyFrames.Add(x_kf_3);

//纵坐标====================================================

LinearDoubleKeyFrame y_kf_1 = new LinearDoubleKeyFrame();

LinearDoubleKeyFrame y_kf_2 = new LinearDoubleKeyFrame();

LinearDoubleKeyFrame y_kf_3 = new LinearDoubleKeyFrame();

y_kf_1.KeyTime = KeyTime.FromTimeSpan(TimeSpan.FromMilliseconds(300));

y_kf_1.Value = 0;

y_kf_2.KeyTime = KeyTime.FromTimeSpan(TimeSpan.FromMilliseconds(600));

y_kf_2.Value = 180;

y_kf_3.KeyTime = KeyTime.FromTimeSpan(TimeSpan.FromMilliseconds(900));

y_kf_3.Value = 180;

dakY.KeyFrames.Add(y_kf_1);

dakY.KeyFrames.Add(y_kf_2);

dakY.KeyFrames.Add(y_kf_3);

//把动画寄托在呈现变形中

this.tt.BeginAnimation(TranslateTransform.XProperty, dakX);

this.tt.BeginAnimation(TranslateTransform.YProperty, dakY);

```

> 前面已经介绍了路径绘图时的强大，那么我们能不能让我的动画按照我们制定的路径去表演呢，答案是可以的。

> 这就是我们要记录的DoubleAnimationUsingPath类。

> 注意它有三个属性很关键，其中Duration是每个动画必须有的，另外两个是Source属性和PathGeometry分别用来指定向那个方向移动和路径。

> 下面给出一个按钮沿路径移动的动画，构思如下：

```

<Window.Resources>

<PathGeometry x:Key="movingPath" Figures="M 40,110 A 50,50 0 1 1 100,60 A110,95 0 0 1 200,60 A 50,50 0 1 1 250 100 A 110,95 0 1 1 55,100 Z"/>

</Window.Resources>

<Grid x:Name="grid" HorizontalAlignment="Left" VerticalAlignment="Top">

<Path x:Name="movingPath" Data="M 40,110 A 50,50 0 1 1 100,60 A110,95 0 0 1 200,60 A 50,50 0 1 1 250 100 A 110,95 0 1 1 55,100 Z" Stroke="Red"

　　　　　　　　　　 StrokeThickness="2" Visibility="Visible"/>

<Button x:Name="btn" Height="30" Width="80" Content="路径动画" Click="btn_Click" Margin="0,0,219,210">

<Button.RenderTransform>

<TranslateTransform x:Name="tt" X="0" Y="0"/>

</Button.RenderTransform>

<Button.Effect>

<DropShadowEffect BlurRadius="45" Color="Red" />

</Button.Effect>

</Button>

</Grid>

```

```

PathGeometry pg =this.FindResource("movingPath") as PathGeometry;

Duration duration = new Duration(TimeSpan.FromMilliseconds(600));

DoubleAnimationUsingPath dakX = new DoubleAnimationUsingPath();

dakX.PathGeometry = pg;

dakX.Source = PathAnimationSource.X;

dakX.Duration = duration;

DoubleAnimationUsingPath dakY = new DoubleAnimationUsingPath();

dakY.PathGeometry = pg;

dakY.Source = PathAnimationSource.Y;

dakY.Duration = duration;

this.tt.BeginAnimation(TranslateTransform.XProperty, dakX);

this.tt.BeginAnimation(TranslateTransform.YProperty, dakY);

```

#### 场景（Storyborad）

```

#####   <Border BorderBrush="Gray" BorderThickness="1" Grid.Row="1">

<Ellipse x:Name="ballG" Height="80" Width="80" Fill="Green" HorizontalAlignment="Left">

    <Ellipse.RenderTransform>

        <TranslateTransform x:Name="ttG"/>

    </Ellipse.RenderTransform>

</Ellipse>

        </Border>

```

对应的cs代码，注释已经给出：

```

//定义动画要执行的时长

Duration duation = new Duration(TimeSpan.FromMilliseconds(600));

//定义一个简单的移动——匀速直线运动

DoubleAnimation daRx = new DoubleAnimation();

daRx.Duration = duation;

daRx.To = 400;

//定义一个关键帧的移动，目标属性值的速率是一条贝赛尔曲线函数

DoubleAnimationUsingKeyFrames dakGx = new DoubleAnimationUsingKeyFrames();

dakGx.Duration = duation;

SplineDoubleKeyFrame kfG = new SplineDoubleKeyFrame(400, KeyTime.FromPercent(1));

kfG.KeySpline = new KeySpline(1, 0, 0, 1);

dakGx.KeyFrames.Add(kfG);

//定义一个关键帧的移动，目标属性值的速率是一条贝赛尔曲线函数

DoubleAnimationUsingKeyFrames dakBx = new DoubleAnimationUsingKeyFrames();

dakBx.Duration = duation;

SplineDoubleKeyFrame kfB = new SplineDoubleKeyFrame(400, KeyTime.FromPercent(1));

kfB.KeySpline = new KeySpline(0, 1, 1, 0);

dakBx.KeyFrames.Add(kfB);

Storyboard storyboard = new Storyboard();

//使指定的动画的UI载体

Storyboard.SetTargetName(daRx, "ttR");

Storyboard.SetTargetName(dakGx, "ttG");

Storyboard.SetTargetName(dakBx, "ttB");

//使动画与UI载体的属性相关联

Storyboard.SetTargetProperty(daRx,new PropertyPath(TranslateTransform.XProperty));

Storyboard.SetTargetProperty(dakGx, new PropertyPath(TranslateTransform.XProperty));

Storyboard.SetTargetProperty(dakBx, new PropertyPath(TranslateTransform.XProperty));

//指定场景的时间,并把各个对像的动画添加到场景里面

storyboard.Duration = duation;

storyboard.Children.Add(daRx);

storyboard.Children.Add(dakGx);

storyboard.Children.Add(dakBx);

storyboard.Begin(this);

```

第Ⅰ部分 基础知识

第1章 WPF概述 3

1.1 Windows图形演化 3

1.1.1 DirectX：新的图形引擎 4

1.1.2 硬件加速与WPF 4

1.2 WPF：高级API 4

1.3 分辨率无关性 5

1.3.1 WPF单位 6

1.3.2 系统DPI 7

1.3.3 位图和矢量图形 9

1.4 WPF体系结构 10

1.5 WPF 4.5 13

1.5.1 WPF工具包 14

1.5.2 Visual Studio 2012 14

1.6 小结 16

第2章 XAML 17

2.1 理解XAML 17

2.1.1 WPF之前的图形用户界面 17

2.1.2 XAML变体 19

2.1.3 XAML编译 19

2.2 XAML基础 20

2.2.1 XAML名称空间 21

2.2.2 代码隐藏类 22

2.3 XAML中的属性和事件 24

2.3.1 简单属性与类型转换器 25

2.3.2 复杂属性 26

2.3.3 标记扩展 28

2.3.4 附加属性 29

2.3.5 嵌套元素 30

2.3.6 特殊字符与空白 32

2.3.7 事件 34

2.3.8 完整的Eight Ball Answer示例 35

2.4 使用其他名称空间中的类型 36

2.5 加载和编译XAML 38

2.5.1 只使用代码 38

2.5.2 使用代码和未经编译的XAML 40

2.5.3 使用代码和编译过的XAML 42

2.5.4 只使用XAML 44

2.6 小结 45

第3章 布局 47

3.1 理解WPF中的布局 47

3.1.1 WPF布局原则 47

3.1.2 布局过程 48

3.1.3 布局容器 48

3.2 使用StackPanel面板进行简单

布局 50

3.2.1 布局属性 52

3.2.2 对齐方式 52

3.2.3 边距 53

3.2.4 小尺寸、尺寸以及显式地

设置尺寸 54

3.2.5 Border控件 56

3.3 WrapPanel和DockPanel面板 57

3.3.1 WrapPanel面板 57

3.3.2 DockPanel面板 58

3.3.3 嵌套布局容器 59

3.4 Grid面板 60

3.4.1 调整行和列 63

3.4.2 布局舍入 64

3.4.3 跨越行和列 65

3.4.4 分割窗口 66

3.4.5 共享尺寸组 69

3.4.6 UniformGrid面板 72

3.5 使用Canvas面板进行基于

坐标的布局 72

3.5.1 Z顺序 73

3.5.2 lnkCanvas元素 74

3.6 布局示例 76

3.6.1 列设置 76

3.6.2 动态内容 77

3.6.3 组合式用户界面 79

3.7 小结 80

第4章 依赖项属性 83

4.1 理解依赖项属性 83

4.1.1 定义依赖项属性 84

4.1.2 注册依赖项属性 84

4.1.3 添加属性包装器 86

4.1.4 WPF使用依赖项属性的方式 87

4.1.5 共享的依赖项属性 88

4.1.6 附加的依赖项属性 88

4.2 属性验证 90

4.2.1 验证回调 90

4.2.2 强制回调 91

4.3 小结 93

第5章 路由事件 95

5.1 理解路由事件 95

5.1.1 定义、注册和封装路由事件 95

5.1.2 共享路由事件 96

5.1.3 引发路由事件 96

5.1.4 处理路由事件 97

5.2 事件路由 99

5.2.1 RoutedEventArgs类 100

5.2.2 冒泡路由事件 100

5.2.3 处理挂起的事件 103

5.2.4 附加事件 103

5.2.5 隧道路由事件 105

5.3 WPF事件 106

5.3.1 生命周期事件 106

5.3.2 输入事件 108

5.4 键盘输入 108

5.4.1 处理按键事件 109

5.4.2 焦点 111

5.4.3 获取键盘状态 112

5.5 鼠标输入 113

5.5.1 鼠标单击 115

5.5.2 捕获鼠标 115

5.5.3 鼠标拖放 116

5.6 多点触控输入 118

5.6.1 多点触控的输入层次 119

5.6.2 原始触控 119

5.6.3 操作 122

5.6.4 惯性 124

5.7 小结 125

第Ⅱ部分 进一步研究WPF

第6章 控件 129

6.1 控件类 129

6.1.1 背景画刷和前景画刷 130

6.1.2 字体 132

6.1.3 鼠标光标 136

6.2 内容控件 137

6.2.1 Content属性 138

6.2.2 对齐内容 140

6.2.3 WPF内容原则 141

6.2.4 标签 142

6.2.5 按钮 142

6.2.6 工具提示 145

6.3 特殊容器 151

6.3.1 ScrollViewer 152

6.3.2 GroupBox 154

6.3.3 TabItem 154

6.3.4 Expander 155

6.4 文本控件 158

6.4.1 多行文本 158

6.4.2 选择文本 159

6.4.3 拼写检查 160

6.4.4 PasswordBox 162

6.5 列表控件 162

6.5.1 ListBox 163

6.5.2 ComboBox 166

6.6 基于范围的控件 166

6.6.1 Slider 167

6.6.2 ProgressBar 168

6.7 日期控件 169

6.8 小结 171

第7章 Application类 173

7.1 应用程序的生命周期 173

7.1.1 创建Application对象 173

7.1.2 派生自定义的Application类 174

7.1.3 应用程序的关闭方式 176

7.1.4 应用程序事件 177

7.2 Application类的任务 179

7.2.1 显示初始界面 179

7.2.2 处理命令行参数 180

7.2.3 访问当前Application对象 181

7.2.4 在窗口之间进行交互 182

7.2.5 单实例应用程序 184

7.3 程序集资源 189

7.3.1 添加资源 189

7.3.2 检索资源 190

7.3.3 pack URI 192

7.3.4 内容文件 193

7.4 本地化 193

7.4.1 构建能够本地化的用户界面 194

7.4.2 使应用程序为本地化做好准备 194

7.4.3 管理翻译过程 195

7.5 小结 200

第8章 元素绑定 201

8.1 将元素绑定到一起 201

8.1.1 绑定表达式 202

8.1.2 绑定错误 203

8.1.3 绑定模式 203

8.1.4 使用代码创建绑定 205

8.1.5 使用代码检索绑定 206

8.1.6 多绑定 207

8.1.7 绑定更新 210

8.1.8 绑定延迟 211

8.2 绑定到非元素对象 211

8.2.1 Source属性 212

8.2.2 RelativeSource属性 212

8.2.3 DataContext属性 213

8.3 小结 214

第9章 命令 215

9.1 理解命令 215

9.2 WPF命令模型 216

9.2.1 ICommand接口 217

9.2.2 RoutedCommand类 217

9.2.3 RoutedUICommand类 218

9.2.4 命令库 219

9.3 执行命令 220

9.3.1 命令源 220

9.3.2 命令绑定 221

9.3.3 使用多命令源 223

9.3.4 微调命令文本 224

9.3.5 直接调用命令 224

9.3.6 禁用命令 225

9.3.7 具有内置命令的控件 227

9.4 高级命令 229

9.4.1 自定义命令 229

9.4.2 在不同位置使用相同的命令 230

9.4.3 使用命令参数 232

9.4.4 跟踪和翻转命令 233

9.5 小结 237

第10章 资源 239

10.1 资源基础 239

10.1.1 资源集合 239

10.1.2 资源的层次 241

10.1.3 静态资源和动态资源 242

10.1.4 非共享资源 243

10.1.5 通过代码访问资源 244

10.1.6 应用程序资源 244

10.1.7 系统资源 245

10.2 资源字典 246

10.2.1 创建资源字典 246

10.2.2 使用资源字典 247

10.2.3 在程序集之间共享资源 248

10.3 小结 251

第11章 样式和行为 253

11.1 样式基础 253

11.1.1 创建样式对象 256

11.1.2 设置属性 257

11.1.3 关联事件处理程序 258

11.1.4 多层样式 259

11.1.5 通过类型自动应用样式 261

11.2 触发器 262

11.2.1 简单触发器 262

11.2.2 事件触发器 264

11.3 行为 266

11.3.1 获取行为支持 266

11.3.2 理解行为模型 267

11.3.3 创建行为 268

11.3.4 使用行为 270

11.3.5 Blend中的设计时行为支持 271

11.4 小结 271

第Ⅲ部分 图画和动画

第12章 形状、画刷和变换 275

12.1 理解形状 275

12.1.1 Shape类 276

12.1.2 矩形和椭圆 277

12.1.3 改变形状的尺寸和放置形状 278

12.1.4 使用Viewbox控件缩放形状 280

12.1.5 直线 282

12.1.6 折线 283

12.1.7 多边形 284

12.1.8 直线线帽和直线交点 286

12.1.9 点划线 287

12.1.10 像素对齐 288

12.2 画刷 289

12.2.1 SolidColorBrush画刷 290

12.2.2 LinearGradientBrush画刷 290

12.2.3 RadialGradientBrush画刷 292

12.2.4 ImageBrush画刷 294

12.2.5 平铺的ImageBrush画刷 295

12.2.6 VisualBrush画刷 297

12.2.7 BitmapCacheBrush画刷 298

12.3 变换 299

12.3.1 变换形状 300

12.3.2 变换元素 302

12.4 透明 303

12.4.1 使元素半透明 303

12.4.2 透明掩码 304

12.5 小结 306

第13章 几何图形和图画 307

13.1 路径和几何图形 307

13.1.1 直线、矩形和椭圆图形 308

13.1.2 使用GeometryGroup

组合形状 309

13.1.3 使用CombinedGeometry融合

几何图形 311

13.1.4 使用PathGeometry绘制曲线和

直线 313

13.1.5 微语言几何图形 318

13.1.6 使用几何图形进行剪裁 319

13.2 图画 320

13.2.1 显示图画 322

13.2.2 导出插图 324

13.3 小结 326

第14章 效果和可视化对象 327

14.1 可视化对象 327

14.1.1 绘制可视化对象 328

14.1.2 在元素中封装可视化对象 329

14.1.3 命中测试 332

14.1.4 复杂的命中测试 334

14.2 效果 338

14.2.1 BlurEffect类 338

14.2.2 DropShadowEffect类 339

14.2.3 ShaderEffect类 340

14.3 WriteableBitmap类 342

14.3.1 生成位图 342

14.3.2 写入WriteableBitmap对象 343

14.3.3 更高效的像素写入 345

14.4 小结 347

第15章 动画基础 349

15.1 理解WPF动画 349

15.1.1 基于时间的动画 349

15.1.2 基于属性的动画 350

15.2 基本动画 351

15.2.1 Animation类 351

15.2.2 使用代码创建动画 353

15.2.3 同时发生的动画 358

15.2.4 动画的生命周期 358

15.2.5 Timeline类 359

15.3 故事板 362

15.3.1 故事板 363

15.3.2 事件触发器 363

15.3.3 重叠动画 366

15.3.4 同步的动画 367

15.3.5 控制播放 367

15.3.6 监视动画进度 371

15.4 动画缓动 373

15.4.1 使用缓动函数 373

15.4.2 在动画开始时应用缓动与在动画

结束时应用缓动 374

15.4.3 缓动函数类 375

15.4.4 创建自定义缓动函数 377

15.5 动画性能 379

15.5.1 期望的帧率 380

15.5.2 位图缓存 382

15.6 小结 384

第16章 高级动画 385

16.1 动画类型回顾 385

16.1.1 动态变换 386

16.1.2 动态改变画刷 390

16.1.3 动态改变像素着色器 392

16.2 关键帧动画 393

16.2.1 离散的关键帧动画 395

16.2.2 缓动关键帧 395

16.2.3 样条关键帧动画 396

16.3 基于路径的动画 397

16.4 基于帧的动画 399

16.5 使用代码创建故事板 402

16.5.1 创建主窗口 403

16.5.2 创建Bomb用户控件 405

16.5.3 投弹 406

16.5.4 拦截炸弹 409

16.5.5 统计炸弹和清理工作 410

16.6 小结 412

第Ⅳ部分 模板和自定义元素

第17章 控件模板 417

17.1 理解逻辑树和可视化树 417

17.2 理解模板 422

17.2.1 修饰类 424

17.2.2 剖析控件 426

17.3 创建控件模板 428

17.3.1 简单按钮 429

17.3.2 模板绑定 430

17.3.3 改变属性的触发器 431

17.3.4 使用动画的触发器 434

17.4 组织模板资源 435

17.4.1 分解按钮控件模板 436

17.4.2 通过样式应用模板 438

17.4.3 自动应用模板 439

17.4.4 由用户选择的皮肤 440

17.5 构建更复杂的模板 442

17.5.1 嵌套的模板 443

17.5.2 修改滚动条 445

17.5.3 控件模板示例 450

17.6 可视化状态 451

17.7 小结 452

第18章 自定义元素 453

18.1 理解WPF中的自定义元素 454

18.2 构建基本的用户控件 456

18.2.1 定义依赖项属性 456

18.2.2 定义路由事件 459

18.2.3 添加标记 460

18.2.4 使用控件 462

18.2.5 命令支持 462

18.2.6 深入分析用户控件 465

18.3 创建无外观控件 466

18.3.1 修改颜色拾取器的代码 466

18.3.2 修改颜色拾取器的标记 467

18.3.3 精简控件模板 469

18.4 支持可视化状态 472

18.4.1 开始编写FlipPanel类 473

18.4.2 选择部件和状态 475

18.4.3 默认控件模板 476

18.4.4 使用FlipPanel控件 482

18.4.5 使用不同的控件模板 483

18.5 创建自定义面板 485

18.5.1 两步布局过程 485

18.5.2 Canvas面板的副本 488

18.5.3 更好的WrapPanel面板 489

18.6 自定义绘图元素 492

18.6.1 OnRender( )方法 493

18.6.2 评估自定义绘图 494

18.6.3 自定义绘图元素 495

18.6.4 创建自定义装饰元素 497

18.7 小结 498

第Ⅴ部分 数据

第19章 数据绑定 501

19.1 使用自定义对象绑定到

数据库 501

19.1.1 构建数据访问组件 502

19.1.2 构建数据对象 504

19.1.3 显示绑定对象 505

19.1.4 更新数据库 508

19.1.5 更改通知 508

19.2 绑定到对象集合 510

19.2.1 显示和编辑集合项 510

19.2.2 插入和移除集合项 513

19.2.3 绑定到ADO.NET对象 514

19.2.4 绑定到LINQ表达式 515

19.3 提高大列表的性能 518

19.3.1 虚拟化 518

19.3.2 项容器再循环 519

19.3.3 缓存长度 519

19.3.4 延迟滚动 520

19.4 验证 521

19.4.1 在数据对象中进行验证 521

19.4.2 自定义验证规则 526

19.4.3 响应验证错误 528

19.4.4 获取错误列表 529

19.4.5 显示不同的错误指示符号 530

19.4.6 验证多个值 533

19.5 数据提供者 535

19.5.1 ObjectDataProvider 536

19.5.2 XmlDataProvider 539

19.6 小结 541

第20章 格式化绑定的数据 543

20.1 数据绑定回顾 543

20.2 数据转换 544

20.2.1 使用StringFormat属性 545

20.2.2 值转换器简介 546

20.2.3 使用值转换器设置字符串

的格式 547

20.2.4 使用值转换器创建对象 549

20.2.5 应用条件格式化 551

20.2.6 评估多个属性 552

20.3 列表控件 554

20.4 列表样式 555

20.4.1 ItemContainerStyle 556

20.4.2 包含复选框或单选按钮的ListBox

控件 557

20.4.3 交替条目样式 559

20.4.4 样式选择器 561

20.5 数据模板 564

20.5.1 分离和重用模板 566

20.5.2 使用更高级的模板 567

20.5.3 改变模板 569

20.5.4 模板选择器 570

20.5.5 模板与选择 573

20.5.6 改变项的布局 577

20.6 ComboBox控件 578

20.7 小结 581

第21章 数据视图 583

21.1 View对象 583

21.1.1 检索视图对象 584

21.1.2 视图导航 584

21.1.3 以声明方式创建视图 587

21.2 过滤、排序与分组 588

21.2.1 过滤集合 588

21.2.2 过滤DataTable对象 591

21.2.3 排序 592

21.2.4 分组 593

21.2.5 实时成型 598

21.3 小结 599

第22章 列表、树和网格 601

22.1 ListView控件 601

22.1.1 使用GirdView创建列 602

22.1.2 创建自定义视图 606

22.2 TreeView控件 613

22.2.1 创建数据绑定的TreeView

控件 614

22.2.2 将DataSet对象绑定到TreeView

控件 617

22.2.3 即时创建节点 618

22.3 DataGrid控件 621

22.3.1 改变列的尺寸与重新安排列 622

22.3.2 定义列 623

22.3.3 设置列的格式和样式 628

22.3.4 设置行的格式 629

22.3.5 显示行细节 630

22.3.6 冻结列 631

22.3.7 选择 632

22.3.8 排序 632

22.3.9 编辑 633

22.4 小结 635

第Ⅵ 窗口、页面和富控件

第23章 窗口 639

23.1 Window类 639

23.1.1 显示窗口 641

23.1.2 定位窗口 642

23.1.3 保存和还原窗口位置 642

23.2 窗口交互 644

23.2.1 窗口所有权 646

23.2.2 对话框模型 647

23.2.3 通用对话框 648

23.3 非矩形窗口 649

23.3.1 简单形状窗口 649

23.3.2 具有形状内容的透明窗口 651

23.3.3 移动形状窗口 653

23.3.4 改变形状窗口的尺寸 653

23.3.5 组合到一起：窗口的自定义控件

模板 655

23.4 Windows 7任务栏编程 658

23.4.1 使用跳转列表 659

23.4.2 改变任务栏图标和预览 663

23.5 小结 667

第24章 页面和导航 669

24.1 基于页面的导航 669

24.2 基于页面的界面 670

24.2.1 创建一个具有导航窗口的基于

页面的简单应用程序 670

24.2.2 Page类 672

24.2.3 超链接 673

24.2.4 在框架中驻留页面 675

24.2.5 在另一个页面中驻留页面 677

24.2.6 在Web浏览器中驻留页面 678

24.3 页面历史 678

24.3.1 深入分析WPF中的URI 678

24.3.2 导航历史 679

24.3.3 维护自定义的属性 681

24.4 导航服务 682

24.4.1 通过编程进行导航 682

24.4.2 导航事件 683

24.4.3 管理日志 684

24.4.4 向日志添加自定义项 685

24.4.5 使用页函数 689

24.5 XAML浏览器应用程序 692

24.5.1 创建XBAP应用程序 692

24.5.2 部署XBAP应用程序 693

24.5.3 更新XBAP应用程序 695

24.5.4 XBAP应用程序的安全性 695

24.5.5 完全信任的XBAP应用程序 696

24.5.6 组合XBAP/独立应用程序 697

24.5.7 为不同的安全级别编写代码 697

24.5.8 在网页中嵌入XBAP

应用程序 702

24.6 WebBrowser控件 702

24.6.1 导航到页面 703

24.6.2 构建DOM树 704

24.6.3 使用.NET代码为网页添加

脚本 706

24.7 小结 708

第25章 菜单、工具栏和功能区 709

25.1 菜单 709

25.1.1 Menu类 710

25.1.2 菜单项 710

25.1.3 ContextMenu类 712

25.1.4 菜单分隔条 713

25.2 工具栏和状态栏 714

25.2.1 ToolBar控件 714

25.2.2 StatusBar控件 717

25.3 功能区 718

25.3.1 添加功能区 719

25.3.2 应用程序菜单 720

25.3.3 选项卡、组与按钮 722

25.3.4 富工具提示 724

25.3.5 带有快捷键提示的键盘访问 725

25.3.6 改变功能区的大小 726

25.3.7 快速访问工具栏 729

25.4 小结 730

第26章 声音和视频 731

26.1 播放WAV音频 731

26.1.1 SoundPlayer类 731

26.1.2 SoundPlayerAction类 733

26.1.3 系统声音 733

26.2 MediaPlayer类 734

26.3 MediaElement类 735

26.3.1 使用代码播放音频 736

26.3.2 处理错误 737

26.3.3 使用触发器播放音频 737

26.3.4 播放多个声音 739

26.3.5 改变音量、平衡、速度以及

位置 740

26.3.6 将动画同步到音频 742

26.3.7 播放视频 744

26.3.8 视频效果 744

26.4 语音 747

26.4.1 语音合成 747

26.4.2 语音识别 749

26.5 小结 751

第27章 3D绘图 753

27.1 3D绘图基础 753

27.1.1 视口 754

27.1.2 3D对象 754

27.1.3 摄像机 761

27.2 深入研究3D绘图 765

27.2.1 着色和法线 766

27.2.2 更复杂的形状 769

27.2.3 Model3DGroup集合 769

27.2.4 使用材质 771

27.2.5 纹理映射 773

27.3 交互和动画 777

27.3.1 变换 777

27.3.2 旋转 778

27.3.3 飞过 779

27.3.4 跟踪球 781

27.3.5 命中测试 782

27.3.6 3D表面上的2D元素 786

27.4 小结 789

第Ⅶ部分 文档和打印

第28章 文档 793

28.1 理解文档 793

28.2 流文档 794

28.2.1 流内容元素 795

28.2.2 设置内容元素的格式 796

28.2.3 创建简单的流文档 797

28.2.4 块元素 799

28.2.5 内联元素 804

28.2.6 通过代码与元素进行交互 809

28.2.7 文本对齐 812

28.3 只读流文档容器 813

28.3.1 缩放 814

28.3.2 创建页面和列 815

28.3.3 从文件加载文档 817

28.3.4 打印 818

28.4 编辑流文档 818

28.4.1 加载文件 819

28.4.2 保存文件 821

28.4.3 设置所选文本的格式 822

28.4.4 获取单个单词 824

28.5 固定文档 825

28.6 批注 826

28.6.1 批注类 827

28.6.2 启用批注服务 828

28.6.3 创建批注 829

28.6.4 检查批注 832

28.6.5 响应批注更改 835

28.6.6 在固定文档中保存批注 835

28.6.7 自定义便签的外观 836

28.7 小结 837

第29章 打印 839

29.1 基本打印 839

29.1.1 打印元素 840

29.1.2 变换打印输出 842

29.1.3 打印不显示的元素 844

29.1.4 打印文档 845

29.1.5 在文档打印输出中控制页面 848

29.2 自定义打印 851

29.2.1 使用可视化层中的类

进行打印 851

29.2.2 自定义多页打印 854

29.3 打印设置和管理 859

29.3.1 保存打印设置 859

29.3.2 打印页面范围 859

29.3.3 管理打印队列 860

29.4 通过XPS进行打印 863

29.4.1 为打印预览创建XPS文档 863

29.4.2 写入内存的XPS文档 864

29.4.3 通过XPS直接打印到

打印机 865

29.4.4 异步打印 866

29.5 小结 866

第Ⅷ部分 其他主题

第30章 与Windows窗体进行交互 869

30.1 访问互操作性 869

30.2 混合窗口和窗体 870

30.2.1 为WPF应用程序添加窗体 870

30.2.2 为Windows窗体应用程序

添加WPF窗口 870

30.2.3 显示模态窗口和窗体 871

30.2.4 显示非模态窗口和窗体 871

30.2.5 启用Windows窗体控件的

可视化风格 872

30.3 创建具有混合内容的窗口 872

30.3.1 WPF和Windows窗体

“空域” 873

30.3.2 在WPF中驻留Windows

窗体控件 874

30.3.3 使用WPF和Windows窗体

用户控件 876

30.3.4 在Windows窗体中驻留WPF

控件 877

30.3.5 访问键、助记码和焦点 879

30.3.6 属性映射 880

30.4 小结 882

第31章 多线程 883

31.1 了解多线程模型 883

31.1.1 Dispatcher类 884

31.1.2 DispatcherObject类 884

31.2 BackgroundWorker类 887

31.2.1 简单的异步操作 887

31.2.2 创建BackgroundWorker

对象 888

31.2.3 运行BackgroundWorker

对象 889

31.2.4 跟踪进度 891

31.2.5 支持取消 893

31.3 小结 894

第32章 插件模型 895

32.1 在MAF和MEF两者间

进行选择 895

32.2 了解插件管道 896

32.2.1 管道的工作原理 897

32.2.2 插件文件夹结构 898

32.2.3 为使用插件模型准备

解决方案 899

32.3 创建使用插件模型的

应用程序 900

32.3.1 协定 901

32.3.2 插件视图 901

32.3.3 插件 902

32.3.4 插件适配器 902

32.3.5 宿主视图 903

32.3.6 宿主适配器 904

32.3.7 宿主 904

32.3.8 更多插件 907

32.4 与宿主进行交互 908

32.5 可视化插件 912

32.6 小结 915

第33章 ClickOnce部署 917

33.1 理解应用程序部署 917

33.1.1 ClickOnce安装模型 918

33.1.2 ClickOnce部署的局限性 919

33.2 简单的ClickOnce发布 920

33.2.1 设置发布者和产品 920

33.2.2 启动发布向导 922

33.2.3 理解部署文件的结构 926

33.2.4 安装ClickOnce应用程序 926

33.2.5 更新ClickOnce应用程序 928

33.3 ClickOnce附加选项 928

33.3.1 发布版本 928

33.3.2 更新 929

33.3.3 文件关联 930

33.3.4 发布选项 931

33.4 小结 932

## HTML 5

## JQuery

## Angular

## React

## Vue.js

## Bootstrap学习总结

### Bootstrap 基础

#### 媒体查询（css3特性）

> @media not|only 媒体类型 and (媒体特性) {css 代码样式}

> css3中的媒体类型和媒体特性与bootsrap不太一样。

> 可以实现依据最小最大宽度（媒体类型）等设置不同css样式。

##### 媒体类型

> all	用于所有多媒体类型设备

> print	用于打印机

> screen	用于电脑屏幕，平板，智能手机等。

> speech	用于屏幕阅读器

##### 媒体特性

> aspect-ratio	定义输出设备中的页面可见区域宽度与高度的比率

> color	定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0

> color-index	定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0

> device-aspect-ratio	定义输出设备的屏幕可见宽度与高度的比率。

> device-height	定义输出设备的屏幕可见高度。

> device-width	定义输出设备的屏幕可见宽度。

> grid	用来查询输出设备是否使用栅格或点阵。

> height	定义输出设备中的页面可见区域高度。

> max-aspect-ratio	定义输出设备的屏幕可见宽度与高度的最大比率。

> max-color	定义输出设备每一组彩色原件的最大个数。

> max-color-index	定义在输出设备的彩色查询表中的最大条目数。

> max-device-aspect-ratio	定义输出设备的屏幕可见宽度与高度的最大比率。

> max-device-height	定义输出设备的屏幕可见的最大高度。

> max-device-width	定义输出设备的屏幕最大可见宽度。

> max-height	定义输出设备中的页面最大可见区域高度。

> max-monochrome	定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。

> max-resolution	定义设备的最大分辨率。

> max-width	定义输出设备中的页面最大可见区域宽度。

> min-aspect-ratio	定义输出设备中的页面可见区域宽度与高度的最小比率。

> min-color	定义输出设备每一组彩色原件的最小个数。

> min-color-index	定义在输出设备的彩色查询表中的最小条目数。

> min-device-aspect-ratio	定义输出设备的屏幕可见宽度与高度的最小比率。

> min-device-width	定义输出设备的屏幕最小可见宽度。

> min-device-height	定义输出设备的屏幕的最小可见高度。

> min-height	定义输出设备中的页面最小可见区域高度。

> min-monochrome	定义在一个单色框架缓冲区中每像素包含的最小单色原件个数

> min-resolution	定义设备的最小分辨率。

> min-width	定义输出设备中的页面最小可见区域宽度。

> monochrome	定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0

> orientation	定义输出设备中的页面可见区域高度是否大于或等于宽度。

> resolution	定义设备的分辨率。如：96dpi, 300dpi, 118dpcm

> scan	定义电视类设备的扫描工序。

> width	定义输出设备中的页面可见区域宽度。

### Bootstrap 布局

#### 包装容器

> .container .container -{breakpoint} .container-fluid

#### 响应断点

> 当你须要搞定响应式布局时，一堆堆的媒体查询、大量的属性、属性值往往能够把你搞颠，SASS（或者诸如此类的预处理器）被觉得是处理响应式断点的最佳利器。

> 1.使用变量(With variables)

Bootstrap和Foundation採用这样的方式，首先定义变量，然后在媒体查询中使用变量。换句话说，你能够在配置文件或者其它地方定义变量以备使用。我们来看看Bootstrap怎么干的。

// Defining values

$screen-sm-min: 768px;

$screen-xs-max: ($screen-sm-min - 1);

$screen-md-min: 992px;

$screen-sm-max: ($screen-md-min - 1);

$screen-lg-min: 1200px;

$screen-md-max: ($screen-lg-min - 1);

 

// Usage

@media (max-width: $screen-xs-max) { ... }

@media (min-width: $screen-sm-min) { ... }

@media (max-width: $screen-sm-max) { ... }

@media (min-width: $screen-md-min) { ... }

@media (max-width: $screen-md-max) { ... }

@media (min-width: $screen-lg-min) { ... }

Foudation更进一步，使用跨范围的媒体查询，避免使用过多的max-width和min-width。

// Defining values

$small-range:   (0em, 40em);       /* 0, 640px */

$medium-range:  (40.063em, 64em);  /* 641px, 1024px */

$large-range:   (64.063em, 90em);  /* 1025px, 1440px */

$xlarge-range:  (90.063em, 120em); /* 1441px, 1920px */

$xxlarge-range: (120.063em);       /* 1921px */

 

// Defining media queries

$screen:       "only screen" !default;

$landscape:    "#{$screen} and (orientation: landscape)" !default;

$portrait:     "#{$screen} and (orientation: portrait)" !default;

$small-up:     $screen !default;

$small-only:   "#{$screen} and (max-width: #{upper-bound($small-range)})" !default;

$medium-up:    "#{$screen} and (min-width:#{lower-bound($medium-range)})" !default;

$medium-only:  "#{$screen} and (min-width:#{lower-bound($medium-range)}) and (max-width:#{upper-bound($medium-range)})" !default;

$large-up:     "#{$screen} and (min-width:#{lower-bound($large-range)})" !default;

$large-only:   "#{$screen} and (min-width:#{lower-bound($large-range)}) and (max-width:#{upper-bound($large-range)})" !default;

$xlarge-up:    "#{$screen} and (min-width:#{lower-bound($xlarge-range)})" !default;

$xlarge-only:  "#{$screen} and (min-width:#{lower-bound($xlarge-range)}) and (max-width:#{upper-bound($xlarge-range)})" !default;

$xxlarge-up:   "#{$screen} and (min-width:#{lower-bound($xxlarge-range)})" !default;

$xxlarge-only: "#{$screen} and (min-width:#{lower-bound($xxlarge-range)}) and (max-width:#{upper-bound($xxlarge-range)})" !default;

 

// Usage

@media #{$small-up}     { ... }

@media #{$small-only}   { ... }

@media #{$medium-up}    { ... }

@media #{$medium-only}  { ... }

@media #{$large-up}     { ... }

@media #{$large-only}   { ... }

@media #{$xlarge-up}    { ... }

@media #{$xlarge-only}  { ... }

@media #{$xxlarge-up}   { ... }

@media #{$xxlarge-only} { ... }

两种方法各有一个不爽的地方，在Bootstrap里每次都要使用max-width，在Foundation里我们须要使用插值变量这样的又丑又烦的方式。显示我们须要想办法解决这些问题。

> 2.使用独立Mixin(With a standalone mixin)《media queries in Sass 3.2》是CSS-Tricks里最火的文章之中的一个，在这篇文章里Chris Coyier在借鉴a former idea by Mason Wendell和a former idea by Jeff Croft两文的基础上，怎样使用sass实现响应式布局的断点管理。

命名断点是非常重要的，由于能够为抽象的数字赋予意义（你知道767px是什么意思吗，我不知道，直到我去使用小屏幕的时候才知道）。为什么Bootstrap和Foundation要使用变量呢，不也是为了给抽象的数字起个名字吗？

所以我们定义个mixin，接收断点名作唯一的參数，返回媒体查询的内容。准备好了吗？走起。

@mixin respond-to($breakpoint) {

  @if $breakpoint == "small" {

    @media (min-width: 767px) {

      @content;

    }

  }

 

  @else if $breakpoint == "medium" {

    @media (min-width: 992px) {

      @content;

    }

  }

 

  @else if $breakpoint == "large" {

    @media (min-width: 1200px) {

      @content;

    }

  }

}

然后，我们这样使用mixin。

@include respond-to(small) { ... }

@include respond-to(medium) { ... }

@include respond-to(large) { ... }

这种方法是极好的（甄嬛体，老外也看？），原因有二：抽象数据有意义，大量断点集中管理。假设你想把“992px”改成“970px”，你不须要爬过每个css文件，而仅仅需更新mixin，然后所有更新。

可是也还有两个问题：

a.断点不easy从mixin里拿出来，放到配置文件中去。

b.冗余太多。

> 3. 可配置的mixin(With a configurable mixin  )

<为了解决上面的两个问题，我们须要从断点mixin中抽出一个列表，仅仅剩下mixin核心，然后这个列表就能够随便移动，或者扔到配置文件中。

然后，使用sass 3.3+中的maps，我们能够方便的使用关联的属性和属性值。

$breakpoints: (

  'small'  : 767px,

  'medium' : 992px,

  'large'  : 1200px

);

然后原来的mixin进行相应的改动

@mixin respond-to($breakpoint) {

  // Retrieves the value from the key

  $value: map-get($breakpoints, $breakpoint);

 

  // If the key exists in the map

  @if $value != null {

    // Prints a media query based on the value

    @media (min-width: $value) {

      @content;

    }

  }

 

  // If the key doesn't exist in the map

  @else {

    @warn "Unfortunately, no value could be retrieved from `#{$breakpoint}`. "

        + "Please make sure it is defined in `$breakpoints` map.";

  }

}

我们在改动mixin的同一时候也进行了一些提高，不要小看这些提高，我们加上了错误处理，假设在maps中没有找到断点值，将会弹出一个错误提示，这将便于我们开发过程中的调试。

我们让mixin变得更加精简，能非常好的处理错误，同一时候我们去掉了一个功能——推断属性是否是你想要的（min-width,max-width,min-height等），这在移动优先的网页中没问题，由于我们仅仅须要min-width。可是，假设须要查询其它属性，我们须要把这个功能加回来。为了达到这个目的，我想到了一个非常优雅的解决方式，同一时候并不添加复杂性。

$breakpoints: (

  'small'  : ( min-width:  767px ),

  'medium' : ( min-width:  992px ),

  'large'  : ( min-width: 1200px )

);

  

@mixin respond-to($name) {

  // If the key exists in the map

  @if map-has-key($breakpoints, $name) {

    // Prints a media query based on the value

    @media #{inspect(map-get($breakpoints, $name))} {

      @content;

    }

  }

 

  // If the key doesn't exist in the map

  @else {

    @warn "Unfortunately, no value could be retrieved from `#{$breakpoint}`. "

        + "Please make sure it is defined in `$breakpoints` map.";

  }

}

在这里，我们主要做了三个事情

a. 检查查询的断点在map中存在不存在

b.假设存在，打印相应的媒体查询。

c.假设不在，进行错误提示。

简单吧，假设我们回想前面的两个缺陷，已经不再有WET(Write Everything Twice))问题，也不再有不灵活的媒体查询。可是另一个问题，不支持复杂的媒体查询。复杂指的是涉及多个组件的查询（e.g. screen and (min-width: 767px)）。我们上面这些方案除了第一种变量之外都不能非常好的解决问题。

> 4. 使用外部工具(With an external tool)

```

最后一个相同重要的是，假设不想创建自己的mixin，你能够使用外部的工具处理响应式布局的断点，有非常多sass的扩展在这个方面做得非常好。

SassMQ by Kaelig

Breakpoint by Mason Wendell and Sam Richard

Breakup by Ben Scott

 	SassMQ	Breakpoint	Breakup

MQ type	*-width	any	any

No Query fallback	yep	yep	yep

API complexity	simple	very simple	medium

Code complexity	very simple	complexe	simple

Extra	Debug mode	Singularity.gs	—

基本上是这样，假设发现有没有涉及的，记得一定告诉我。

SassMQ

// Configuration

$mq-responsive: true;

$mq-static-breakpoint: desktop;

$mq-breakpoints: (

  mobile:  320px,

  tablet:  740px,

  desktop: 980px,

  wide:    1300px

);

 

// Example

selector {

  @include mq($from: mobile) {

    property: value;

  }

}

BreakPoints

$high-tide: 500px;

$ex-presidents: 600px 800px;

$surfboard-width: max-width 1000px;

$surfboard-height: (min-height 1000px) (orientation portrait);

 

selector {

  @include breakpoint($high-tide) {

    property: value;

  }

}

Breakup

$breakup-breakpoints: (

  'thin' '(max-width: 35.999em)',

  'wide' '(min-width: 36em)',

  'full' '(min-width: 61em)'

);

 

selector {

  @include breakup-block('thin') {

    property: value;

  }

}

```

#### 堆叠顺序 z-index

#### 网格系统

> 12列的网格 col-2 列占用2/12的宽度 

### Bootstrap 版式

#### 文档案

#### 图片

#### 表格

#### 代码

### Bootstrap 通用样式

#### 文本

#### 颜色

#### 边框

#### 定位浮动

#### 代码弹性盒子

#### 其它 对齐等

### Bootstrap 组件

#### 按钮

#### 按钮组

#### 下拉

#### 媒体对象

#### 表单

#### 进度条

#### 导航栏

#### 列表组

#### 面包屑 

> 显示导航层次位置 如 “首页-> 文学-> 中国文学”

#### 分页

#### 加载指示器（转圈圈）

#### 按钮卡片

###  Sass

#### 变量

#### 嵌套归斥责

#### 导入

#### SASS 混合器 混合器继承

> 混合器 Sass中的混合器类似于js的函数，将一段代码定义成混合器以实现代码的重用  编译后其实会转换成正常的css

> 声明混合器：@mixin mixName 

> 调用混合器  @include minName 如

@mixin border-round{

    -moz-border:1px solid red;

    -webkit-border:1px solid red;

    border:1px solid red

}

#top{

    @include border-round;

}

//编译后

#top {

  -moz-border: 1px solid red;

  -webkit-border: 1px solid red;

  border: 1px solid red; }

> 混合器css规则 混合器中也可以包含css规则

@mixin testmix{

    list-style:none;

    li{

        color:red;

        padding:30px;

    }

    >.top{

        background:red

    }

}

ul.parent{

    border:1px solid red;

    @include testmix;

}

//编译后

ul.parent {

  border: 1px solid red;

  list-style: none; 

}

  ul.parent li {

    color: red;

    padding: 30px; 

}

  ul.parent > .top {

    background: red;

 }

> 混合器传参 混合器可以像函数一样传递参数 混合器传参数

@mixin test($color,$size,$hoverColor){

    color:$color;

    border:$size solid red;

    &:hover{

        color:$hoverColor

    }

}

#top{

    @include test(red,1px,blue);

}

//编译后

#top {

  color: red;

  border: 1px solid red; 

}

  #top:hover {

    color: blue; 

}

/*# 

当然这里有个问题，混合器里面的参数不允许颠倒位置，如果你记不清他们什么位置可以使用键值的方式明确指定

@mixin test($color,$size,$hoverColor){

    color:$color;

    border:$size solid red;

    &:hover{

        color:$hoverColor

    }

}

#top{

    @include test($size:1px,$hoverColor:blue,$color:red);

}

//编译后

#top {

  color: red;

  border: 1px solid red;

  }

#top:hover {

    color: blue;

  }

> 参数默认值 混合器允许你定义参数默认值 如下

@mixin test($normal,$hover:red){

    color:$normal;

    background-color:$hover

}

#top{

    @include test(skyblue,orange);

}

//编译后

#top {

  color: skyblue;

  background-color: orange;

  }

  //不指定color

@mixin test($normal,$hover:red){

    color:$normal;

    background-color:$hover

}

#top{

    @include test(skyblue);

}

//编译后

  

#top {

  color: skyblue;

  background-color: red; }

> Sass继承 Sass中也可实现继承类似面向对象思想子类继承父类，sass可以继承多个父类 这个”父类“可以是类，id 标签 状态等。 继承语法 @extend name 如

.error{

    color:red;

    font-size:15px;

}

.danger-error{

    @extend .error;

    font-size:20px;

}

//编译后

.error, .danger-error {

  color: red;

  font-size: 15px;

}

.danger-error {

  font-size: 20px; 

}

当然父类也可包含css规则

.error{

    color:red;

    font-size:15px;

    >.te{

        padding:10px

    }

}

.danger-error{

    @extend .error;

    font-size:20px;

}

//编译后

.error, .danger-error {

  color: red;

  font-size: 15px; 

}

.error > .te, .danger-error > .te {

    padding: 10px;

  }

.danger-error {

  font-size: 20px; 

 }

> 组合继承

.error a{

    color:red;

    font-size:10px;

}

.danger{

    @extend .error;

    color:orange;

}

//编译后

.error a, .danger a {

  color: red;

  font-size: 10px; 

}

.danger {

  color: orange; 

}

> 继承多个

.one{

    color:red;

}

.two{

    border:1px solid red;

}

.three{

    @extend .one;

    @extend .two;

    //或者这样写@extend .one,.two

    //

    background:blue;

}

//编译后

.one, .three {

  color: red; 

}

.two, .three {

  border: 1px solid red;

}

.three {

  background: blue;

}

> 继承局限性 继承不支持组合 很多选择器不支持继承如包选择器 .one tow 相邻选择器 .one+.two

%继承 有些时候我们希望被用来继承的代码不要渲染到页面上只作为继承使用。 定义方法 父类名前+%

%test{

    border:1px solid red;

}

#main{

    @extend %test;

}

//编译后

#main {

  border: 1px solid red; 

}

#meng a%long{

    color:blue;

    border:1px solid red;

}

.notice{

    @extend %long;

}

//编译后

#meng a.notice {

  color: blue;

  border: 1px solid red; 

}

继承在指令的作用域如（@media） 在指令内部无法继承到指令外部的类，指令外部继承指令内部的类无法达到预期效果

.one{

    height:400px;

}

@media print{

    .two{

        @extend .one

    }

    width:300px;

}

> 编译时报错 继承注意事项

> 不能过量使用继承，因为所有类继承了父类，父类改变就会影响子类

 

继承只会在生成css时复制选择器，而不会复制大段的css属性  如果不小心会让生成css中包含大量的选择器复制  避免这种情况的最好办法：  不要在继承css规则中使用后代选择器如

 

 .dsf{}

 .foo .bar {

 @extend dsf //不推荐

 }

##  Font Awesome

## Asp.net core MVC 一些总结

### Router

#### property router

> [Route("app/[controller]/actions/[action]/{id:weekday?}")]

#### 设置路由中间件

```

app.UseMvc(routes =>

{

    routes.MapRoute(

        name: "default",

        template: "{controller=Home}/{action=Index}/{id?}");

});

```

> 常规路由：routes.MapRoute(name: "default",template: "{controller=Home}/{action=Index}/{id?}");  这是一个常规路由

#### 多路由 

```

app.UseMvc(routes =>

{

    routes.MapRoute("blog", "blog/{*article}",

        defaults: new { Controller = "Blog", Action = "Index" });

    routes.MapRoute(

        name: "default",

        template: "{controller=Home}/{action=Index}/{id?}");

});

```

#### 高级路由

```

app.UseMvc(routes => {

    routes.MapRoute(

        name: "areas",

        template: "{area:exists}/{controller=Home}/{action=Index}");

    routes.Routes.Add(new LegacyRoute(

        routes.DefaultHandler,

        "/articles/Windows_3.1_Overview.html",

        "/old/.NET_1.0_Class_Library"));

    routes.MapRoute(

        name: "default",

        template: "{controller=Home}/{action=Index}/{id?}");

    routes.MapRoute(

        name: "out",

        template: "outbound/{controller=Home}/{action=Index}");

});

```

### Session

```

using System;

using Microsoft.AspNetCore.Http;

using Microsoft.Extensions.DependencyInjection;

using Newtonsoft.Json;

using SportsStore.Infrastructure;

namespace SportsStore.Models

{

    public class SessionCart : Cart

    {

        public static Cart GetCart(IServiceProvider services)

        {

            ISession session = services.GetRequiredService<IHttpContextAccessor>()?

                .HttpContext.Session;

            SessionCart cart = session?.GetJson<SessionCart>("Cart")

                ?? new SessionCart();

            cart.Session = session;

            return cart;

        }

        [JsonIgnore]

        public ISession Session { get; set; }

        public override void AddItem(Product product, int quantity)

        {

            base.AddItem(product, quantity);

            Session.SetJson("Cart", this);

        }

        public override void RemoveLine(Product product)

        {

            base.RemoveLine(product);

            Session.SetJson("Cart", this);

        }

        public override void Clear()

        {

            base.Clear();

            Session.Remove("Cart");

        }

    }

}

```

### 授权认证管理

#### 认证

```

using System.Threading.Tasks;

using Microsoft.AspNetCore.Authorization;

using Microsoft.AspNetCore.Identity;

using Microsoft.AspNetCore.Mvc;

using SportsStore.Models.ViewModels;

using SportsStore.Models;

[Authorize]

public class AccountController : Controller {

    private UserManager<IdentityUser> userManager;

    private SignInManager<IdentityUser> signInManager;

    public AccountController(UserManager<IdentityUser> userMgr,

            SignInManager<IdentityUser> signInMgr) {

        userManager = userMgr;

        signInManager = signInMgr;

        IdentitySeedData.EnsurePopulated(userMgr).Wait();

    }

    [AllowAnonymous]

    public ViewResult Login(string returnUrl) {

        return View(new LoginModel {

            ReturnUrl = returnUrl

        });

    }

    [HttpPost]

    [AllowAnonymous]

    [ValidateAntiForgeryToken]

    public async Task<IActionResult> Login(LoginModel loginModel) {

        if (ModelState.IsValid) {

            IdentityUser user =

                await userManager.FindByNameAsync(loginModel.Name);

            if (user != null) {

                await signInManager.SignOutAsync();

                if ((await signInManager.PasswordSignInAsync(user,

                        loginModel.Password, false, false)).Succeeded) {

                    return Redirect(loginModel?.ReturnUrl ?? "/Admin/Index");

                }

            }

        }

        ModelState.AddModelError("", "Invalid name or password");

        return View(loginModel);

    }

    public async Task<RedirectResult> Logout(string returnUrl = "/") {

        await signInManager.SignOutAsync();

        return Redirect(returnUrl);

    }

}

```

> rezor

```

@model LoginModel

@{

    ViewBag.Title = "Log In";

    Layout = "_AdminLayout";

}

<div class="text-danger" asp-validation-summary="All"></div>

<form asp-action="Login" asp-controller="Account" method="post">

    <input type="hidden" asp-for="ReturnUrl" />

    <div class="form-group">

        <label asp-for="Name"></label>

        <div><span asp-validation-for="Name" class="text-danger"></span></div>

        <input asp-for="Name" class="form-control" />

    </div>

    <div class="form-group">

        <label asp-for="Password"></label>

        <div><span asp-validation-for="Password" class="text-danger"></span></div>

        <input asp-for="Password" class="form-control" />

    </div>

    <button class="btn btn-primary" type="submit">Log In</button>

</form>

```

### DI

> services.AddSingleton<IRepository, MemoryRepository>(); 单实例

> services.AddTransient<IModelStorage, DictionaryStorage>(); 每一次获取的对象都不是同一个

> services.AddScoped 请求开始-请求结束 在这次请求中获取的对象都是同一个；不用申明静态类；

### Filters

> > 子类Controller拦截器要先于父类Controller拦截器执行

> 最先执行的是全局声明的MyActionOneAttribute拦截器

> 然后执行的是声明在子Controller类HomeController上的MyActionThreeAttribute拦截器

> 接着执行的是声明在父Controller类BaseController上的MyActionTwoAttribute拦截器

> 最后执行的是声明在子Controller类HomeController的Index方法上的MyActionFourAttribute拦截器

```

public class MyFilterAttribute : ResultFilterAttribute {

    private string message;

    public MyFilterAttribute(string msg) {

        message = msg;

    }

    public override void OnResultExecuting(ResultExecutingContext context) {

        WriteMessage(context, $"<div>Before Result:{message}</div>");

    }

    public override void OnResultExecuted(ResultExecutedContext context) {

        WriteMessage(context, $"<div>After Result:{message}</div>");

    }

    private void WriteMessage(FilterContext context, string msg) {

        byte[] bytes = Encoding.ASCII

            .GetBytes($"<div>{msg}</div>");

        // Synchronous operations are disallowed. Call WriteAsync or set AllowSynchronousIO to true instead.

        context.HttpContext.Response

            .Body.WriteAsync(bytes, 0, bytes.Length);

    }

}

```

> Usage:

```

    [MyFilter("This is the Controller-Scoped Filter", Order = 10)]

    public class HomeController : Controller {

        [MyFilter("This is the First Action-Scoped Filter", Order = 1)]

        [MyFilter("This is the Second Action-Scoped Filter", Order = -1)]

        public ViewResult Index() => View("Message",

            "This is the Index action on the Home controller");

    }

```

#### 授权过滤器 AuthorizeAttribute

```

 public class HttpsOnlyAttribute : Attribute, IAuthorizationFilter {

        public void OnAuthorization(AuthorizationFilterContext context) {

            if (!context.HttpContext.Request.IsHttps) {

                context.Result =

                    new StatusCodeResult(StatusCodes.Status403Forbidden);

            }

        }

    }

```

#### 资源过滤器 IResourceFilter

```

public class CustomerResourceFilterAttribute : Attribute, IResourceFilter

    {

        private static Dictionary<string,object> cacheDic=new Dictionary<string, object>();

        public void OnResourceExecuting(ResourceExecutingContext context)

        {

            var path=context.HttpContext.Request.Path; 

            if (cacheDic.ContainsKey(path))

            {

                context.Result = (IActionResult)cacheDic[path];

            }

            Console.WriteLine("CustomerResourceFilterAttribute.OnResourceExecuting");

        }

        public void OnResourceExecuted(ResourceExecutedContext context)

        {

            var path = context.HttpContext.Request.Path;

            cacheDic[path] = context.Result;

            Console.WriteLine("CustomerResourceFilterAttribute.OnResourceExecuted");

        }

 

         

    }

```

#### 异常过滤器 IExceptionFilter

```

public class RangeExceptionAttribute : ExceptionFilterAttribute {

        public override void OnException(ExceptionContext context) {

            if (context.Exception is ArgumentOutOfRangeException) {

                context.Result = new ViewResult() {

                    ViewName = "Message",

                    ViewData = new ViewDataDictionary(

                        new EmptyModelMetadataProvider(),

                        new ModelStateDictionary()) {

                        Model = @"The data received by the

                                application cannot be processed"

                    }

                };

            }

        }

    }

```

#### 操作过滤器 ActionFilterAttribute

```

public class ProfileAttribute : ActionFilterAttribute {

        private Stopwatch timer;

        private double actionTime;

        public override async Task OnActionExecutionAsync(

                ActionExecutingContext context,

                ActionExecutionDelegate next) {

            timer = Stopwatch.StartNew();

            await next();

            actionTime = timer.Elapsed.TotalMilliseconds;

        }

        public override async Task OnResultExecutionAsync(

                ResultExecutingContext context,

                ResultExecutionDelegate next) {

            await next();

            timer.Stop();

            string result = "<div>Action time: "

                + $"{actionTime} ms</div><div>Total time: "

                + $"{timer.Elapsed.TotalMilliseconds} ms</div>";

            byte[] bytes = Encoding.ASCII.GetBytes(result);

            await context.HttpContext.Response.Body.WriteAsync(bytes,

                0, bytes.Length);

        }

    }

```

```

public class ViewResultDiagnostics : IActionFilter {

        private IFilterDiagnostics diagnostics;

        public ViewResultDiagnostics(IFilterDiagnostics diags) {

            diagnostics = diags;

        }

        public void OnActionExecuting(ActionExecutingContext context) {

            // do nothing - not used in this filter

        }

        public void OnActionExecuted(ActionExecutedContext context) {

            ViewResult vr;

            if ((vr = context.Result as ViewResult) != null) {

                diagnostics.AddMessage($"View name: {vr.ViewName}");

                diagnostics.AddMessage($@"Model type: 

                    {vr.ViewData.Model.GetType().Name}");

            }

        }

    }

```

#### 结果过滤器 ResultFilterAttribute

```

     public class MessageAttribute : ResultFilterAttribute {

        private string message;

        public MessageAttribute(string msg) {

            message = msg;

        }

        public override void OnResultExecuting(ResultExecutingContext context) {

            WriteMessage(context, $"<div>Before Result:{message}</div>");

        }

        public override void OnResultExecuted(ResultExecutedContext context) {

            WriteMessage(context, $"<div>After Result:{message}</div>");

        }

        private void WriteMessage(FilterContext context, string msg) {

            byte[] bytes = Encoding.ASCII

                .GetBytes($"<div>{msg}</div>");

            // Synchronous operations are disallowed. Call WriteAsync or set AllowSynchronousIO to true instead.

            context.HttpContext.Response

                .Body.WriteAsync(bytes, 0, bytes.Length);

        }

    }

```

```

 public class ViewResultDetailsAttribute : ResultFilterAttribute {

        public override async Task OnResultExecutionAsync(

                ResultExecutingContext context,

                ResultExecutionDelegate next) {

            Dictionary<string, string> dict = new Dictionary<string, string> {

                ["Result Type"] = context.Result.GetType().Name,

            };

            ViewResult vr;

            if ((vr = context.Result as ViewResult) != null) {

                dict["View Name"] = vr.ViewName;

                dict["Model Type"] = vr.ViewData.Model.GetType().Name;

                dict["Model Data"] = vr.ViewData.Model.ToString();

            }

            context.Result = new ViewResult {

                ViewName = "Message",

                ViewData = new ViewDataDictionary(

                        new EmptyModelMetadataProvider(),

                        new ModelStateDictionary()) {

                    Model = dict

                }

            };

            await next();

        }

    }

```

#### 结果过滤器 IFilterDiagnostics

```

     public interface IFilterDiagnostics {

        IEnumerable<string> Messages { get; }

        void AddMessage(string message);

    }

    public class DefaultFilterDiagnostics : IFilterDiagnostics {

        private List<string> messages = new List<string>();

        public IEnumerable<string> Messages => messages;

        public void AddMessage(string message) =>

            messages.Add(message);

    }

```

#### IAsyncResultFilter

```

    public class DiagnosticsFilter : IAsyncResultFilter {

        private IFilterDiagnostics diagnostics;

        public DiagnosticsFilter(IFilterDiagnostics diags) {

            diagnostics = diags;

        }

        public async Task OnResultExecutionAsync(

                ResultExecutingContext context,

                ResultExecutionDelegate next) {

            await next();

            foreach (string message in diagnostics?.Messages) {

                byte[] bytes = Encoding.ASCII

                    .GetBytes($"<div>{message}</div>");

                await context.HttpContext.Response.Body

                    .WriteAsync(bytes, 0, bytes.Length);

            }

        }

    }

```

```

 public class TimeFilter : IAsyncActionFilter, IAsyncResultFilter {

        private ConcurrentQueue<double> actionTimes = new ConcurrentQueue<double>();

        private ConcurrentQueue<double> resultTimes = new ConcurrentQueue<double>();

        private IFilterDiagnostics diagnostics;

        public TimeFilter(IFilterDiagnostics diags) {

            diagnostics = diags;

        }

        public async Task OnActionExecutionAsync(

                ActionExecutingContext context, ActionExecutionDelegate next) {

            Stopwatch timer = Stopwatch.StartNew();

            await next();

            timer.Stop();

            actionTimes.Enqueue(timer.Elapsed.TotalMilliseconds);

            diagnostics.AddMessage($@"Action time: 

                {timer.Elapsed.TotalMilliseconds} 

                Average: {actionTimes.Average():F2}");

        }

        public async Task OnResultExecutionAsync(

                ResultExecutingContext context, ResultExecutionDelegate next) {

            Stopwatch timer = Stopwatch.StartNew();

            await next();

            timer.Stop();

            resultTimes.Enqueue(timer.Elapsed.TotalMilliseconds);

            diagnostics.AddMessage($@"Result time: 

                {timer.Elapsed.TotalMilliseconds}

                Average: {resultTimes.Average():F2}");

        }

    }

```

### Controllers

> [HttpGet("object/{format?}")]

>    [FormatFilter]

#### WebAPI

```

    [Route("api/[controller]")]

    public class ContentController : Controller {

        [HttpGet("string")]

        public string GetString() => "This is a string response";

        [HttpGet("object/{format?}")]

        [FormatFilter]

        //[Produces("application/json", "application/xml")]

        public Reservation GetObject() => new Reservation {

            ReservationId = 100,

            ClientName = "Joe",

            Location = "Board Room"

        };

        [HttpPost]

        [Consumes("application/json")]

        public Reservation ReceiveJson([FromBody] Reservation reservation) {

            reservation.ClientName = "Json";

            return reservation;

        }

        [HttpPost]

        [Consumes("application/xml")]

        public Reservation ReceiveXml([FromBody] Reservation reservation) {

            reservation.ClientName = "Xml";

            return reservation;

        }

    }

```

#### Controller

> 所有的动作结果都继承自ActionResult基类 ASP.NET MVC框架支持六种标准类型的动作结果：

> 动作名称 概述 方法名

> ViewResult 视图内容，HTML或标记 View

> EmptyResult 空内容

> RedirectResult 重定向到新的URL

> Redirect RedirectToRouteResult 重定向到新的控制器

> RedirectToAction/RedirectToRoute JsonResult 返回一个JSON（Javascript Object Notation）内容 Json ContentResult 返回文本内容 Content

```

[Route("api/[controller]")]

    public class ReservationController : Controller {

        private IRepository repository;

        public ReservationController(IRepository repo) => repository = repo;

        [HttpGet]

        public IEnumerable<Reservation> Get() => repository.Reservations;

        [HttpGet("{id}")]

        public Reservation Get(int id) => repository[id];

        [HttpPost]

        public Reservation Post([FromBody] Reservation res) =>

            repository.AddReservation(new Reservation {

                ClientName = res.ClientName,

                Location = res.Location

            });

        [HttpPut]

        public Reservation Put([FromBody] Reservation res) =>

            repository.UpdateReservation(res);

        [HttpPatch("{id}")]

        public StatusCodeResult Patch(int id,

                [FromBody]JsonPatchDocument<Reservation> patch) {

            Reservation res = Get(id);

            if (res != null) {

                patch.ApplyTo(res);

                return Ok();

            }

            return NotFound();

        }

        [HttpDelete("{id}")]

        public void Delete(int id) => repository.DeleteReservation(id);

    }

```

#### Rezor View

```

@model IEnumerable<Reservation>

@{  Layout = "_Layout"; }

<form id="addform" asp-action="AddReservation" method="post">

    <div class="form-group">

        <label for="ClientName">Name:</label>

        <input class="form-control" name="ClientName" />

    </div>

    <div class="form-group">

        <label for="Location">Location:</label>

        <input class="form-control" name="Location" />

    </div>

    <div class="text-center panel-body">

        <button type="submit" class="btn btn-sm btn-primary">Add</button>

    </div>

</form>

<table class="table table-sm table-striped table-bordered m-2">

    <thead><tr><th>ID</th><th>Client</th><th>Location</th></tr></thead>

    <tbody>

        @foreach (var r in Model) {

            <tr>

                <td>@r.ReservationId</td>

                <td>@r.ClientName</td>

                <td>@r.Location</td>

            </tr>

        }

    </tbody>

</table>

```

```

services.AddMvc()

    .AddXmlDataContractSerializerFormatters()

    .AddMvcOptions(opts => {

        opts.EnableEndpointRouting = false;

        opts.FormatterMappings.SetMediaTypeMappingForFormat("xml",

            new MediaTypeHeaderValue("application/xml"));

        opts.RespectBrowserAcceptHeader = true;

        opts.ReturnHttpNotAcceptable = true;

    });

```

### ViewComponent

```

 public class PageSize : ViewComponent {

        public async Task<IViewComponentResult> InvokeAsync() {

            HttpClient client = new HttpClient();

            HttpResponseMessage response

                = await client.GetAsync("http://apress.com");

            return View(response.Content.Headers.ContentLength);

        }

    }

```

### Taghelper 

> 可以扩展一些自定义的标记 其实就是后台生成html代码的一种形式

> 扩展标记，可以从后台进行前端Html的配置

> HtmlTargetElement 属性中配置那些html元素，那些样式起作用

> 定义一个Taghelper  formbutton 设置其属性

```

    [HtmlTargetElement("button", Attributes = "bs-button-color", ParentTag = "div")]

    [HtmlTargetElement("a", Attributes = "bs-button-color", ParentTag = "div")]

    [HtmlTargetElement("formbutton")]

    public class LYFButtonTagHelper : TagHelper {

        public string BsButtonColor { get; set; } = "primary";

        public override void Process(TagHelperContext context,

                                     TagHelperOutput output) {

            output.Attributes.SetAttribute("class", $"btn btn-{BsButtonColor}");

        }

    }

```

> View中用法

```

<formbutton>hello</formbutton>

```

> 本质上所有的mvc视图元素都是来自Taghelper 比如form

```

<form method="post" asp-controller="Home" asp-action="Create"

      asp-antiforgery="true">

    <div class="form-group">

        <label asp-for="Name"></label>

        <input class="form-control" asp-for="Name" />

    </div>

    <div class="form-group">

        <label asp-for="Country"></label>

        <select class="form-control" asp-for="Country" asp-items="ViewBag.Countries">

            <option disabled selected value="">Select a Country</option>

        </select>

    </div>

    <div class="form-group">

        <label asp-for="Population"></label>

        <input class="form-control" asp-for="Population" />

    </div>

    <div class="form-group">

        <label asp-for="Notes"></label>

        <textarea class="form-control" asp-for="Notes"></textarea>

    </div>

    <button type="submit" class="btn btn-primary">Add</button>

    <a class="btn btn-primary" href="/Home/Index">Cancel</a>

</form>

```

### SignalR

> 什么是 SignalR？

> > ASP.NET Core SignalR 是一个开放源代码库，可用于简化向应用添加实时 Web 功能。 实时 Web 功能使服务器端代码能够将内容推送到客户端。

> 适合 SignalR 的候选项：

> > 需要从服务器进行高频率更新的应用。 示例包括游戏、社交网络、投票、拍卖、地图和 GPS 应用。

> > 仪表板和监视应用。 示例包括公司仪表板、即时销售更新或旅行警报。

> > 协作应用。 协作应用的示例包括白板应用和团队会议软件。

> > 需要通知的应用。 社交网络、电子邮件、聊天、游戏、旅行警报和很多其他应用都需使用通知。

> > SignalR 提供用于创建服务器到客户端远程过程调用 (RPC) 的 API。 RPC 从服务器端 .NET Core 代码调用客户端上的函数。 提供多个受支持的平台，其中每个平台都有各自的客户端 SDK。 因此，RPC 调用所调用的编程语言有所不同。

> 以下是 ASP.NET Core SignalR 的一些功能：

> > 自动处理连接管理。

> > 同时向所有连接的客户端发送消息。 例如聊天室。

> > 向特定客户端或客户端组发送消息。

> > 对其进行缩放，以处理不断增加的流量。

> > SignalR 中心协议

> > 源托管在 GitHub 上的存储库中SignalR。

> 传输

> > SignalR 支持以下用于处理实时通信的技术（按正常回退的顺序）：

> > WebSockets

> > Server-Sent Events

> > 长轮询

> > SignalR 自动选择服务器和客户端能力范围内的最佳传输方法。

> 中心

> > SignalR 使用 中心 在客户端和服务器之间进行通信。

> > Hub 是一种高级管道，允许客户端和服务器相互调用方法。 SignalR 自动处理跨计算机边界的调度，并允许客户端调用服务器上的方法，反之亦然。 可以将强类型参数传递给方法，从而支持模型绑定。 SignalR 提供两个内置中心协议：基于 JSON 的文本协议和基于 MessagePack 的二进制协议。 与 ON 相比 JS，MessagePack 通常会创建较小的消息。 旧版浏览器必须支持 XHR 级别 2 才能提供 MessagePack 协议支持。

> > 中心通过发送包含客户端方法的名称和参数的消息来调用客户端代码。 作为方法参数发送的对象使用配置的协议进行反序列化。 客户端尝试将名称与客户端代码中的方法匹配。 当客户端找到匹配项时，它会调用该方法并将反序列化的参数数据传递给它。

> 不支持 ECMAScript 6 的浏览器 (ES6)

> > SignalR 面向 ES6。 对于不支持 ES6 的浏览器，请将库转译为 ES5。 有关详细信息，请参阅使用 ES6 入门 – 使用 Traceur 和 Babel 将 ES6 转为 ES5。

> SignalR 简单示例

> > 创建 Web 应用项目

> > > 创建 ASP.NET Core Web 应用

> > > 在“配置新项目”对话框中，为“项目名称”输入 SignalRChat。 请务必将项目命名为 SignalRChat（包括匹配大写），以便命名空间与教程中的代码匹配。

> > 添加 SignalR 客户端库

> > > ASP.NET Core 共享框架中包含 SignalR 服务器库。 JavaScript 客户端库不会自动包含在项目中。 对于此教程，使用库管理器 (LibMan) 从 unpkg 获取客户端库。 unpkg 是一个快速的全局内容分发网络，适用于 npm 上的所有内容。

> > > 在“解决方案资源管理器”>中，右键单击项目，然后选择“添加”“客户端库”。

> > > 在“添加客户端库”对话框中：

> > > 为“提供程序”选择“unpkg”

> > > 对于“库”，请输入 @microsoft/signalr@latest。

> > > 选择“选择特定文件”，展开“dist/browser”文件夹，然后选择 signalr.js 和 signalr.min.js。

> > > 将“目标位置”设置为 wwwroot/js/signalr/。

> > > 选择“安装” 。

> > > “添加客户端库”对话框 - 选择库

> > > LibMan 创建 wwwroot/js/signalr 文件夹并将所选文件复制到该文件夹。

> > 创建 SignalR 中心

> > > 中心是一个类，用作处理客户端 - 服务器通信的高级管道。

> > > 在 SignalRChat 项目文件夹中，创建 Hubs 文件夹。

> > > 在 Hubs 文件夹中，使用以下代码创建 ChatHub 类：

> > > C#

```

using Microsoft.AspNetCore.SignalR;

namespace SignalRChat.Hubs

{

    public class ChatHub : Hub

    {

        public async Task SendMessage(string user, string message)

        {

            await Clients.All.SendAsync("ReceiveMessage", user, message);

        }

    }

}

```

> > > ChatHub 类继承自 SignalRHub。 Hub 类管理连接、组和消息。

> > > 可通过已连接客户端调用 SendMessage，以向所有客户端发送消息。 本教程后面部分将显示调用该方法的 JavaScript 客户端代码。 SignalR 代码是异步模式，可提供最大的可伸缩性。

> > 配置 SignalR

> > > 必须将 SignalR 服务器配置为将 SignalR 请求传递给 SignalR。 将以下突出显示的代码添加到 Program.cs 文件。

C#

```

using SignalRChat.Hubs;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddRazorPages();

builder.Services.AddSignalR();

var app = builder.Build();

// Configure the HTTP request pipeline.

if (!app.Environment.IsDevelopment())

{

    app.UseExceptionHandler("/Error");

    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.

    app.UseHsts();

}

app.UseHttpsRedirection();

app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

app.MapRazorPages();

app.MapHub<ChatHub>("/chatHub");

app.Run();

```

> > > 以上突出显示的代码将 SignalR 添加到 ASP.NET Core 依赖关系注入和路由系统。

> > 添加 SignalR 客户端代码

> > > CSHTML

```

@page

<div class="container">

    <div class="row p-1">

        <div class="col-1">User</div>

        <div class="col-5"><input type="text" id="userInput" /></div>

    </div>

    <div class="row p-1">

        <div class="col-1">Message</div>

        <div class="col-5"><input type="text" class="w-100" id="messageInput" /></div>

    </div>

    <div class="row p-1">

        <div class="col-6 text-end">

            <input type="button" id="sendButton" value="Send Message" />

        </div>

    </div>

    <div class="row p-1">

        <div class="col-6">

            <hr />

        </div>

    </div>

    <div class="row p-1">

        <div class="col-6">

            <ul id="messagesList"></ul>

        </div>

    </div>

</div>

<script src="~/js/signalr/dist/browser/signalr.js"></script>

<script src="~/js/chat.js"></script>

```

> > > JavaScript

```

"use strict";

var connection = new signalR.HubConnectionBuilder().withUrl("/chatHub").build();

//Disable the send button until connection is established.

document.getElementById("sendButton").disabled = true;

connection.on("ReceiveMessage", function (user, message) {

    var li = document.createElement("li");

    document.getElementById("messagesList").appendChild(li);

    // We can assign user-supplied strings to an element's textContent because it

    // is not interpreted as markup. If you're assigning in any other way, you 

    // should be aware of possible script injection concerns.

    li.textContent = `${user} says ${message}`;

});

connection.start().then(function () {

    document.getElementById("sendButton").disabled = false;

}).catch(function (err) {

    return console.error(err.toString());

});

document.getElementById("sendButton").addEventListener("click", function (event) {

    var user = document.getElementById("userInput").value;

    var message = document.getElementById("messageInput").value;

    connection.invoke("SendMessage", user, message).catch(function (err) {

        return console.error(err.toString());

    });

    event.preventDefault();

});

```

## Tensorflow

## C# 调用 Tensorflow

> https://github.com/migueldeicaza/TensorFlowSharp

'''

When to use TensorFlowSharp

TensorFlowSharp is a good runtime to run your existing models, and is mostly a straight binding to the underlying TensorFlow runtime. Most people will want to use a higher-level library for interfacing with TensorFlow.

The library was designed to blend in the .NET ecosystem and use the .NET naming conventions.

I strongly recommend that you use TensorFlow.NET which takes a different approach than TensorFlowSharp, it uses the Python naming convention and has a much broader support for the higher level operations that you are likely to need - and is also actively maintained.

TensorFlowSharp

TensorFlowSharp are .NET bindings to the TensorFlow library published here:

https://github.com/tensorflow/tensorflow

This surfaces the C API as a strongly-typed .NET API for use from C# and F#.

The API surfaces the entire low-level TensorFlow API, it is on par with other language bindings. But currently does not include a high-level API like the Python binding does, so it is more cumbersome to use for those high level operations.

You can prototype using TensorFlow or Keras in Python, then save your graphs or trained models and then load the result in .NET with TensorFlowSharp and feed your own data to train or run.

The current API documentation is here.

Using TensorFlowSharp

Installation

The easiest way to get started is to use the NuGet package for TensorFlowSharp which contains both the .NET API as well as the native libraries for 64-bit Linux, Mac and Windows using the CPU backend.

You can install using NuGet like this:

nuget install TensorFlowSharp

Or select it from the NuGet packages UI on Visual Studio.

On Visual Studio, make sure that you are targeting .NET 4.6.1 or later, as this package uses some features of newer .NETs. Otherwise, the package will not be added. Once you do this, you can just use the TensorFlowSharp nuget

Alternatively, you can download it directly.

Using TensorFlowSharp

Your best source of information right now are the SampleTest that exercises various APIs of TensorFlowSharp, or the stand-alone samples located in "Examples".

This API binding is closer design-wise to the Java and Go bindings which use explicit TensorFlow graphs and sessions. Your application will typically create a graph (TFGraph) and setup the operations there, then create a session from it (TFSession), then use the session runner to setup inputs and outputs and execute the pipeline.

Something like this:

using (var graph = new TFGraph ())

{

    // Load the model

    graph.Import (File.ReadAllBytes ("MySavedModel"));

    using (var session = new TFSession (graph))

    {

        // Setup the runner

        var runner = session.GetRunner ();

        runner.AddInput (graph ["input"] [0], tensor);

        runner.Fetch (graph ["output"] [0]);

        // Run the model

        var output = runner.Run ();

        // Fetch the results from output:

        TFTensor result = output [0];

    }

}

If your application is sensitive to GC cycles, you can run your model as follows. The Run method will then allocate managed memory only at the first call and reuse it later on. Note that this requires you to reuse the Runner instance and not to change the shape of the input data:

// Some input matrices

var inputs = new float[][,] {

    new float[,] { { 1, 2 }, { 3, 4 } },

    new float[,] { { 2, 4 }, { 6, 8 } }

};

// Assumes all input matrices have identical shape

var shape = new long[] { inputs[0].GetLongLength(0), inputs[0].GetLongLength(1) };

var size = inputs[0].Length * sizeof(float);

// Empty input and output tensors

var input = new TFTensor(TFDataType.Float, shape, size);

var output = new TFTensor[1];

// Result array for a single run

var result = new float[1, 1];

using (var graph = new TFGraph())

{

    // Load the model

    graph.Import(File.ReadAllBytes("MySavedModel"));

    using (var session = new TFSession(graph))

    {

        // Setup the runner

        var runner = session.GetRunner();

        runner.AddInput(graph["input"][0], input);

        runner.Fetch(graph["output"][0]);

        // Run the model on each input matrix

        for (int i = 0; i < inputs.Length; i++)

        {

            // Mutate the input tensor

            input.SetValue(inputs[i]);

            // Run the model

            runner.Run(output);

            // Fetch the result from output into `result`

            output[0].GetValue(result);

        }

    }

}

In scenarios where you do not need to setup the graph independently, the session will create one for you. The following example shows how to abuse TensorFlow to compute the addition of two numbers:

using (var session = new TFSession())

{

    var graph = session.Graph;

    var a = graph.Const(2);

    var b = graph.Const(3);

    Console.WriteLine("a=2 b=3");

    // Add two constants

    var addingResults = session.GetRunner().Run(graph.Add(a, b));

    var addingResultValue = addingResults.GetValue();

    Console.WriteLine("a+b={0}", addingResultValue);

    // Multiply two constants

    var multiplyResults = session.GetRunner().Run(graph.Mul(a, b));

    var multiplyResultValue = multiplyResults.GetValue();

    Console.WriteLine("a*b={0}", multiplyResultValue);

}

Here is an F# scripting version of the same example, you can use this in F# Interactive:

#r @"packages\TensorFlowSharp.1.4.0\lib\net471\TensorFlowSharp.dll"

open System

open System.IO

open TensorFlow

// set the path to find the native DLL

Environment.SetEnvironmentVariable("Path", 

    Environment.GetEnvironmentVariable("Path") + ";" + __SOURCE_DIRECTORY__ + @"/packages/TensorFlowSharp.1.2.2/native")

module AddTwoNumbers = 

    let session = new TFSession()

    let graph = session.Graph

    let a = graph.Const(new TFTensor(2))

    let b = graph.Const(new TFTensor(3))

    Console.WriteLine("a=2 b=3")

    // Add two constants

    let addingResults = session.GetRunner().Run(graph.Add(a, b))

    let addingResultValue = addingResults.GetValue()

    Console.WriteLine("a+b={0}", addingResultValue)

    // Multiply two constants

    let multiplyResults = session.GetRunner().Run(graph.Mul(a, b))

    let multiplyResultValue = multiplyResults.GetValue()

    Console.WriteLine("a*b={0}", multiplyResultValue)

Working on TensorFlowSharp

If you want to work on extending TensorFlowSharp or contribute to its development read the CONTRIBUTING.md file.

Please keep in mind that this requires a modern version of C# as this uses some new capabilities there. So you will want to use Visual Studio 2017.

Possible Contributions

Build More Tests

Would love to have more tests to ensure the proper operation of the framework.

Samples

The binding is pretty much complete, and at this point, I want to improve the API to be easier and more pleasant to use from both C# and F#. Creating samples that use Tensorflow is a good way of finding easy wins on the usability of the API, there are some here:

https://github.com/tensorflow/models

Packaging

Mobile: we need to package the library for consumption on Android and iOS.

Documentation Styling

The API documentation has not been styled, I am using the barebones template for documentation, and it can use some work.

Issues

I have logged some usability problems and bugs in Issues, feel free to take on one of those tasks.

Documentation

Much of the online documentation comes from TensorFlow and is licensed under the terms of Apache 2 License, in particular all the generated documentation for the various operations that is generated by using the tensorflow reflection APIs.

Last API update: Release 1.9

'''

## gRPC 

### gRPC 概述

```

gRPC 是一种与语言无关的高性能远程过程调用 (RPC) 框架。

gRPC 的主要优点是：

现代高性能轻量级 RPC 框架。

协定优先 API 开发，默认使用协议缓冲区，允许与语言无关的实现。

可用于多种语言的工具，以生成强类型服务器和客户端。

支持客户端、服务器和双向流式处理调用。

使用 Protobuf 二进制序列化减少对网络的使用。

这些优点使 gRPC 适用于：

效率至关重要的轻量级微服务。

需要多种语言用于开发的 Polyglot 系统。

需要处理流式处理请求或响应的点对点实时服务。

 GRPC是google开源的一个高性能、跨语言的RPC框架，基于HTTP2协议，基于protobuf 3.x，基于Netty 4.x +。GRPC与thrift、avro-rpc等其实在总体原理上并没有太大的区别，简而言之GRPC并没有太多突破性的创新。（如下描述，均基于JAVA语言的实现）

    对于开发者而言：

    1）需要使用protobuf定义接口，即.proto文件

    2）然后使用compile工具生成特定语言的执行代码，比如JAVA、C/C++、Python等。类似于thrift，为了解决跨语言问题。

    3）启动一个Server端，server端通过侦听指定的port，来等待Client链接请求，通常使用Netty来构建，GRPC内置了Netty的支持。

    4）启动一个或者多个Client端，Client也是基于Netty，Client通过与Server建立TCP长链接，并发送请求；Request与Response均被封装成HTTP2的stream Frame，通过Netty Channel进行交互。

```

### gRPC 服务项目模板

```

对 .proto 文件的 C# 工具支持

gRPC 使用协定优先方法进行 API 开发。 在 .proto 文件中定义服务和消息：

ProtoBuf

```

syntax = "proto3";

service Greeter {

  rpc SayHello (HelloRequest) returns (HelloReply);

}

message HelloRequest {

  string name = 1;

}

message HelloReply {

  string message = 1;

}

通过在项目中包含 .proto 文件，可自动生成用于服务、客户端和消息的 .NET 类型：

将包引用添加到 Grpc.Tools 包。

将 .proto 文件添加到 <Protobuf> 项目组。

```

XML

```

<ItemGroup>

  <Protobuf Include="Protos\greet.proto" />

</ItemGroup>

```

有关 gRPC 工具支持的详细信息，请参阅使用 C# 的 gRPC 服务。

ASP.NET Core 上的 gRPC 服务

gRPC 服务可以托管在 ASP.NET Core 上。 这些服务与日志记录、依赖关系注入 (DI)、身份验证和授权等 ASP.NET Core 功能完全集成。

将 gRPC 服务添加到 ASP.NET Core 应用

gRPC 需要 Grpc.AspNetCore 包。 若要了解如何在 .NET 应用中配置 gRPC，请查看配置 gRPC。

```

### ASP.NET Core gRPC 服务项目模板提供了一个入门版服务：

```

public class GreeterService : Greeter.GreeterBase

{

    private readonly ILogger<GreeterService> _logger;

    public GreeterService(ILogger<GreeterService> logger)

    {

        _logger = logger;

    }

    public override Task<HelloReply> SayHello(HelloRequest request,

        ServerCallContext context)

    {

        _logger.LogInformation("Saying hello to {Name}", request.Name);

        return Task.FromResult(new HelloReply 

        {

            Message = "Hello " + request.Name

        });

    }

}

GreeterService 继承自 GreeterBase 类型，后者是从 .proto 文件的 Greeter 服务生成的。 Startup.csProgram.cs 中的客户端可以访问该服务：

app.MapGrpcService<GreeterService>();

若要详细了解 ASP.NET Core 上的 gRPC 服务，请参阅使用 ASP.NET Core 的 gRPC 服务。

```

### 使用 .NET 客户端调用 gRPC 服务

```

gRPC 客户端是从 .proto 文件生成的具体客户端类型。 具体 gRPC 客户端具有转换为 .proto 文件中 gRPC 服务的方法。

var channel = GrpcChannel.ForAddress("https://localhost:5001");

var client = new Greeter.GreeterClient(channel);

var response = await client.SayHelloAsync(

    new HelloRequest { Name = "World" });

Console.WriteLine(response.Message);

gRPC 客户端是使用通道创建的，该通道表示与 gRPC 服务的长期连接。 可以使用 GrpcChannel.ForAddress 创建通道。

有关创建客户端、调用不同服务方法的详细信息，请参阅使用 .NET 客户端调用 gRPC 服务。

```

## Php

### Pyplot，画出各种你想要的图

> https://blog.csdn.net/qq_42257666/article/details/122439666

## Python

### 语言特点

#### 跨平台

##### 可远行于

###### 各大操作系统

#### 解释型脚本语言

##### 内建

###### 高级的数据结构

#### 面向对象的语言

##### 便于

###### 数据和逻辑

####### 相分离

#### 动态语言

##### 变量本身

###### 类型不固定

###### 可随意转换

###### 不需要声明

#### 不用考虑

##### 内存问题

#### 可处理的数据量

##### 无限制

#### 默认编码

##### UTF-8

### 运行程序

#### 两种模式

##### 脚本式编程

###### 一次性执行

####### 源代码脚本

##### 交互式编程

###### 逐行输入

####### 再执行

#### 远行脚本

##### 命令行/终端模式

###### python *.py

##### Linux下可执行脚本

###### 首行添加

####### #!/usr/local/bin/python

####### #!/usr/bin/env python

###### 赋予权限

####### chmod 755 *.py

###### 运行脚本

####### *.py

##### IPython

###### %run *.py

### 代码格式

#### 缩进

##### 用【缩进深度】区分

###### 语句【代码块】

#### 行长

##### 每行不超过80字符

#### 空行

##### 将程序的不同部分分开

#### \ 

##### 继续上一行

##### 跨行特例

###### 闭合操作符

####### [],{},()

###### 三引号

####### 常用于【多行注释】

#### ;

##### 在同一行

###### 连接多个语句

#### :

##### 分开代码块(组)

###### 头&体

### 变量

#### 内涵

##### 存储了一个值

###### 与【变量】相关联的信息

#### 命名规则

##### 只能包含

###### 字母、数字和下划线

##### 不能

###### 以【数字】打头

###### 包含【空格】

###### 使用python保留字：用于【特殊用途】的单词

####### 关键字

####### 函数名

##### 建议

###### 简短又具有描述性

###### 使用【小写字母】

###### 慎用

####### 小写字母l

####### 大写字母O

####### 易与1&0混淆

### 变量赋值

#### 赋值符

##### =

#### 增量赋值

##### +=

#### 多重赋值

##### x=y=z=1

#### 多元赋值

##### x,y,z=1,2,'a'

###### *var收集多余的值

##### 通常【元组】需要【小括号】

##### 建议

###### 加上【小括号】以增加【可读性】

###### (x,y,z)=(1,2,'a')

#### 变量交换

##### x,y=y,x

## Java

### consul

## 数据库基础

### 锁

#### 数据库角度

##### * 独占锁（Exclusive Lock）

> 独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。

> 执行数据更新命令，即INSERT、 UPDATE 或DELETE 命令时，SQL Server 会自动使用独占锁。

> 但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。

##### 共享锁（Shared Lock）

> 共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。

> 在SELECT 命令执行时，SQL Server 通常会对对象进行共享锁锁定。

> 通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。

##### 更新锁（Update Lock）

> 更新锁是为了防止死锁而设立的。当SQL Server 准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server 确定要进行更新数据操作时，

> 它会自动将更新锁换为独占锁。但当对象上有其它锁存在时，无法对其作更新锁锁定。

#### 程序员角度

##### 乐观锁（Optimistic Lock）

> 乐观锁假定在处理数据时，不需要在应用程序的代码中做任何事情就可以直接在记录上加锁、即完全依靠数据库来管理锁的工作。

> 一般情况下，当执行事务处理时SQL Server会自动对事务处理范围内更新到的表做锁定。

##### 悲观锁（Pessimistic Lock）

> 悲观锁对数据库系统的自动管理不感冒，需要程序员直接管理数据或对象上的加锁处理，并负责获取、共享和放弃正在使用的数据上的任何锁。

### 数据库中事务的 

#### ACID 原则

##### 原子性 (Atomicity)：

> 事务的原子性是指一个事务中包含的一条语句或者多条语句构成了一个完整的逻辑单元，这个逻辑单元具有不可再分的原子性。这个逻辑单元要么一起提交执行全部成功，要么一起提交执行全部失败。

##### 一致性 (Consistency)：

> 可以理解为数据的完整性，事务的提交要确保在数据库上的操作没有破坏数据的完整性，比如说不要违背一些约束的数据插入或者修改行为。一旦破坏了数据的完整性，SQL Server 会回滚这个事务来确保数据库中的数据是一致的。

##### 隔离性(Isolation)：

> 与数据库中的事务隔离级别以及锁相关，多个用户可以对同一数据并发访问而又不破坏数据的正确性和完整性。但是，并行事务的修改必须与其它并行事务的修改相互独立，隔离。但是在不同的隔离级别下，事务的读取操作可能得到的结果是不同的。

##### 持久性(Durability)：

> 数据持久化，事务一旦对数据的操作完成并提交后，数据修改就已经完成，即使服务重启这些数据也不会改变。相反，如果在事务的执行过程中，系统服务崩溃或者重启，那么事务所有的操作就会被回滚，即回到事务操作之前的状态。

## NoSQL：选择合适的数据库

### 力什么使用NoSCL数据库？

#### 阻抗失衡

##### 关系模型和内存中的数抠结构不匹配

##### 采用更为方便的数据交互方式提升开发效率

#### 待处理的致据量裉大

##### 超过关系型数据库的承载能力

##### 大集群的出现

###### DBMS不是设计给集群使用的

###### 成本；许可费用

###### 横向扩展和纵向扩展

#### 对数据的访同效率要求高

### NoSQL数据库的分类

#### 键值数抿库

##### 产品

###### Redis

###### BerkeleyDB

###### Memcached

###### Project Voldemort

###### Riak

###### LevelDB

##### 特性

##### 适用场景

###### 存放会话信息

###### 用户配置信息

###### 购物车数据

##### 不适合的场景

###### 数据间有大量关系

###### 含有多项操作的事务

###### 根据键值的部分来查询数据

###### 操作关键字集合

#### 文档数据库

##### 产品

###### MongoDB

###### CouchDB

###### RavenDB

###### Terrastore

###### OrientDB

##### 适用场景

###### 事件记录

###### 内容管理系统及博客平台

###### 网站分析及实时分析

###### 电子商务应用程序

####### 需要较灵活的模式

####### 低成本进行数据模型

##### 不适合场景

###### 包含多项操作的复杂查询

###### 查询持续变化的聚合结构

#### 列族数据库

##### 产品

###### HBase

###### Amazon SimpleDB

###### Cassdndra

###### Hypertable

###### BigTable(google)

##### 适用场景

###### 事件记录

####### 保存应用程序状态

####### 远行中遇到的错误

###### CMS及博客平台

###### 计数器

##### 不适用场景

###### 需要ACID事务

###### 查询模式变化频繁的场合

#### 图数据库

##### 产品

###### FlockDB

###### HyperGraphDB

###### Infinite Graph

###### Neo4J

###### OrientDB

##### 适用场景

###### 互联数据

###### 推荐引擎

###### 基手位置的服务

##### 不适用场景

###### 更新全部或某个子集的实体

## Oracle

### 概述

#### 发展史

> 1970——IBM的Codd博士发表A Relational Modeiof Data for Large Shared Data Banks

> 1978年——Oracle在PDP-11上诞生

> 1983年——用C语言编写的Oracle 3

> 1993年——基于Unix的Oracle 7

> 1997年~1999年——基于Java的Oracle 8和基于lnternet平台的Oracle 8i

> 2001年——支持RAC的Oracle 9i

> 2003年——支持网格计算的Oracle 10g

> 2007年——Oracle终极版本Oracle 11g

#### 网格计算

> 虚拟化

> 动态供应

> 资源集中

> 自适应软件

> 统一管理

#### Oracle 11g新特性

> 企业网格管理的高可用性

> 更加优化的性能

> 简化的信息管理

> 集成的信息

> 内置的商业智能

> 丰富的开发平台

### 数据库结构

#### 体系结构

##### 实例

> 一般情况下Oracle数据库都是一个数据库包含一个实例

##### 数据库

###### 数据文件

####### 表空间

> SYSTEM表空间

> SYSAUX表空间

> 撤销表空间

> USERS表空间

####### 数据文件

> 系统数据

> 用户数据

####### 说明

> 表空间是一个数据库的逻辑区域

> 每个表空间由一个或多个数据文件组成

> 一个数据文件只能属于一个表空间

###### 控制文件

###### 日志文件

####### 重做日志文件

####### 归档日志文件

#### 服务器结构

##### 系统全局区

###### 数据高速缓冲区

###### 重做日志缓冲区

###### 共享池

###### Large Pool

##### 后台进程

###### DBWn

###### LGWR

###### SMON

###### PMON

###### ARCH

###### ......

##### 程序全局区

#### 数据字典

> 存放整个数据库实例重要信息的一组表，多数表归sys用户所有

##### 数据字典构成

###### USER_

> 记录用户对象信息

###### ALL_

> 记录用户的对象信息及被授权访问的对象信息

###### DBA_

> 包含数据库实例的所有对象信息

###### V$_

> 当前实例的动态视图

###### GV_

> 分布式环境下所有实例的动态视图

##### 常用数据字典

> DBA_TABLES(=TABS)

> DBA_TAB_COLUMNS(=COLS)

> DBA_VIEWS

> DBA_SYNONYMS(=SYN)

> DBA_SEQUENCES(=SEQ)

> DBA_CONSTRAINTS

> DBA_INDEXES(=IND)

> DBA_IND_COLUMNS

> DBA_TRIGGERS

> DBA_SOUCE

> DBA_SEGMENTS

> DBA_EXTENTS

> DBA_OBJECTS

### SQL语言

#### DDL

##### create

###### 常用数据类型

> varchar2(n)：变长字符串n<=4000

> char(n)：定长字符串n<=2000

> number(p,s)：p表示精度，s表示小数位数，最大位数是38位

> date：时问日期（7字节）

> binary_float：浮点型，32位

> binary_double：双精度型，64位

> blob：大二进制对象，<=4G

> clob：大字符串对象，<=4G

> bfile：外部的二进制文件

###### 表

###### 主键

> 在创建表时定义主键

> 使用alter table语句定义主键

> 使用alter table修改主键状态

###### 外键

> 在创建表时定义外键

> 使用alter table语句定义外键

> 使用alter table修改外键状态

###### 约束

> check约束

> not null约束

> unique约束

###### 索引

###### 视图

###### 序列

###### 同义词

##### drop

##### alter

#### DML

##### insert

###### 插入数据

###### 复制表数据

> create table…as select…

> insert into…select

##### update

##### merge

##### delete

##### truncate

#### DQL

##### select

###### from子句

###### 投影

###### where子句

####### 比较运算符

> =

> <>

> <

> <=

> >=

> LIKE

> %

> _

> 布尔操作

> OR

> AND

> NOT

> BETWEEN…AND…IN

> order by子句

> asc

> desc

> distinct

> 算数运算：

> +

> -

> *

> /

###### 基本函数

> 字符函数

> concat(c1,c2)

> length(c)

> lower(c)/upper(c)

> ltrim(c)/rtrim(c)/trim(c)

> replace(c1,c2,c3)

> substr(c1,i,j)

> 数字函数

> abs(n)

> acos(n)/asin(n)/atan(n)/cos(n)/sin(n)/tan(n)

> ceil(n)/floor(n)

> exp(n)/ln(n)

> power(n1,n2)

> round(n1,n2)

> sign(n)

> sqrt(n)

> 日期函数

> add_months(d,i)

> last_day(d)

> month_between(d1,d2)

> new_time(d,tz1,tz2)

> sysdate

> 转换函数

> convert(c,dset,sset)

> to_char(x,fmt)

> to_date(c,fmt)

> 分组函数/聚合函数

> AVG

> MAX

> MIN

> SUM

> COUNT

> STDDEV

> VARIANCE

> group by

> having子句

###### 集合操作

> UNION

> INTERSECT

> MINUS

###### 子查询

> 表连接

> 内连接 inner join

> 外连接

> 左外连接

> 右外连接

> 全外连接

> case语句

> decode函数

#### DCL

> grant

> revoke

#### TCL

> commit

> rollback

> savepoint

### PL/SQL

#### 概述

#### PL/SQL编程

##### 基本语言块

##### 字符集

##### 注释

##### 数据类型

##### 变量和常量

##### 表达式和运算符

##### 流程控制

###### if-then-elsif-then-else

###### case-when-else

###### loop-exit

###### for-loop

###### while-loop

#### 过程和函数

##### 过程

##### 函数

#### 错误处理

##### 预定义异常

###### DUP_VAL_ON_INDEX

###### LOGIN_DENIED

###### NO_DATA_FOUND

###### TOO_MANY_ROWS

###### ZERO_DIVIDE

###### VALUE_ERROR

###### CASE_NOT_FOUND

##### 自定义异常

###### RAISE

##### 异常函数

###### SQLCODE

###### QLERRM

#### 包

##### 包头

##### 包体

##### 重载

#### 集合

##### 三种类型

###### index-by表

###### 嵌套表

###### 可变数组

##### 属性和方法

###### COUNT

###### DELETE

###### EXISTS

###### EXTEND

###### FIRST/LAST

###### NEXT/PRIOR

#### 游标

##### 显示游标

##### 隐式游标

##### 游标for循环

##### 游标变量

### 数据库管理

#### 管理控制文件

#### 管理日志文件

#### 管理表空间和数据文件

#### 模式对象管理

#### 表分区和索引分区

#### 用户管理与安全

#### 数据完整性和数据约束

### 数据库优化

#### 系统调整

#### SQL语句优化

##### 常用优化技巧

###### 不要用*代替列名

###### 用truncate代替delete

###### 在确保完整性的情况下多用commit语句

###### 尽量减少表查询的次数

###### 用not exists代替in/not in

###### 用not exists代替distinct

###### 有效利用共享游标

###### 以合理的方式使用函数

##### 表的连接方法

###### 选择from表的顺序

####### 小表放在最右

###### 选择驱动表

###### where子句的连接顺序

####### 能够过滤掉最多记录的的条件放在最右

##### 有效使用索引

###### 索引列的选择

####### where从句频繁使用的列

####### 频繁用于表连接的列

####### 不要将频繁修改的列用作索引

####### 用于函数中的列应当考虑建立函数索引

###### 复合索引有时比单列索引有更好的性能

###### 避免对大表的全表扫描

####### 导致全表扫描的情况

> 查询的表没有索引

> 需要返回所有的行

> 条件中有LIKE且使用了%

> 对索引列使用了函数

> 条件中有IS NULL或IS NOT NULL

###### 监视索引是否被使用

####### alter index idx_name monitoring usage;

##### 优化器

##### 执行计划管理

##### SQL重演

### 备份与恢复

#### RMAN(Recovery Manager)工具

#### 闪回技术

##### flashback

##### show recyclebin

#### 数据导入/导出

##### 导出exp

##### 导入imp

### 数据库集群技术

#### RAC应用

#### ASM

#### 容灾和数据卫士

#### 故障诊断

### 商业智能与数据仓库

#### 多维数据库

#### 数据挖掘

### 数据库事务隔离级别

#### 已提交读模式

> > SET TRANSACTION ISOLATION LEVEL＝READ COMMITTED;

> Oracle 默认使用的事务隔离级别。事务内执行的查询只能看到查询执行前（而非事务开始前）就已经提交的数据。Oracle 的查询永远不会读取脏数据（未提交的数据）。

> Oracle 不会阻止一个事务修改另一事务中的查询正在访问的数据，因此在一个事务内的两个查询的执行间歇期间，数据有可能被其他事务修改。举例来说，如果一个事务内同一查询执行两次，可能会遇到不可重复读取或不存在读取的现象。 

#### 串行模式

> > SET TRANSACTION ISOLATION LEVEL＝ SERIALIZABLE;

> 串行化隔离的事务只能看到事务执行前就已经提交的数据，以及事务内 INSERT ， UPDATE ，及 DELETE 语句对数据的修改。串行化隔离的事务不会出现不可重复读取或不存在读取的现象。 

#### 只读模式

> > SET TRANSACTION＝ READ ONLY;

> 只读事务只能看到事务执行前就已经提交的数据，且事务中不能执行 INSERT ， UPDATE ，及 DELETE 语句。

### 

## SQL Server

### DDL

### DML

### 存储过程

### 索引

#### 聚集索引

#### 非聚集索引

### 数据优化

### 并发

### 灾难恢复

### RAC

### 行列转换

#### 行转列PIVOT

#### 列转行UNPIVOT

### SQL 事务隔离级别:

> > 1、用于控制并发用户如何读写数据的操做。

> > 2、读操作默认使用共享锁；写操作需要使用排它锁。

> > 3、读操作能够控制他的处理的方式，写操作不能控制它的处理方式

> read uncommited（读取未提交数据），

> read commited（读取已提交数据）读取的默认方式，

> repeatable read（可重复读），

> serializable（可序列化），

> snapshot（快照），

> read commited 

> snapshot（已经提交读隔离）（后两个是sql server 2005 里面 引入的）。

> > 隔离的强度依次递增。

> > 隔离级别越高,读操作的请求锁定就越严格,

> > 锁的持有时间久越长;所以隔离级别越高,

> > 一致性就越高,并发性就越低,同时性能也相对影响越大.

#### read uncommited（读取未提交数据），

> > read uncommitted：最低的隔离级别：查询的时候不会请求共享锁，

> 所以不会和排它锁产生冲突（不会等待排它锁执行完），

> 查询效率非常高，速度飞快。但是缺点：会查到“脏数据”

> （排它锁的事务已经将数据修改，还没提交，这个时候查询到的数据 是已经更改过的。如果事务回滚，就是“脏数据”）

> 优点：查询效率非常高，速度非常快。

> 缺点：会产生“脏数据”

> 适用性：

> 适用于 像聊天软件的 聊天记录，会是软件的运行速度非常快。 但是不适用于 商务软件。尤其是银行

set transaction isolation level read uncommitted;

#### read commited（读取已提交数据）读取的默认方式，

> > 读取的默认隔离级别就是read committed 和上面正好相反。

> 如果上面情况，采用read committed 隔离级别查询的话查到的就是还没有更改之前的数据。

> set transaction isolation level read committed;

#### repeatable read（可重复读），

> > 查询的时候会加上共享锁，但是查询完成之后，共享锁就会被撤销。

> 比如一些购票系统，如果查到票了，当买的时候就没有，这是不行的。

> 所以要在查询到数据之后做一些延迟共享锁，进而阻塞排它锁来修改。

> （如果查询的事务没有提交，不会释放共享锁，这个时候独占锁就不能访问这条数据）

> 注意：

> 1、repeatable 只会锁定查询的数据 ，而 其他行数据还可以进行 修改（更新、删除）（下面那条语句共享锁只会锁定 shipperid为4 的行）

> 2、其他进行插入数据，并且插入的数据满足第一次开始事务时的 查询的筛选条件的时候；

> 第二次查询的时候就会将新插入的数据 查询出来。这就叫做“幻读”（解决幻读，需要更高级别的隔离，就是下面的serializable）

> set transaction isolation level repeatable read;

#### serializable（可序列化），

> > 更高级的 隔离。用户解决“幻读”（上面提到的）。

> 就是使用上面的（repeatable read）  加上共享锁 并不撤销，如果锁定的 一行数据，

> 那么 其他的进程 还可以对 其他的数据进行操作，也可以 进行新增和删除的操作。

> 所以如果想要在查询的时候，不能对整张表进行任何操作，

> 那么就要 将表的结构也 锁定    （就需要使用 更强的 锁定）

> set transaction isolation level serializable;

#### snapshot（快照），

> > 为数据产生一个临时数据库，当sql server 数据更新之前将当前数据库复制到 tempdb数据库里面，

> 查询就是从tempdb数据库中查询，但是不能再 使用 snapshot 线程的事务内执行 修改操作，

> 因为不能修改 旧版本数据库（tempdb），会报错。

> snapshot隔离级别，读操作 不适用 共享锁，使用的是“行版本控制”，

> 所以读数据的性能效率很高，但是修改操作性能就降低的很多。

> 因为是将 数据库  中的数据 复制到 tempdb 数据库中，所以不会产生 幻读。

> set transaction isolation level snapshot;

> >带来两个问题：

> > 1、当 另外一个事务  已经提交，但是这边的查询到数据还是没有修改。因为 每次查询到的快照是针对于 本次回话对应的那个 transaction 的，因为在这个事务里面是没有修改的，所以查询到的数据是没有修改的。

> > 2、（更新问题）因为 那边的数据已经是 飞凤公司了，但是这里还是   联邦,所以,在这个事务里面是不能对表进行修改,因为访问的是临时数据库,想要对 数据库修改是不可能的（sql server 就会报错，阻止修改） 

#### read commited snapshot（已经提交读隔离）

> > 读取的默认隔离级别就是read committed 和上面正好相反。

> 如果上面情况，采用read committed 隔离级别查询的话查到的就是还没有更改之前的数据。

> alter database ssdemo set read_committed_snapshot on;

#### Sql Server 事务隔离级别的查看及更改

> 根据自身 Sql Server 的情况来自定义 事务隔离级别，将会更加的满足需求，或提升性能。例如，对于逻辑简单的 Sql Server,完全可以使用 read uncommitted 模式，来减少死锁，减少堵塞， 提升性能和响应。对于此种应用场景应该是蛮多的，但是却没有一个全局设置，你妹呀！

> 这个功能真的很强大，但是不知道微软为什么把它的最大作用域定义为 当前链接，蛋疼，真的很蛋疼，没法全局设置，下面也尽可能详细的解释如何少设置，多舒服的使用吧

> 查看 当前 Sql Server 事务隔离级别 的设置：

> DBCC Useroptions -> isolation level 这一项的 Value 既是当前的设置值

> 但是我不得不说，这个命令几乎是废物，为什么呢，因为 事务隔离级别 的作用域是 当前链接，也就是，你查看的是当前链接的 级别，但是sql server 同时 150+ 个链接是很正常的，其他链接呢，你说蛋疼不，我X

> 设置Sql Server 事务隔离级别

> Sql Server 事务隔离级别 的设置也同样很蛋疼，很纠结，很恶心。但是稍微好一点的是，其设置可以在多个场合，多种方式设置，稍微弥补了一点点.

1. Transact-SQL 语句中的设置

> 就是在当前 SQL 语句中，设置的事务隔离级别只影响当前 sql 语句, 有两种方式：

> > -- the first method

> > select *  from Table1 with(nolock) 

> > -- the second method

> > SET TRANSACTION ISOLATION LEVEL Read UnCommitted;

> > select *  from Table1 

> > 这种方式比较灵活，可以重点语句重点对待，缺点就是 要设置的实在是太多了，因为这种方式的作用域实在是太小了啊啊啊啊

1. ADO.NET 中的设置

> 使用 System.Data.SqlClient 托管命名空间的 ADO.NET 应用程序可以调用 SqlConnection.BeginTransaction 方法并将 IsolationLevel 选项设置为 Unspecified、Chaos、ReadUncommitted、ReadCommitted、RepeatableRead、Serializable 或 Snapshot。

就是 SqlConnection 中设置了，代码如下：

System.Data.SqlClient.SqlConnection con = new SqlConnection();

con.BeginTransaction(IsolationLevel.ReadUncommitted);

这种方式有点就是作用域范围变大了；缺点就是要在 C## 设置，最要命的是，如果用了ORM，如何让我设置！！！！！！！！！！！！！

当然，还有其他的设置，详情请参考：调整事务隔离级别

这就是蛋疼的功能，如此好的功能，却如此蛋疼的设置，没有一个全局的设置，强烈建议 微软 把 事务隔离级别 的设置放到 sp_configure 里面去

Sql Server 事务隔离级别的解释：

事务指定一个隔离级别，该隔离级别定义一个事务必须与其他事务所进行的资源或数据更改相隔离的程度。隔离级别从允许的并发副作用（例如，脏读或幻读）的角度进行描述。

事务隔离级别控制：

读取数据时是否占用锁以及所请求的锁类型。

占用读取锁的时间。

引用其他事务修改的行的读取操作是否：

在该行上的排他锁被释放之前阻塞其他事务。

检索在启动语句或事务时存在的行的已提交版本。

读取未提交的数据修改。

选择事务隔离级别不影响为保护数据修改而获取的锁。事务总是在其修改的任何数据上获取排他锁并在事务完成之前持有该锁，不管为该事务设置了什么样的隔离级别。对于读取操作，事务隔离级别主要定义保护级别，以防受到其他事务所做更改的影响。

较低的隔离级别可以增强许多用户同时访问数据的能力，但也增加了用户可能遇到的并发副作用（例如脏读或丢失更新）的数量。相反，较高的隔离级别减少了用户可能遇到的并发副作用的类型，但需要更多的系统资源，并增加了一个事务阻塞其他事务的可能性。应平衡应用程序的数据完整性要求与每个隔离级别的开销，在此基础上选择相应的隔离级别。最高隔离级别（可序列化）保证事务在每次重复读取操作时都能准确检索到相同的数据，但需要通过执行某种级别的锁定来完成此操作，而锁定可能会影响多用户系统中的其他用户。最低隔离级别（未提交读）可以检索其他事务已经修改、但未提交的数据。在未提交读中，所有并发副作用都可能发生，但因为没有读取锁定或版本控制，所以开销最少。

ISO 标准定义了下列隔离级别，SQL Server 数据库引擎支持所有这些隔离级别：

未提交读（隔离事务的最低级别，只能保证不读取物理上损坏的数据）

已提交读（数据库引擎的默认级别）

可重复读

可序列化（隔离事务的最高级别，事务之间完全隔离）

隔离级别

脏读

不可重复读

幻读

未提交读

是

是

是

已提交读

否

是

是

可重复读

否

否

是

快照

否

否

否

可序列化

否

否

否

## LiteDB：本地化NOSQL

 LiteDB是一个小型的.NET平台开源的NoSQL类型的轻量级文件数据库。特点是小和快，dll文件只有200K大小，而且支持LINQ和命令行操作，数据库是一个单一文件，类似Sqlite。

　 官方网站：http://www.litedb.org/

### 特点

> 1.NoSQL文件存储。这是和传统关系型数据库的主要区别；支持实体类的字段更新；

> 2.类似MongoDB的简单API；

> 3.完全使用C#代码,在.NET 4.0环境下编写，核心dll小巧,只有168K;

> 4.支持ACID事务处理；

> 5.可以进行写入失败的恢复；

> 6.存储到文件或者数据流中（类似MongoDB的GridFS）;

> 7.类似Sqlite的单一文件存储；

> 8.支持文件索引，可以进行快速搜索；可以直接存储文件；

> 9.支持Linq查询；【这也许是C#编写最直接的好处】;

> 10.支持命令行操作数据库，官方提供了一个Shell command line;

> 11.完全开源和免费，包括商业使用；

> Serverless NoSQL 文档存储

> 类似于 MongoDB 的简单 API

> 100% C## 代码，支持.NET 3.5 / .NET 4.0 / NETStandard 1.3 / NETStandard 2.0，单 DLL (小于 300kb)

> 支持线程和进程安全

> 支持文档/操作级别的 ACID

> 支持写失败后的数据还原 (日志模式)

> 可使用 DES (AES) 加密算法进行数据文件加密

> 可使用特性或 fluent 映射 API 将你的 POCO类映射为 BsonDocument

> 可存储文件与流数据 (类似 MongoDB 的 GridFS)

> 单数据文件存储 (类似 SQLite)

> 支持基于文档字段索引的快速搜索 (每个集合支持多达16个索引)

> 支持 LINQ 查询

> Shell 命令行 - 试试这个在线版本

> 相当快 - 这里是与 SQLite 的对比结果

> 开源，对所有人免费 - 包括商业应用

### LiteDB使用基本案例

#### 创建实体类

public class Customer

{

    public int Id { get; set; }

    public string Name { get; set; }

    public string[] Phones { get; set; }

    public bool IsActive { get; set; }

}

#### 使用Demo

使用过程首先要添加dll应用，以及引入命名空间：

using LiteDB;

    下面是测试代码，会在当前目录下创建一个sample.db的数据库文件：

//打开或者创建新的数据库

using (var db = new LiteDatabase("sample.db"))

{

    //获取 customers 集合，如果没有会创建，相当于表

    var col = db.GetCollection<Customer>("customers");

    //创建 customers 实例

    var customer = new Customer

    {

        Name = "John Doe",

        Phones = new string[] { "8000-0000", "9000-0000" },

        IsActive = true

    };

    // 将新的对象插入到数据表中，Id是自增，自动生成的

    col.Insert(customer);

    // 更新实例

    customer.Name = "Joana Doe";

    //保存到数据库

    col.Update(customer);

    // 使用对象的属性，这个方法生成索引，来进行检索

    col.EnsureIndex(x => x.Name);

    //使用LINQ语法来检索

    var results = col.Find(x => x.Name.StartsWith("Jo"));

}

    上述过程很清楚，根据注释理解几乎不用费神。

### 使用场景

> 1.桌面或者本地小型的应用程序

> 2.小型web应用程序

> 3.单个数据库账户或者单个用户数据的存储

> 4.少量用户的并发写操作的应用程序

### LiteDB的技术细节

#### LiteDB的工作原理

> LiteDB是虽然单个文件类型的数据库，但是数据库有很多信息，

例如索引，集合，文件等。为了管理这些信息，LiteDB实现了数据库页的概念。

页 是一个拥有4096 字节的 存储相同信息的地址块。

页 也是操作磁盘文件(读写)的最小单元。LiteDB有6种页类型。

其作用也不一样，分布是：Header Page，Collection Page，Index Page， Data Page，Extend Page，Empty Page。

鉴于篇幅较大，这里只介绍重要的Data Page。

其他几个页面的作用看文件也很容易。Data Page的作用是存储核心的数据，是以序列化后的BSON格式来存储。

值得注意的是，如果存储的数据太大，超过page大小，数据块就会使用一个指针指向Extend Page。

　　在上面的代码中，我们初始化数据库是这样的：

1

var db = new LiteDatabase("MyData.db");

　　这种情况比较好用，可以打开或者创建新的数据库，同样也可以使用连接名称来获取，例如：

1

var db = new LiteDatabase("userdb");

　　这样会直接从connectionStrings找到这个名称的连接。包括了文件名称，使用模式，以及版本信息。一般情况下直接使用第一种即可。

　　LiteDB的数据库连接完整形式是：filename=C:\Path\mydb.db; journal=false; version=5　　

#### LiteDB的查询

本节翻译自：https://github.com/mbdavid/LiteDB/wiki/Queries

　　LiteDB的查询必须在相关的查询字段上使用索引，如果没有索引，会默认去创建索引。上面例子中就是创建字段的索引，并查询。LiteDB中查询有2种方法：

1.使用静态的帮助类Query;

2.使用Linq方式，就是类似Demo的方法;

　　LiteDB使用Query的查询方式有以下一些方法，详细讲解几个重要的，其他几个大家理解一下，也应该不难，如果有不准确的地方，还请指正： 

Query.All 返回所有的数据，可以使用指定的索引字段进行排序

Query.EQ 查找返回和指定字段值相等的数据

Query.LT/LTE 查找< 或 <= 某个值的数据

Query.GT/GTE 查找> 或 >= 某个值的数据

Query.Between 查找在指定区间范围内的数据

Query.In - 和SQL的in类似吧，查找和列表中值相等的数据

Query.Not - 和EQ相反，是不等于某个值的数据

Query.StartsWith 查找以某个字符串开头的数据

Query.Contains 查找保护某个字符串的数据，这个查询只扫描索引

Query.And 2个查询的交集

Query.Or 2个查询结果的并集

看看实际代码：

var results = collection.Find(Query.EQ("Name", "John Doe"));

var results = collection.Find(Query.GTE("Age", 25));

var results = collection.Find(Query.And(

    Query.EQ("FirstName", "John"), Query.EQ("LastName", "Doe")

));

var results = collection.Find(Query.StartsWith("Name", "Jo"));

　　如图，语法是左边是字段，右边是值。注意LiteDB不支持这种表达式：CreationDate == DueDate。

　　下面介绍使用Linq的查询的几个主要方法：

FindAll: 查找表或者集合中所有的结果记录

FindOne:返回第一个或者默认的结果

FindById: 通过索引返回单个结果

Find: 使用查询表达式或者linq表达式查询返回结果

 看看几个例子：


collection.EnsureIndex(x => x.Name);

var result = collection

    .Find(Query.EQ("Name", "John Doe")) 

    .Where(x => x.CreationDate >= x.DueDate.AddDays(-5)) 

    .OrderBy(x => x.Age)

    .Select(x => new

    { 

        FullName = x.FirstName + " " + x.LastName, 

        DueDays = x.DueDate - x.CreationDate 

    });

 当然还有一些方法如：Count() , Exists(),Min() , Max()等方法。。比较好理解。看看linq表达式的查询案例：

var collection = db.GetCollection<Customer>("customer");

var results = collection.Find(x => x.Name == "John Doe");

var results = collection.Find(x => x.Age > 30);

var results = collection.Find(x => x.Name.StartsWith("John") && x.Age > 30);

##### Query.All 返回所有的数据，可以使用指定的索引字段进行排序

##### Query.EQ 查找返回和指定字段值相等的数据

##### Query.LT/LTE 查找< 或 <= 某个值的数据

##### Query.GT/GTE 查找> 或 >= 某个值的数据

##### Query.Between 查找在指定区间范围内的数据

##### Query.In - 和SQL的in类似吧，查找和列表中值相等的数据

##### Query.Not - 和EQ相反，是不等于某个值的数据

##### Query.StartsWith 查找以某个字符串开头的数据

##### Query.Contains 查找保护某个字符串的数据，这个查询只扫描索引

##### Query.And 2个查询的交集

##### Query.Or 2个查询结果的并集

#### LiteDB的查询

##### LiteDB的技术细节

### C## 示例

#### 基本示例

##### namespace Inovance.FA.FAOutTest.Views

{

    

    /// <summary>

    /// SelectDevices.xaml 的交互逻辑

    /// </summary>

    public partial class TestLiteDB

    {

        public TestLiteDB() : base("")

        {

    InitializeComponent();

    this.Loaded += TestLiteDB_Loaded;

        }

        private void TestLiteDB_Loaded(object sender, RoutedEventArgs e)

        {

     InitDB();

        }

        public void InitDB()

        {

            using (var db = new LiteDatabase("sample.db"))

            {

                //获取 customers 集合，如果没有会创建，相当于表

                var col = db.GetCollection<Customer>("customers");

                //创建 customers 实例

                var customer = new Customer

                {

                    Name = "John Doe",

                    Phones = new string[] { "8000-0000", "9000-0000" },

                    IsActive = true

                };

                // 将新的对象插入到数据表中，Id是自增，自动生成的

                col.Insert(customer);

                // 更新实例

                customer.Name = "Joana Doe";

                //保存到数据库

                col.Update(customer);

                // 使用对象的属性，这个方法生成索引，来进行检索

                col.EnsureIndex(x => x.Name);

                //使用LINQ语法来检索

                var results = col.Find(x => x.Name.StartsWith("Jo"));

                tbContent.Text = JsonConvert.SerializeObject(results);

            }

        }

    }

}

## LabView

### 工程

### VI

### 第1章LabⅥEW基础知识

#### 1.1LabⅥEW简介

##### 1.1.1LabⅥEW概述

##### 1.1.2LabⅥEW 2018的新功能

#### 1.2LabⅥEW编程环境

##### 1.2.1前面板

##### 1.2.2程序框图

##### 1.2.3菜单栏

##### 1.2.4工具栏

##### 1.2.5项目浏览器窗口

#### 1.3Ⅵ管理

##### 1.3.1新建Ⅵ

##### 1.3.2保存Ⅵ

##### 1.3.3运行Ⅵ

##### 1.3.4纠正Ⅵ的错误

##### 1.3.5高亮显示程序执行过程

##### 1.3.6单步通过Ⅵ及其子Ⅵ

##### 1.4LabⅥEW 2018的帮助系统

##### 1.4.1使用即时帮助

##### 1.4.2使用目录和索引查找在线帮助

##### 1.4.3查找LabⅥEW范例

##### 1.4.4使用网络资源

#### Xcontrol

##### 1.什么是LabVIEW XControl

###### XControl对于用户来说，和普通的控件没有区别，但XControl对于开发者来说，除了有自定义外观外，还能自定义行为。

##### 2.XControl的好处

###### 可以将控件的功能封装起来，使其和应用程序代码分离。同时有助于重用。

##### 3.创建XControl

###### 新建XCtrl：

###### Data.ctl: 指定了XCtrl的数据类型；

###### State.ctl: 指定了除数据类型之外其他影响XCtrl外观的信息，其他所有数据的定义放在此处；

###### Init.vi: 当XCtrl第一次被放置在前面板上或含有XCtrl的vi第一次被载入内存时，初始化显示状态。

###### 新建Method，定义XCtrl支持的方法（类似于类的成员函数），用于操作State中的数据；这里实现各种具体的操作。

###### 新建Property，定义了XCtrl的可读取属性（类似于LabVIEW类的accessor的工作），用于读取XCtrl中的数据；

###### 修改facade vi，用于定制XControl的外观，创建各种状态改变事件。

###### X控件的本质是为控件事先定义好一系列可以响应的事件，之后使用控件时，就可以在控件的属性或调用节点中看到这些事件，像操作普通控件一样，调用这些节点来执行特定操作。

###### 以LabVIEW自带的摄氏华氏温度转换XCtrl为例：

### 第2章前面板设计

#### 2.1前面板

##### 2.1.1“工具”选板

##### 2.1.2实例——标注汽车行驶车速变化表

##### 2.1.3图标/连接器

##### 2.1.4实例——设计汽车行驶车速变化表图标

##### 2.1.5选板可见性设置

#### 2.2前面板控件

##### 2.2.1“控件”选板

##### 2.2.2控件样式

##### 2.2.3实例——数值控件的使用

#### 2.3对象的设置

##### 2.3.1选择对象

##### 2.3.2删除对象

##### 2.3.3变更对象位置

##### 2.3.4属性节点

##### 2.3.5实例——控件显示

#### 2.4设置前面板的外观

##### 2.4.1改变对象的大小

##### 2.4.2改变对象的颜色

##### 2.4.3设置对象的字体

##### 2.4.4实例——编辑汽车行驶车速变化表标注

##### 2.4.5对象编辑窗口

##### 2.4.6实例——设计计算机控件

#### 2.5菜单设计

##### 2.5.1菜单编辑器

##### 2.5.2实例——自定义菜单系统

##### 2.5.3“菜单”函数

#### 2.6综合实例——交通信号灯控制系统

### 第3章程序框图与程序结构

#### 3.1程序框图

#### 3.2循环结构

##### 3.2.1For循环及并行循环

##### 3.2.2实例——显示循环次数

##### 3.2.3移位寄存器

##### 3.2.4实例——计算1+2+…+100

##### 3.2.5实例——计算偶数的和与积

##### 3.2.6实例——计算循环次数与循环总数

##### 3.2.7While循环

##### 3.2.8实例——求解平方和优选值

##### 3.2.9反馈节点

##### 3.2.10实例——指示灯显示

#### 3.3条件结构

#### 3.3.1添加条件结构

#### 3.3.2实例——计算圆面积

#### 3.4顺序结构

#### 3.5事件结构

#### 3.5.1实例——自定义控件的菜单

#### 3.5.2程序框图禁用结构

#### 3.5.3条件禁用结构

#### 3.6定时循环

#### 3.6.1定时循环和定时顺序结构

#### 3.6.2实例——定时循环参数设置

#### 3.6.3配置定时循环和定时顺序结构

#### 3.6.4同步开始定时结构和中止定时结构的执行

#### 3.6.5实例——设置循环周期

#### 3.7公式节点

#### 3.7.1程序逻辑的公式节点

#### 3.7.2实例——输出函数值

#### 3.8综合实例——定时循环显示循环次数

### 第4章数值字符串与布尔运算

#### 4.1数值控件

#### 4.1.1数值型控件

#### 4.1.2实例——水库蓄水系统前面板设计

#### 4.1.3布尔型控件和单选按钮

#### 4.1.4字符串与路径控件

#### 4.1.5实例——“银色”选板控件的使用方法

#### 4.1.6设置数值型控件的属性

#### 4.1.7实例——显示温度单位

#### 4.1.8设置文本型控件的属性

#### 4.1.9实例——组合框的使用方法

#### 4.1.10设置布尔型控件的属性

#### 4.1.11实例——切换按钮颜色

#### 4.2数值运算

#### 4.2.1数值函数

#### 4.2.2实例——水库蓄水系统

#### 4.2.3实例——仪表显示

#### 4.2.4函数快捷菜单命令

#### 4.2.5实例——车检基本情况表

#### 4.2.6实例——气温测试系统

#### 4.2.7三角函数

#### 4.2.8实例——正切函数计算

#### 4.3字符串运算

#### 4.3.1字符串常量

#### 4.3.2实例——字符显示

#### 4.3.3设置字符串控件的属性

#### 4.3.4实例——字符转换

#### 4.3.5实例——字符选择

#### 4.3.6字符串函数

#### 4.3.7实例——英文字符转换

#### 4.4其余运算

#### 4.4.1布尔运算

#### 4.4.2比较运算

#### 4.4.3定时运算

#### 4.4.4对话框与用户界面运算

#### 4.4.5图形与声音运算

#### 4.4.6实例——水库预警系统

#### 4.5综合实例——血压测试系统

### 第5章数组、矩阵与簇

#### 5.1数组控件

##### 5.1.1数组、矩阵和簇控件

##### 5.1.2列表框、树形控件和表格

##### 5.1.3容器控件

##### 5.1.4实例——数组分类

#### 5.2数组

##### 5.2.1数组的组成

##### 5.2.2实例——创建数组控件

##### 5.2.3实例——创建多维数组控件

##### 5.2.4数组函数

##### 5.2.5实例——比较数组

##### 5.2.6实例——选项卡数组

#### 5.3簇

##### 5.3.1簇的组成

##### 5.3.2创建簇

##### 5.3.3实例——创建簇控件

##### 5.3.4实例——调整“簇”控件顺序

##### 5.3.5簇函数

##### 5.3.6实例——使用“捆绑”函数创建“簇”控件

#### 5.4矩阵

##### 5.4.1创建矩阵

##### 5.4.2矩阵函数

##### 5.4.3实例——创建矩阵控件

##### 5.4.4实例——矩阵变换

#### 5.5综合实例——矩形的绘制

### 第6章数据图形显示

#### 6.1图形控件

#### 6.1.1图形和图表

#### 6.1.2下拉列表与枚举控件

#### 6.1.3I/O控件

#### 6.1.4修饰控件

#### 6.1.5实例——设计数学运算系统前面板

#### 6.1.6对象和应用程序的引用

#### 6.1.7.NET与ActiveX控件

#### 6.1.8设置图形显示控件的属性

#### 6.1.9实例——标注曲线

#### 6.2图表图形

#### 6.2.1波形图

#### 6.2.2实例——双Y轴曲线

#### 6.2.3波形图表

#### 6.2.4实例——波形图表数据显示模式

#### 6.2.5XY图

#### 6.2.6实例——绘制跳动曲线

#### 6.2.7强度图

#### 6.2.8实例——强度图的使用

#### 6.2.9强度图表

#### 6.2.10实例——强度图表的使用

#### 6.3二维图形

#### 6.3.1罗盘图

#### 6.3.2误差线图

#### 6.3.3实例——绘制铸件尺寸误差棒图

#### 6.3.4羽状图

#### 6.3.5XY曲线矩阵

#### 6.3.6实例——绘制XY曲线矩阵图

#### 6.4三维图形

#### 6.4.1三维曲面图

#### 6.4.2实例——山峰函数曲面图

#### 6.4.3三维参数图

#### 6.4.4实例——单位球面

#### 6.4.5三维曲线图

#### 6.4.6实例——绘制螺旋线

#### 6.4.7极坐标图

#### 6.5综合实例——延迟波形

### 第7章数学函数

#### 7.1数学函数运算

#### 7.2线性代数Ⅵ

#### 7.2.1特殊矩阵

#### 7.2.2矩阵的基本运算

#### 7.2.3实例——创建逆矩阵与转置矩阵

#### 7.2.4矩阵的分解

#### 7.2.5实例——分解帕斯卡矩阵

#### 7.2.6特征值

#### 7.2.7实例——创建矩阵特征向量

#### 7.2.8线性方程组

#### 7.3初等与特殊函数

#### 7.3.1指数函数

#### 7.3.2实例——绘制火柴杆图

#### 7.3.3双曲函数

#### 7.3.4实例——绘制双曲正弦曲线

#### 7.3.5离散数学

#### 7.3.6实例——离散计算选项卡

#### 7.3.7贝塞尔曲线

#### 7.3.8实例——绘制贝塞尔曲线条形图

#### 7.3.9Gamma函数

#### 7.3.10实例——绘制Gamma函数及其倒数函数

#### 7.3.11超几何函数

#### 7.3.12椭圆积分函数

#### 7.3.13指数积分函数

#### 7.3.14误差函数

#### 7.3.15椭圆与抛物函数

#### 7.3.16实例——绘制抛物柱面曲线

#### 7.4拟合Ⅵ

#### 7.4.1曲线拟合

#### 7.4.2拟合函数

#### 7.4.3实例——金属材料应力拟合数据

#### 7.5内插与外推Ⅵ

#### 7.6概率与统计Ⅵ

#### 7.6.1累积分布函数（连续）

#### 7.6.2逆累积分布函数（连续

#### 7.6.3累积分布函数（离散）

#### 7.6.4逆累积分布函数（离散）

#### 7.6.5实例——绘制几何概率曲线

#### 7.6.6方差分析Ⅵ

#### 7.7很优化Ⅵ

#### 7.8微分方程Ⅵ

#### 7.9多项式Ⅵ

#### 7.10综合实例——分解矩阵

### 第8章波形运算

#### 8.1波形数据

#### 8.1.1变体函数

#### 8.1.2时间标识

#### 8.2波形生成

#### 8.2.1基本函数发生器

#### 8.2.2实例——生成正弦信号的波形图

#### 8.2.3正弦波形

#### 8.2.4公式波形

#### 8.2.5实例——生成公式信号

#### 8.2.6基本混合单频

#### 8.2.7混合单频与噪声波形

#### 8.2.8基本带幅值混合单频

#### 8.2.9混合单频信号发生器

#### 8.2.10均匀白噪声波形

#### 8.2.11实例——创建均匀白噪声波形

#### 8.2.12周期性随机噪声波形

#### 8.2.13二项分布的噪声波形信号

#### 8.2.14伯努利噪声波形

#### 8.2.15实例——输出噪声波形

#### 8.2.16仿真信号

#### 8.2.17实例——使用ExpressⅥ生成曲线

#### 8.3基本波形函数

#### 8.3.1获取波形成分

#### 8.3.2创建波形

#### 8.3.3实例——创建随机波形图

#### 8.3.4“设置波形属性”函数和“获取波形属性”函数

#### 8.3.5“索引波形数组”函数

#### 8.3.6“获取波形子集”函数

#### 8.3.7实例——简单正弦波形

#### 8.3.8模拟波形

#### 8.3.9实例——波形的偏移与缩放

#### 8.3.10数字波形Ⅵ和函数

#### 8.4波形调理

#### 8.4.1数字FIR滤波器

#### 8.4.2数字IIR滤波器

#### 8.4.3按窗函数缩放

#### 8.4.4波形对齐（连续）

#### 8.4.5波形对齐（单次）

#### 8.4.6实例——波形的对齐和相减

#### 8.4.7连续卷积（FIR）

#### 8.4.8滤波器

#### 8.4.9对齐和重采样

#### 8.4.10触发与门限

#### 8.4.11实例——执行带可选规范的IIR滤波

#### 8.5波形测量

#### 8.5.1基本平均直流——均方根

#### 8.5.2瞬态特性测量

#### 8.5.3提取单频信息

#### 8.5.4快速傅里叶变换频谱（幅度——相位）

#### 8.5.5频率响应函数（幅度——相位）

#### 8.5.6频谱测量

#### 8.5.7失真测量

#### 8.5.8幅值和电平测量

#### 8.5.9实例——幅值和电平测量计算

#### 8.5.10波形监测

#### 8.5.11实例——基本电平触发波形

#### 8.6综合实例——混合信号图

### 第9章信号生成与处理

#### 9.1信号生成

#### 9.1.1基于持续时间的信号发生器

#### 9.1.2混合单频与噪声

#### 9.1.3高斯调制正弦波

#### 9.1.4实例——计算高斯调制正弦波

#### 9.1.5正弦信号

#### 9.1.6正弦波

#### 9.1.7均匀白噪声

#### 9.1.8任意波形发生器

#### 9.1.9实例——对方波信号进行仿真滤波

#### 9.2信号运算

#### 9.2.1卷积和相关ExpressⅥ

#### 9.2.2缩放和映射

#### 9.3窗

#### 9.4滤波器

#### 9.4.1巴特沃斯滤波器

#### 9.4.2实例——正弦信号滤波

#### 9.4.3切比雪夫滤波器

#### 9.4.4FIR加窗滤波器

#### 9.4.5SaⅥtzky-Golay滤波器

#### 9.4.6贝塞尔滤波器

#### 9.5谱分析

#### 9.6变换

#### 9.6.1FFT

#### 9.6.2FHT

#### 9.6.3反FFT

#### 9.6.4反FHT

#### 9.6.5实例——序列FFT

#### 9.7逐点

#### 9.7.1信号生成

#### 9.7.2信号运算

#### 9.7.3滤波器

#### 9.7.4谱分析

#### 9.7.5变换

#### 9.7.6实例——生成STFT时频图

#### 9.7.7线性代数

#### 9.8综合实例——获取回声信号的位置

### 第10章文件管理

#### 10.1文件数据

#### 10.1.1路径

#### 10.1.2文件I/O格式

#### 10.1.3文件操作

#### 10.1.4文件常量

#### 10.1.5实例——格式化写入文件和扫描文件

#### 10.2文件类型

#### 10.2.1文本文件

#### 10.2.2实例——写入余弦数据

#### 10.2.3实例——读取余弦数据

#### 10.2.4带分隔符电子表格文件

#### 10.2.5实例——输出带噪声锯齿波数据

#### 10.2.6实例——读取带Gamma噪声锯齿波数据

#### 10.2.7二进制文件

#### 10.2.8配置文件

#### 10.2.9TDMS

#### 10.2.10存储/数据插件

#### 10.2.11实例——写入TDM数据文件

#### 10.2.12实例——读取TDM文件

#### 10.2.13Zip文件

#### 10.2.14XML格式

#### 10.2.15波形文件I/O函数

#### 10.2.16不错文件函数

#### 10.2.17实例——编辑选中的文件

#### 10.2.18数据记录文件的创建和读取

#### 10.2.19记录前面板数据

#### 10.2.20实例——获取子Ⅵ前面板记录

#### 10.2.21数据与XML格式间的相互转换

#### 10.3综合实例——多路解调器

### 第11章数据采集

#### 11.1数据采集基础

#### 11.1.1DAQ功能概述

#### 11.1.2NI-DAQ安装及节点介绍

#### 11.1.3DAQ节点常用的参数简介

#### 11.2DAQmx节点及其编程

#### 11.3综合实例——DAQ助手的使用

### 第12章通信技术

#### 12.1串行通信技术

#### 12.1.1串行通信介绍

#### 12.1.2ⅥSA配置串口

#### 12.2DataSocket技术

#### 12.2.1DataSocket技术

#### 12.2.2读取DataSocket

#### 12.2.3写入DataSocket

#### 12.2.4打开DataSocket

#### 12.2.5关闭DataSocket

#### 12.2.6实例——正弦信号的远程通信

#### 12.3TCP通信

#### 12.3.1TCP

#### 12.3.2TCP侦听

#### 12.3.3打开TCP连接

#### 12.3.4读取TCP数据

#### 12.3.5写入TCP数据

#### 12.3.6实例——随机波形的局域传递

#### 12.4其他通信方法介绍

#### 12.4.1UDP通信

#### 12.4.2实例——数据的地址传送

#### 12.5综合实例——队列速度的控制

### 第13章综合实例

#### 13.1火车故障检测系统实例

#### 13.2预测成本实例

#### 13.32D图片旋转显示实例

#### 13.4二进制文件的字节顺序实例

## 插件式框架

### Main

#### Log4Net配置

##### log4net.Config.XmlConfigurator.Configure();

#### Log4Net初始化

#### MEF初始化

##### new FABuilder().Load();

### Plugin实现层

#### 服务实现层

##### FACommonService

###### FALoggerService

using Inovance.FA.Plugin.Interfaces;

using Inovance.FA.Plugin.Services;

using log4net;

using System;

using System.Collections.Generic;

using System.ComponentModel.Composition;

using System.Linq;

using System.Reflection;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.FACommonService

{

    [Export(typeof(IFALogger))]

    public class FALoggerService : IFALogger

    {

        ILog logger;

        public FALoggerService()

        {

            logger = log4net.LogManager.GetLogger("RollingLogFileAppender"); 

        }

        public bool IsDebugEnabled => true;

        public bool IsInfoEnabled => true;

        public bool IsWarnEnabled => true;

        public bool IsErrorEnabled => true;

        public bool IsFatalEnabled => true;

        public void Debug(object message)

        {

            logger.Debug(message);

        }

        public void Debug(object message, Exception exception)

        {

            logger.Debug(message, exception);

        }

        public void DebugFormat(string format, params object[] args)

        {

            logger.DebugFormat(format, args);

        }

        public void Error(object message)

        {

            logger.Error(message);

        }

        public void Error(object message, Exception exception)

        {

            logger.Error(message, exception);

        }

        public void ErrorFormat(string format, params object[] args)

        {

            logger.ErrorFormat(format, args);

        }

        public void Fatal(object message)

        {

            logger.Fatal(message);

        }

        public void Fatal(object message, Exception exception)

        {

            logger.Fatal(message, exception);

        }

        public void FatalFormat(string format, params object[] args)

        {

            logger.FatalFormat(format, args);

        }

        public void Info(object message)

        {

            logger.Info(message);

        }

        public void Info(object message, Exception exception)

        {

            logger.Info(message, exception);

        }

        public void InfoFormat(string format, params object[] args)

        {

            logger.InfoFormat(format, args);

        }

        public void Warn(object message)

        {

            logger.Warn(message);

        }

        public void Warn(object message, Exception exception)

        {

            logger.Warn(message, exception);

        }

        public void WarnFormat(string format, params object[] args)

        {

            logger.WarnFormat(format, args);

        }

    }

}

###### FAMessageService

using Inovance.FA.Plugin.Services;

using System;

using System.Collections.Generic;

using System.ComponentModel.Composition;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows;

namespace Inovance.FA.FACommonService

{

    [Export(typeof(IFAMessageBox))]

    public class FAMessageService : IFAMessageBox

    {

        public string Title = "FA";

        public void ShowDebug(string message)

        {

            MessageBox.Show(message, Title, MessageBoxButton.OK, MessageBoxImage.Information);

        }

        public void ShowError(string message, Exception ex=null)

        {

            if (ex == null)

            {

                MessageBox.Show(message, Title, MessageBoxButton.OK, MessageBoxImage.Error);

            }

            else

            {

                MessageBox.Show($"{message}/r/n{ex.ToString()}/r/n{ex.Message}/r/n{ex.StackTrace}/r/n", Title, MessageBoxButton.OK, MessageBoxImage.Error);

            }

            

        }

        public void ShowInfo(string message)

        {

            MessageBox.Show(message, Title, MessageBoxButton.OK, MessageBoxImage.Information);

        }

        public bool ShowQuestion(string message)

        {

            if (MessageBox.Show(message, Title, MessageBoxButton.YesNo, MessageBoxImage.Question) == MessageBoxResult.Yes)

            {

                return true;

            }

            else

            {

                return false;

            }

        }

        public void ShowWarn(string message)

        {

            MessageBox.Show(message, Title, MessageBoxButton.OK, MessageBoxImage.Warning);

        }

    }

}

##### FACommonViews

###### DebugPanel.xaml

<inplug:FAView x:Class="Inovance.FA.FACommonViews.Views.DebugPanel"

             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"

             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"

             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 

             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 

             xmlns:local="clr-namespace:Inovance.FA.FACommonViews.Views"

             xmlns:facontrols="clr-namespace:Inovance.FA.Controls;assembly=FAControls"

             xmlns:localvm="clr-namespace:Inovance.FA.FACommonViews.ViewModels"

             xmlns:inplug="clr-namespace:Inovance.FA.Plugin;assembly=FAPlugin"

             mc:Ignorable="d" 

             d:DesignHeight="300" d:DesignWidth="600" Width="600" Height="300" >

    <!--<inplug:FAView.DataContext>

        <localvm:DebugPanelViewModel/>

    </inplug:FAView.DataContext>-->

    <Grid>

        <Grid.RowDefinitions>

            <RowDefinition Height="30" />

            <RowDefinition Height="*" />

        </Grid.RowDefinitions>

        <Grid.ColumnDefinitions>

            <ColumnDefinition Width="*" />

        </Grid.ColumnDefinitions>

        <Label Content="显示输出来源" HorizontalAlignment="Left" Grid.Row="0" />

        <!--Text="{Binding Message}"-->

        <TextBlock Text="{Binding Message}" HorizontalAlignment="Left" Grid.Row="1"/>

    </Grid>

</inplug:FAView>

###### DebugPanelViewModel

using Inovance.FA.Plugin;

using Inovance.FA.Plugin.Services;

using System;

using System.Collections.Generic;

using System.Collections.ObjectModel;

using System.ComponentModel.Composition;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.FACommonViews.ViewModels

{

    [Export(typeof(IDebugOut))]

    [Export(typeof(FAViewModel))]

    public class DebugPanelViewModel : FAViewModel, IDebugOut

    {

        public string message = "请输入";

        public string Message

        {

            get

            {

                return message;

            }

            set

            {

                message = value;

                RaisePropertyChanged("Message");

            }

        }

        public void Debug(string Message)

        {

            this.Message= Message;

        }

    }

}

###### DebugPanel.Xaml.cs

using Inovance.FA.Controls;

using Inovance.FA.Plugin;

using System;

using System.Collections.Generic;

using System.ComponentModel.Composition;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows;

using System.Windows.Controls;

using System.Windows.Data;

using System.Windows.Documents;

using System.Windows.Input;

using System.Windows.Media;

using System.Windows.Media.Imaging;

using System.Windows.Navigation;

using System.Windows.Shapes;

namespace Inovance.FA.FACommonViews.Views

{

    [Export(typeof(FAView))]

    /// <summary>

    /// SelectDevices.xaml 的交互逻辑

    /// </summary>

    public partial class DebugPanel:FAView

    {

        public DebugPanel():base("DebugPanelViewModel")

        {

            InitializeComponent();

        }

    }

}

#### 插件实现层

##### MyFAPlugin1

###### MyFAPlugin1

using Inovance.FA.Plugin;

using Inovance.FA.Plugin.Services;

using System;

using System.Collections.Generic;

using System.ComponentModel.Composition;

using System.Linq;

using System.Text;

using System.Threading;

using System.Threading.Tasks;

namespace Inovance.FA.MyFAPlugin1

{

    [Export(typeof(FAPluginBase))]

    public class MyFAPlugin1 : FAPluginBase

    {

        //IFALogger FALogger { get; set; }

        [ImportingConstructor]

        public MyFAPlugin1() //IFALogger logger

        {

            this.ID = "MyFAPlugin1";

            this.Name = "MyFAPlugin1";

            this.Categorys = new List<FACategory>();

            ///FALogger = logger;

        }

        public override void Init()

        {

            base.Init();

            

            this.MessageReceived += MyFAPlugin1_MessageReceived;

            //FAMessageBox.ShowInfo("MyFAPlugin1.Init()-MyFAPlugin1 inited!");

            this.PluginInited += MyFAPlugin1_PluginInited;

        }

        private void MyFAPlugin1_PluginInited(object sender, EventArgs e)

        {

            ThreadPool.QueueUserWorkItem(o =>

            {

                Thread.Sleep(10000);

                while (true)

                {

                    SendMessage("MyFAPlugin2", "string", Encoding.UTF8.GetBytes("This is a test message from MyFAPlugin1 !"));

                    Thread.Sleep(100);

                };

            });

            FALogger.Info("MyFAPlugin1 inited! This message is from MYFAPlugin1.dll");

            //FADebugOut.Debug("MyFAPlugin1 inited! This message is from MYFAPlugin1.dll");

        }

        private void MyFAPlugin1_MessageReceived(object sender, Plugin.Args.MessageReceivedEventArgs e)

        {

            FALogger.Info($"MyFAPlugin1.MyFAPlugin1_MessageReceived()-Message from【{e.SenderID}】 type:{e.DataType} content:{Encoding.Default.GetString(e.Data)}");

            //FAMessageBox.ShowInfo($"MyFAPlugin1.MyFAPlugin1_MessageReceived()-Message from【{e.SenderID}】 type:{e.DataType} content:{e.Data.ToString()}");

            //FADebugOut.Debug($"MyFAPlugin1.MyFAPlugin1_MessageReceived()-Message from【{e.SenderID}】 type:{e.DataType} content:{Encoding.Default.GetString(e.Data)}");

        }

    }

}

##### MyFAPlugin2

###### MyFAPlugin2

using Inovance.FA.Plugin;

using System;

using System.Collections.Generic;

using System.ComponentModel.Composition;

using System.Linq;

using System.Text;

using System.Threading;

using System.Threading.Tasks;

namespace Inovance.FA.MyFAPlugin2

{

    [Export(typeof(FAPluginBase))]

    public class MyFAPlugin2 : FAPluginBase

    {

        public MyFAPlugin2()

        {

            this.ID = "MyFAPlugin2";

            this.Name = "MyFAPlugin2";

        }

        public override void Init()

        {

            base.Init();

            this.MessageReceived += MyFAPlugin2_MessageReceived;

            try

            {

                throw new Exception("This is a test exception!");

            }

            catch(Exception ex)

            {

                FALogger.Error("MyFAPlugin2.Init()-There is an error", ex);

                //FADebugOut.Debug("MyFAPlugin2.Init()-There is an error:"+ex.Message);

            }

            this.PluginInited += MyFAPlugin2_PluginInited;

        }

        private void MyFAPlugin2_PluginInited(object sender, EventArgs e)

        {

            ThreadPool.QueueUserWorkItem(o =>

            {

                Thread.Sleep(10000);

                while (true)

                {

                    SendMessage("MyFAPlugin1", "string", Encoding.UTF8.GetBytes("This is a test message from MyFAPlugin2 !"));

                    Thread.Sleep(100);

                };

            });

        }

        private void MyFAPlugin2_MessageReceived(object sender, Plugin.Args.MessageReceivedEventArgs e)

        {

            FALogger.Info($"MyFAPlugin2.MyFAPlugin2_MessageReceived()-Message from【{e.SenderID}】 type:{e.DataType} content:{Encoding.Default.GetString(e.Data)}");

            //FAMessageBox.ShowInfo($"MyFAPlugin2.MyFAPlugin2_MessageReceived()-Message from【{e.SenderID}】 type:{e.DataType} content:{e.Data.ToString()}");

            //FADebugOut.Debug($"MyFAPlugin2.MyFAPlugin2_MessageReceived()-Message from【{e.SenderID}】 type:{e.DataType} content:{Encoding.Default.GetString(e.Data)}");

        }

    }

}

#### FAStaticData

using System;

using System.Collections.Generic;

using System.ComponentModel.Composition;

using System.ComponentModel.Composition.Hosting;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.Plugin

{

    public class FAStaticData

    {

        public static CompositionContainer Container = null;

        //[ImportMany(typeof(FAView))]

        ////private IEnumerable<Lazy<View, IViewMetadata>> views { get; set; }

        //public static IEnumerable<FAView> Views { get; set; }

    }

}

### Controls

#### Conveter

##### ProjectVisableConverter

using Inovance.FA.Plugin;

using System;

using System.Collections.Generic;

using System.Globalization;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows;

using System.Windows.Data;

namespace Inovance.FA.Controls.Conveter

{

    [ValueConversion(typeof(FAProject), typeof(Visibility))]

    public class ProjectVisableConverter : IValueConverter

    {

        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)

        {

            if (value!=null&&value is FAProject)

            {

                return Visibility.Visible;

            }

            else

            {

                return Visibility.Collapsed;

            }

        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)

        {

            throw new NotImplementedException();

        }

    }

}

#### DialogCloser

using System;

using System.Collections.Generic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows;

namespace Inovance.FA.Controls

{

    public static class DialogCloser

    {

        public static readonly DependencyProperty DialogResultProperty =

            DependencyProperty.RegisterAttached("DialogResult",

                                                typeof(bool?),

                                                typeof(DialogCloser),

                                                new PropertyMetadata(DialogResultChanged));

        private static void DialogResultChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)

        {

            var window = d as Window;

            if (window != null)

            {

                window.DialogResult = e.NewValue as bool?;

            }

        }

        public static void SetDialogResult(Window target, bool? value)

        {

            target.SetValue(DialogResultProperty, value);

        }

    }

}

#### FADialog

using System;

using System.Collections.Generic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows;

using System.Windows.Data;

namespace Inovance.FA.Controls

{

    public class FADialog : FAWindow

    {

        public FADialog()

        {

            this.WindowStyle = WindowStyle.ToolWindow;

            this.WindowStartupLocation = WindowStartupLocation.CenterScreen;

        }

    }

}

#### FAWindow

using System;

using System.Collections.Generic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows;

using System.Windows.Data;

namespace Inovance.FA.Controls

{

    public class FAWindow:Window

    {

        public FAWindow()

        {

            Binding binding = new Binding();

            //binding.Source = DialogCloser.DialogResultProperty;

            binding.Path = new PropertyPath("DialogResult");

            binding.Mode = BindingMode.TwoWay;

            this.SetBinding(DialogCloser.DialogResultProperty, binding);

        }

    }

}

### Plugin接口层

#### Plugin插件模型接口层

##### FAPluginBase

using Inovance.FA.Plugin.Args;

using Inovance.FA.Plugin.Services;

using System;

using System.Collections.Generic;

using System.ComponentModel.Composition;

using System.Threading;

namespace Inovance.FA.Plugin

{

    public class FAPluginBase:FAObject

    {

        public FAPluginBase()

        {

            

        }

        public bool Inited { get; set; } = false;

        public List<FACategory> Categorys { get; set; }

        public FAEquipmentType EquipmentType { get; set; }

        [Import]

        public IFALogger FALogger { get; set; }

        [Import]

        public IFAMessageBox FAMessageBox { get; set; }

        //[Import]

        //public IDebugOut FADebugOut { get; set; }

        public virtual void Init()

        {

            ThreadPool.QueueUserWorkItem(o => {

                while (!Inited)

                {

                    Thread.Sleep(100);

                }

                FALogger.Info($"FAPluginBase.Init()-{this.ToString()} Inited!");

                //FADebugOut.Debug($"FAPluginBase.Init()-{this.ToString()} Inited!");

                if (PluginInited != null)

                {

                    PluginInited(this, new EventArgs());

                }

            });

        }

        public void SendMessage(string ReceiverID,string DataType, byte[] Data)

        {

            if (MessageSend != null)

            {

                MessageSend(this, new MessageReceivedEventArgs { Data = Data,DataType=DataType, SenderID = this.ID ,ReceiverID=ReceiverID});

            }

        }

        public void RaiseMessageReceived(MessageReceivedEventArgs e)

        {

            if (MessageReceived != null)

            {

                MessageReceived(this, e);

            }

        }

        public event EventHandler<EventArgs> PluginInited;

        public event EventHandler<MessageReceivedEventArgs> MessageSend;

        public event EventHandler<MessageReceivedEventArgs> MessageReceived;

    }

}

##### FAView

using System;

using System.Collections.Generic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows;

using System.Windows.Controls;

namespace Inovance.FA.Plugin

{

    public class FAView:UserControl

    {

        public FAView(string ViewModelName)

        {

            if(!string.IsNullOrEmpty(ViewModelName))

            {

                DataContext = FAStaticData.Container.GetExportedValues<FAViewModel>().FirstOrDefault(v => v.Name.Equals(ViewModelName));

            }

        }

        public bool IsReadOnly { get; set; }

    }

}

##### FAViewModel

using Inovance.FA.Plugin.Services;

using System;

using System.Collections.Generic;

using System.ComponentModel;

using System.ComponentModel.Composition;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.Plugin

{

    public abstract class FAViewModel:INotifyPropertyChanged

    {

        public IFALogger FALogger { get; set; }

        public IFAMessageBox FAMessageBox { get; set; }

        public FAViewModel()

        {

            FALogger = FAStaticData.Container.GetExportedValue<IFALogger>();

            FAMessageBox = FAStaticData.Container.GetExportedValue<IFAMessageBox>();

        }

        public string Name

        {

            get

            {

                return this.GetType().Name;

            }

        }

        private FAProject project = null;

        public FAProject Project

        {

            get

            {

                return project;

            }

            set

            {

                project = value;

                RaisePropertyChanged("Project");

            }

        }

        public bool? dialogResult;

        public bool? DialogResult

        {

            get

            {

                return dialogResult;

            }

            set

            {

                dialogResult = value;

                RaisePropertyChanged("DialogResult");

            }

        }

        protected virtual void RaisePropertyChanged(string propertyName)

		{

			if (PropertyChanged != null)

				PropertyChanged(this, new PropertyChangedEventArgs(propertyName));

		}

		public event PropertyChangedEventHandler PropertyChanged;

	}

}

#### 服务接口层

##### IDebugOut

using System;

using System.Collections.Generic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.Plugin.Services

{

    public interface IDebugOut

    {

        void Debug(string Message);

    }

}

##### IFALogger

using Inovance.FA.Plugin.Interfaces;

using System;

using System.Collections.Generic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.Plugin.Services

{

    public interface IFALogger: IFAService

	{

		void Debug(object message);

		void Debug(object message, Exception exception);

		void DebugFormat(string format, params object[] args);

		void Info(object message);

		void Info(object message, Exception exception);

		void InfoFormat(string format, params object[] args);

		void Warn(object message);

		void Warn(object message, Exception exception);

		void WarnFormat(string format, params object[] args);

		void Error(object message);

		void Error(object message, Exception exception);

		void ErrorFormat(string format, params object[] args);

		void Fatal(object message);

		void Fatal(object message, Exception exception);

		void FatalFormat(string format, params object[] args);

		bool IsDebugEnabled { get; }

		bool IsInfoEnabled { get; }

		bool IsWarnEnabled { get; }

		bool IsErrorEnabled { get; }

		bool IsFatalEnabled { get; }

	}

}

##### IFAMessageBox

using System;

namespace Inovance.FA.Plugin.Services

{

    public interface IFAMessageBox 

    {

        void ShowInfo(string message);

        void ShowError(string message,Exception ex);

        void ShowDebug(string message);

        void ShowWarn(string message);

        bool ShowQuestion(string message);

    }

}

#### Plugin插件模型接口层

##### MessageReceivedEventArgs

using System;

using System.Collections.Generic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.Plugin.Args

{

    public class MessageReceivedEventArgs:EventArgs

    {

        public string SenderID { get; set; }

        public string ReceiverID { get; set; }

        public string DataType { get; set; }

        public byte[] Data

        {

            get; set;

        }

    }

}

### Core

#### FABuilder

using Inovance.FA.Plugin;

using Inovance.FA.Plugin.Services;

using System;

using System.Collections.Generic;

using System.ComponentModel.Composition;

using System.ComponentModel.Composition.Hosting;

using System.IO;

using System.Linq;

using System.Text;

using System.Threading;

using System.Threading.Tasks;

namespace Inovance.FA.Core

{

    

    public class FABuilder

    {

        [ImportMany(typeof(FAPluginBase))]

        public static IEnumerable<FAPluginBase> Plugins { get; private set; }

        //[ImportMany(typeof(FAView))]

        ////private IEnumerable<Lazy<View, IViewMetadata>> views { get; set; }

        //public static IEnumerable<FAView> Views { get; private set; }

        [Import(typeof(IFALogger))]

        public IFALogger logger { get; set; }

        //private CompositionContainer container = null;

        public void Load()

        {

            var catalog = new DirectoryCatalog(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins"), "*");

            FAStaticData.Container = new CompositionContainer(catalog);

            try

            {

                Plugins = FAStaticData.Container.GetExportedValues<FAPluginBase>();

                foreach (var plugin in Plugins)

                {

                    plugin.Init();

                    plugin.Inited = true;

                    plugin.MessageSend += Plugin_MessageSend;

                }

            }

            catch (CompositionException compositionEx)

            {

                logger.Error("FABuilder.Load Plugins Failed!", compositionEx);

            }

            //try

            //{

            //    FAStaticData.Views = FAStaticData.Container.GetExportedValues<FAView>();

            //}

            //catch (CompositionException compositionEx)

            //{

            //    logger.Error("FABuilder.Load Views Failed!", compositionEx);

            //}

            

        }

        private void Plugin_MessageSend(object sender, Plugin.Args.MessageReceivedEventArgs e)

        {

            if (e != null && !String.IsNullOrEmpty(e.ReceiverID))

            {

                var plugin = Plugins.Where(p => p.ID == e.ReceiverID).FirstOrDefault();

                ThreadPool.QueueUserWorkItem(o => {

                    if (plugin != null)

                    {

                        while (!plugin.Inited)

                        {

                            Thread.Sleep(100);

                        }

                        plugin.RaiseMessageReceived(e);

                    }

                });

                

            }

        }

    }

}

### Viwes

#### CreateProject

##### Xaml

<facontrols:FADialog x:Class="Inovance.FA.Views.Views.CreateProject"

             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"

             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"

             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 

             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 

             xmlns:local="clr-namespace:Inovance.FA.Views.Views"

             xmlns:facontrols="clr-namespace:Inovance.FA.Controls;assembly=FAControls"

             xmlns:localvm="clr-namespace:Inovance.FA.Views.ViewModels"

             mc:Ignorable="d" 

             d:DesignHeight="300" d:DesignWidth="600" Width="600" Height="300" >

    <Window.DataContext>

        <localvm:CreateProjectViewModel/>

    </Window.DataContext>

    <Grid>

        <Grid.RowDefinitions>

            <RowDefinition Height="*" />

            <RowDefinition Height="30" />

            <RowDefinition Height="30" />

            <RowDefinition Height="30" />

            <RowDefinition Height="60" />

            <RowDefinition Height="30" />

            <RowDefinition Height="*" />

        </Grid.RowDefinitions>

        <Grid.ColumnDefinitions>

            <ColumnDefinition Width="*" />

            <ColumnDefinition Width="200" />

            <ColumnDefinition Width="300" />

            <ColumnDefinition Width="*" />

        </Grid.ColumnDefinitions>

        <Label Content="项目名称：" Grid.Row="1" Grid.Column="1" />

        <Label Content="路径：" Grid.Row="2" Grid.Column="1" />

        <Label Content="作者" Grid.Row="3" Grid.Column="1" />

        <Label Content="备注" Grid.Row="4" Grid.Column="1" />

        <Button Content="创建" Grid.Row="5" Grid.Column="2" Command="{Binding CreateProjectCommand}"/>

        <TextBox Text="{Binding Project.Name, Mode=TwoWay}" Grid.Row="1" Grid.Column="2" />

        <TextBox Text="{Binding Project.BasePath, Mode=TwoWay}"  Grid.Row="2" Grid.Column="2" />

        <TextBox Text="{Binding Project.Author, Mode=TwoWay}"  Grid.Row="3" Grid.Column="2" />

        <TextBox Text="{Binding Project.Description, Mode=TwoWay}" Grid.Row="4" Grid.Column="2" />

    </Grid>

</facontrols:FADialog>

##### ViewModel

using Inovance.FA.Plugin;

using System;

using System.Collections.Generic;

using System.Collections.ObjectModel;

using System.IO;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.Views.ViewModels

{

    public class CreateProjectViewModel : FAViewModel

    {

        public FACommand CreateProjectCommand

        {

            get;

            set;

        }

        public CreateProjectViewModel()

        {

            Project = new FAProject(LanguageResource.Resource.DefaultProjectName);

            Project.BasePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),"FAProject", Project.Name);

            Project.Author = Environment.UserName;

            Project.Description = LanguageResource.Resource.DefaultProjectDescrption;

            CreateProjectCommand = new FACommand(o => {

                RaisePropertyChanged("Project");

                this.DialogResult = true;

                FAMessageBox.ShowInfo($"[{Project.Author}]创建项目[{Project.Name}]成功！");

                FALogger.Info($"创建项目[{Project.Name}]成功！");

            });

        }

    }

}

#### MainWindow

##### Xaml

<facontrols:FAWindow x:Class="Inovance.FA.Views.Views.MainWindow"

        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"

        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"

        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"

        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"

        xmlns:local="clr-namespace:Inovance.FA.Views"

        xmlns:inplug="clr-namespace:Inovance.FA.Plugin;assembly=FAPlugin"

        xmlns:facontrols="clr-namespace:Inovance.FA.Controls;assembly=FAControls"

        xmlns:lanrs="clr-namespace:Inovance.FA.LanguageResource;assembly=LanguageResource"

        xmlns:localvm="clr-namespace:Inovance.FA.Views.ViewModels"

        xmlns:facvt="clr-namespace:Inovance.FA.Controls.Conveter;assembly=FAControls"

        xmlns:avalon="https://github.com/Dirkster99/AvalonDock"

        mc:Ignorable="d"

        Title ="{x:Static lanrs:Resource.AppTitle}" WindowState="Maximized"  Margin="3" Height="450" Width="800">

    <Window.DataContext>

        <localvm:MainWindowViewModel/>

    </Window.DataContext>

    <Window.Resources>

        <facvt:ProjectVisableConverter x:Key="ProjectVisableConverter"/>

        <local:ViewLocator x:Key="InViewLocator"/>

    </Window.Resources>

    <Grid>

        <Grid.RowDefinitions>

            <RowDefinition Height="Auto" />

            <RowDefinition Height="Auto" />

            <RowDefinition Height="*" />

            <RowDefinition Height="Auto" />

        </Grid.RowDefinitions>

        <Menu Grid.Row="0">

            <MenuItem Header="项目(_P)" >

                <MenuItem  Header="新建(_N)" Command="{Binding CreateProjectCommand}" CommandParameter="新项目">

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="打开(_O)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="移植项目(_M)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="关闭(_C)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="删除项目(_D)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <Separator/>

                <MenuItem  Header="保存(_S)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="另存为(_A)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="归档(_H)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <Separator/>

                <MenuItem  Header="项目服务器(_H)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                    <MenuItem  Header="管理项目服务器" >

                    </MenuItem>

                    <MenuItem  Header="离线运行" >

                        <MenuItem.Icon>

                            <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                        </MenuItem.Icon>

                    </MenuItem>

                </MenuItem>

                <Separator/>

                <MenuItem  Header="读卡器/USB存储器" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="存储卡文件(_F)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <Separator/>

                <MenuItem  Header="启动完整性基本检查" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <Separator/>

                <MenuItem  Header="推出(_X)" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

            </MenuItem>

            <MenuItem Header="编辑(_E)">

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

            </MenuItem>

            <MenuItem Header="视图(_V)">

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

            </MenuItem>

            <MenuItem Header="插入(_I)">

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

            </MenuItem>

            <MenuItem Header="在线(_O)">

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

            </MenuItem>

            <MenuItem Header="选项(_N)">

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

            </MenuItem>

            <MenuItem Header="工具(_T)">

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

            </MenuItem>

            <MenuItem Header="窗口(_W)">

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="子菜单1" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

            </MenuItem>

            <MenuItem Header="帮助(_H)">

                <MenuItem  Header="显示帮助" >

                    <MenuItem.Icon>

                        <Image Source="/FAViews;Component/Images/Menu/Box.png" />

                    </MenuItem.Icon>

                </MenuItem>

                <MenuItem  Header="Internet上得服务帮助与支持" />

                <MenuItem  Header="FA中的帮助与支持(_T) Ctrl+Shift+F7" />

                <Separator />

                <MenuItem  Header="已安装的产品(_I)..." />

            </MenuItem>

        </Menu>

        <ToolBarTray Grid.Row="1" Background="White">

            <ToolBar Band="1" BandIndex="1" >

                <Button >

                    <Image Source="/FAViews;Component/Images/ToolBar/BlueLarge.png" />

                </Button>

                <Button>

                    <Image Source="/FAViews;Component/Images/ToolBar/BlueLarge.png" />

                </Button>

                <Button>

                    <Image Source="/FAViews;Component/Images/ToolBar/BlueLarge.png" />

                </Button>

            </ToolBar>

            <ToolBar Band="1" BandIndex="2">

                <Button>

                    <Image Source="/FAViews;Component/Images/ToolBar/BlueLarge.png" />

                </Button>

                <Button>

                    <Image Source="/FAViews;Component/Images/ToolBar/BlueLarge.png" />

                </Button>

            </ToolBar>

            <ToolBar Band="1" BandIndex="3">

                <Button>

                    <Image Source="/FAViews;Component/Images/ToolBar/BlueLarge.png" />

                </Button>

                <Button ToolTip="Help">

                    <Image Source="/FAViews;Component/Images/ToolBar/BlueLarge.png" />

                </Button>

                <Separator/>

            </ToolBar>

        </ToolBarTray>

        <!--<DockPanel Grid.Row="1" Background="LightBlue" >

            <TextBlock DockPanel.Dock="Top" Text="Hello!"/>

        </DockPanel>-->

        <Grid Grid.Row="2" Background="LightBlue" >

            <Grid.RowDefinitions>

                <RowDefinition Height="0"/>

                <RowDefinition Height="*"/>

                <RowDefinition Height="24"/>

            </Grid.RowDefinitions>

            <!--<Menu>

                <MenuItem Header="File">

                    <MenuItem Header="New Document" Click="NewDocument_Click"  Name="NewDocument"/>

                    <MenuItem Header="Exit"/>

                </MenuItem>

            </Menu>-->

            <DockingManager x:Name="dockManager"

            Grid.Row="1"

            AllowMixedOrientation="True"

            AutoWindowSizeWhenOpened="True"

            IsVirtualizingAnchorable="True"

            IsVirtualizingDocument="True">

                <DockingManager.DocumentHeaderTemplate>

                    <DataTemplate>

                        <StackPanel Orientation="Horizontal">

                            <Image Margin="0,0,4,0" Source="{Binding IconSource}" />

                            <TextBlock Text="{Binding Title}" TextTrimming="CharacterEllipsis" />

                        </StackPanel>

                    </DataTemplate>

                </DockingManager.DocumentHeaderTemplate>

                <LayoutRoot>

                    <LayoutPanel Orientation="Horizontal">

                        <LayoutAnchorablePane DockWidth="150">

                            <LayoutAnchorable x:Name="WinFormsWindow"

                            Title="项目树"

                            CanClose="False"

                            CanHide="False"

                            ContentId="WinFormsWindow"

                            ToolTip="My WinForms Tool">

                                <TreeView>

                                    <TreeViewItem Header="{Binding Project.Name}" ToolTip="{Binding Project.Description}" Visibility="{Binding Project,Converter={StaticResource ProjectVisableConverter},Mode=OneWay}"/>

                                    <TreeViewItem Header="在线访问"/>

                                    <TreeViewItem Header="读卡器/本地USB存储器"/>

                                </TreeView>

                            </LayoutAnchorable>

                        </LayoutAnchorablePane>

                        <LayoutDocumentPaneGroup>

                            <LayoutDocumentPane

                                x:Name="LayoutDocumentPane">

                                <!--ContentId="document1"-->

                                <LayoutDocument

                                CanClose="False"

                                Title="欢迎页面"

                                >

                                    <Grid>

                                        <Grid.ColumnDefinitions>

                                            <ColumnDefinition Width="10"/>

                                            <ColumnDefinition Width="120"/>

                                            <ColumnDefinition Width="*"/>

                                        </Grid.ColumnDefinitions>

                                        <Grid.RowDefinitions>

                                            <RowDefinition Height="Auto" />

                                            <RowDefinition Height="Auto" />

                                            <RowDefinition Height="Auto" />

                                            <RowDefinition Height="Auto" />

                                            <RowDefinition Height="Auto" />

                                        </Grid.RowDefinitions>

                                        <Button

                                            Grid.Row="0"

                                            Grid.Column="1"

                                            Height="28"

                                            VerticalAlignment="Top"

                                            Command="{Binding TestCommand}" 

                                            CommandParameter="Hai" 

                                            Content="Test Button 1" />

                                        <Button

                                            Grid.Row="1"

                                            Grid.Column="1"

                                            Height="28"

                                            VerticalAlignment="Top"

                                            Command="{Binding TestCommand}" 

                                            Content="Test Button 2" />

                                        <Button

                                            Grid.Row="2"

                                            Grid.Column="1"

                                            Height="28"

                                            VerticalAlignment="Top"

                                            Command="{Binding TestCommand}" 

                                            CommandParameter="{Binding ElementName=tbValue,Path=Text}"

                                            Content="Test Button 3" />

                                        <TextBox 

                                            x:Name="tbValue" 

                                            Grid.Row="5" 

                                            Grid.Column="1"

                                            Text="Document 1 Content" />

                                    </Grid>

                                </LayoutDocument>

                                <LayoutDocument Title="文档2" ContentId="document2">

                                    <TextBox

                                    Background="Transparent"

                                    BorderThickness="0"

                                    Foreground="White"

                                    Text="{Binding TestTimer, Mode=OneWay, StringFormat='Document 2 Attached to Timer ->\{0\}'}" />

                                </LayoutDocument>

                                <LayoutDocument Title="依赖注入测试" ContentId="document2">

                                    <Grid>

                                        <Grid.RowDefinitions>

                                            <RowDefinition Height="*"/>

                                            <RowDefinition Height="30"/>

                                            <RowDefinition Height="30"/>

                                            <RowDefinition Height="30"/>

                                            <RowDefinition Height="*"/>

                                        </Grid.RowDefinitions>

                                        <Grid.ColumnDefinitions>

                                            <ColumnDefinition Width="*"/>

                                            <ColumnDefinition Width="200"/>

                                            <ColumnDefinition Width="200"/>

                                            <ColumnDefinition Width="200"/>

                                            <ColumnDefinition Width="200"/>

                                            <ColumnDefinition Width="*"/>

                                        </Grid.ColumnDefinitions>

                                        <Label  Grid.Row="1" Grid.Column="1" Content="数值1"/>

                                        <TextBox  Grid.Row="1" Grid.Column="2" />

                                        <Label  Grid.Row="1" Grid.Column="3" Content="数值2"/>

                                        <TextBox  Grid.Row="1" Grid.Column="4" />

                                        <Button Margin="3"  Grid.Row="2" Grid.Column="1"  Content="{x:Static lanrs:Resource.Button1}" />

                                        <Button Padding="5"  Grid.Row="2" Grid.Column="2" Content="{x:Static lanrs:Resource.Button2}"/>

                                        <Button  Grid.Row="2" Grid.Column="3" Content="{x:Static lanrs:Resource.Button3}"/>

                                        <Button  Grid.Row="2" Grid.Column="4" Content="{x:Static lanrs:Resource.Button4}"/>

                                        <Button Margin="3"  Grid.Row="3" Grid.Column="1"  Content="测试"/>

                                        <Button Padding="5"  Grid.Row="3" Grid.Column="2" Content=""/>

                                        <Button  Grid.Row="3" Grid.Column="3" Content=""/>

                                        <Button  Grid.Row="3" Grid.Column="4" Content=""/>

                                    </Grid>

                                </LayoutDocument>

                            </LayoutDocumentPane>

                        </LayoutDocumentPaneGroup>

                        <LayoutAnchorablePaneGroup DockWidth="150">

                            <LayoutAnchorablePane>

                                <LayoutAnchorable

                                Title="属性"

                                ContentId="toolWindow1"

                                CanHide="False">

                                    <StackPanel MinHeight="450">

                                        <TextBox Text="{Binding TestTimer, Mode=OneWay, StringFormat='Tool Window 1 Attached to Timer ->\{0\}'}" />

                                    </StackPanel>

                                </LayoutAnchorable>

                                <LayoutAnchorable

                                    Title="查找替换" 

                                    CanClose="False"

                                    CanHide="False"

                                    ContentId="toolWindow2">

                                    <TextBlock Text="{Binding FocusedElement}" />

                                </LayoutAnchorable>

                            </LayoutAnchorablePane>

                        </LayoutAnchorablePaneGroup>

                    </LayoutPanel>

                    <LayoutRoot.LeftSide>

                        <LayoutAnchorSide >

                            <LayoutAnchorGroup >

                                <LayoutAnchorable

                                Title="设备"

                                ContentId="AutoHide1Content"

                                IconSource="/FAViews;Component/Images/Blue.png" AutoHideWidth="150">

                                    <TextBox Text="{Binding TestTimer, Mode=OneWay, StringFormat='AutoHide Attached to Timer ->\{0\}'}" />

                                </LayoutAnchorable>

                                <LayoutAnchorable Title="文件" ContentId="AutoHide2Content" AutoHideWidth="150">

                                    <StackPanel Orientation="Vertical">

                                        <TextBox />

                                        <TextBox />

                                    </StackPanel>

                                </LayoutAnchorable>

                            </LayoutAnchorGroup>

                        </LayoutAnchorSide>

                    </LayoutRoot.LeftSide>

                    <LayoutRoot.BottomSide>

                        <LayoutAnchorSide>

                            <LayoutAnchorGroup>

                                <LayoutAnchorable

								FloatingHeight="200"

                                Title="调试"

                                CanClose="False"

                                CanHide="False"

                                ContentId="AutoHide1Content"

                                IconSource="/FAViews;Component/Images/Blue.png">

                                    <TextBox Text="{Binding TestTimer, Mode=OneWay, StringFormat='AutoHide Attached to Timer ->\{0\}'}" />

                                </LayoutAnchorable>

                                <LayoutAnchorable 

                                    Title="输出" 

                                    FloatingHeight="200" 

                                    ContentId="AutoHide2Content"

                                    CanClose="False"

                                    CanHide="False">

                                    <ContentControl Content="{Binding DebugPanel, Source={StaticResource InViewLocator}}"/>

                                </LayoutAnchorable>

                            </LayoutAnchorGroup>

                        </LayoutAnchorSide>

                    </LayoutRoot.BottomSide>

                </LayoutRoot>

            </DockingManager>

            <StatusBar Grid.Row="2">

                <StatusBarItem Content="Inovance FA"/>

            </StatusBar>

        </Grid>

    </Grid>

</facontrols:FAWindow>

##### ViewModel

using Inovance.FA.Core;

using Inovance.FA.Plugin;

using Inovance.FA.Plugin.Services;

using Inovance.FA.Views.Views;

using System;

using System.Collections.Generic;

using System.Collections.ObjectModel;

using System.ComponentModel.Composition;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows;

using System.Windows.Input;

namespace Inovance.FA.Views.ViewModels

{

    public class MainWindowViewModel : FAViewModel

    {

        //[Import]

        //public static ViewLocator Locator;

        public FACommand TestCommand

        {

            get;

            set;

        }

        public FACommand SelectDevicesCommand

        {

            get;

            set;

        }

        public FACommand CreateProjectCommand

        {

            get;

            set;

        }

        public MainWindowViewModel()

        {

            

            TestCommand = new FACommand(ShowMessage);

            SelectDevicesCommand = new FACommand(SelectDevices);

            CreateProjectCommand = new FACommand((o) => {

                

                //Project = new FAProject(o.ToString());

                CreateProject CreateProjectWindow = new CreateProject();

                if (CreateProjectWindow.ShowDialog() == true)

                {

                    Project = (CreateProjectWindow.DataContext as CreateProjectViewModel).Project;

                    FAStaticData.Container.GetExportedValue<IDebugOut>().Debug($"{Project.Author}创建了项目：{Project.Name} ！");

                }

            });

           

        }

        public void ShowMessage(object obj)       //消息 方法

        {

            if (obj != null)

            {

                MessageBox.Show(obj.ToString());

            }

            else

            {

                MessageBox.Show("obj is null");

            }

        }

        public void SelectDevices(object obj)       //消息 方法

        {

            SelectDevices selectDevices = new SelectDevices();

            var items = new ObservableCollection<string>((from p in FABuilder.Plugins select p.Name).ToList());

            (selectDevices.DataContext as SelectDevicesViewModel).FACategorys = items;

            selectDevices.ShowDialog();

        }

    }

}

#### SelectDevices

##### Xaml

<facontrols:FAWindow x:Class="Inovance.FA.Views.Views.SelectDevices"

             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"

             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"

             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 

             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 

             xmlns:local="clr-namespace:Inovance.FA.Views.Views"

             xmlns:facontrols="clr-namespace:Inovance.FA.Controls;assembly=FAControls"

             xmlns:localvm="clr-namespace:Inovance.FA.Views.ViewModels"

             mc:Ignorable="d" 

             d:DesignHeight="450" d:DesignWidth="800">

    <Window.DataContext>

        <localvm:SelectDevicesViewModel/>

    </Window.DataContext>

    <Grid>

        <Grid.RowDefinitions>

            <RowDefinition Height="*" />

            <RowDefinition Height="30" />

        </Grid.RowDefinitions>

        <ListView Name="lst" Grid.Row="0"  ItemsSource ="{Binding FACategorys}"/>

        <Button Grid.Row="1" Click="Button_Click"/>

    </Grid>

</facontrols:FAWindow>

##### ViewModel

using Inovance.FA.Plugin;

using System;

using System.Collections.Generic;

using System.Collections.ObjectModel;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.Views.ViewModels

{

    public class SelectDevicesViewModel:FAViewModel

    {

        public ObservableCollection<string> faCategorys = null;

        public ObservableCollection<string> FACategorys {

            get {

                return faCategorys;

            }

            set {

                faCategorys = value;

                RaisePropertyChanged("FACategorys");

            }

        }

	}

}

#### ViewLocator

using Inovance.FA.Plugin;

using Inovance.FA.Plugin.Services;

using System;

using System.Collections.Generic;

using System.ComponentModel.Composition;

using System.Dynamic;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

namespace Inovance.FA.Views

{

    //[Export(typeof(ViewLocator))]

    public class ViewLocator : DynamicObject, IPartImportsSatisfiedNotification

    {

        //[ImportMany(typeof(FAView))]

        ////private IEnumerable<Lazy<View, IViewMetadata>> views { get; set; }

        //public static IEnumerable<FAView> Views { get; set; }

        public IFALogger FALogger { get {

                return FAStaticData.Container.GetExportedValue<IFALogger>();

            } }

        public override bool TryGetMember(GetMemberBinder binder, out object result)

        {

            string name = binder.Name;

            var views = FAStaticData.Container.GetExportedValues<FAView>();

            if (views == null)

            {

                result = null;

                return false;

            }

            var view = views.FirstOrDefault(v => v.GetType().Name.Equals(name));

            // Error handling

            if (null == view)

                FALogger.Error("views is null at TryGetMember");

            result = view;

            return null != result;

        }

        public void OnImportsSatisfied()

        {

            FALogger.Info($"{this.GetType()} Composition complete");

        }

    }

}

### 外部包依赖

#### Dirkster.AvalonDock

##### Dirkster.AvalonDock.Themes.VS2013

#### Fluent.Ribbon

#### log4net

#### MEF

##### System.ComponentModel.Composition

#### Dirkster.AvalonDock

#### log4net

### LanguageResource实现多语言支持

## 数据结构与算法

### 数据结构

#### 逻辑结构

##### 集合结构

##### 线性结构

##### 树形结构

##### 图形结构

#### 线性结构

##### 顺序存储结构

##### 链式存储结构

### 算法

#### 算法复杂度

（O(n)渐进表示法）

##### 时间复杂度

##### 空间复杂度

#### ***章 从数据到算法

##### 1.1 数据与数据结构

###### 1.1.1 数据及其类型

###### 1.1.2 数据结构简介

##### 1.2 算法

###### 1.2.1 算法的概念

###### 1.2.2 算法的分析

###### 1.2.3 算法的设计

##### 1.3 C++中的STL

###### 1.3.1 STL 简介

###### 1.3.2 STL 构成

###### 1.3.3 STL 的不同版本

#### 第2章 指针与数组--也谈中国古代兵制

##### 2.1 指针

###### 2.1.1 内存与地址

###### 2.1.2 指针的语法

###### 2.1.3 使用指针变量

###### 2.1.4 函数与参数传递

##### 2.2 数组

###### 2.2.1 结构型数据类型

###### 2.2.2 数组定义与初始化

###### 2.2.3 数组与指针

###### 2.2.4 数组的抽象数据类型

##### 2.3 数组应用举例

###### 2.3.1 Z 字形编排问题

###### 2.3.2 大整数乘法问题

###### 2.3.3 九宫格问题

##### 2.4 动态内存管理

###### 2.4.1 关键词new 和delete

###### 2.4.2 避免内存错误

#### 第3章 字符串与模式匹配--梦里寻她千百度

##### 3.1 基本概念与定义

###### 3.1.1 C++中的字符串

###### 3.1.2 字符串抽象数据类型

##### 3.2 文本的***匹配

###### 3.2.1 BF 算法

###### 3.2.2 MP 算法

###### 3.2.3 KMP 算法

###### 3.2.4 BM 算法

###### 3.2.5 BMH 算法

##### 3.3 文本的模糊匹配

###### 3.3.1 全局编辑距离

###### 3.3.2 局部***佳对准

###### 3.3.3 N 元距离模型

##### 3.3.4 语音编码模型

#### 第4章 链表--老鹰捉小鸡

##### 4.1 链表的概念

##### 4.2 单向链表

###### 4.2.1 单向链表的结构

###### 4.2.2 单向链表的操作算法

###### 4.2.3 有序链表的合并算法

##### 4.3 单向循环链表

###### 4.3.1 单向循环链表的结构

###### 4.3.2 单向循环链表的实现

###### 4.3.3 约瑟夫环的问题

###### 4.3.4 魔术师发牌问题

###### 4.3.5 拉丁方阵的问题

##### 4.4 双向循环链表

###### 4.4.1 双向循环链表的结构

###### 4.4.2 双向循环链表的实现

###### 4.4.3 维吉尼亚加密法问题

##### 4.5 游标类的设计与实现

###### 4.5.1 游标类的结构

###### 4.5.2 游标类的实现

##### 4.6 STL 与链表

###### 4.6.1 STL 中链表类的接口

###### 4.6.2 遍历

###### 4.6.3 元素的插入与删除

#### 第5章 **先出与后进先出--简单而深刻

##### 5.1 摞盘子的策略

###### 5.1.1 栈的结构

###### 5.1.2 栈的操作及实现

###### 5.1.3 括号匹配问题

###### 5.1.4 停车场模拟问题

##### 5.2 排队的智慧

###### 5.2.1 队列的结构

###### 5.2.2 队列的操作及实现

###### 5.2.3 舞伴问题

###### 5.2.4 杨辉三角问题

###### 5.2.5 游程编码问题

##### 5.3 优先级队列--兼谈页面置换算法

###### 5.3.1 优先级队列的结构

###### 5.3.2 优先级队列的实现

###### 5.4 STL 中的栈与队列

###### 5.4.1 STL 中的stack

###### 5.4.2 STL 中的queue

###### 5.4.3 STL 中的priority_queue

#### 第6章 递归--老和尚讲故事

##### 6.1 递归的概念

###### 6.1.1 定义

###### 6.1.2 应用递归的原则

###### 6.1.3 递归和非递归的转化

##### 6.2 分治法

###### 6.2.1 分治法简述

###### 6.2.2 汉诺塔问题

###### 6.2.3 传染病问题

##### 6.3 回溯法

###### 6.3.1 回溯法简述

###### 6.3.2 迷宫问题

###### 6.3.3 八皇后问题

#### 树

##### 7.1 认识树这种结构

###### 7.1.1 基本定义

###### 7.1.2 一些术语

###### 7.1.3 树的抽象

##### 7.2 花开二枝分外香--二叉树及相关算法

###### 7.2.1 二叉树的定义

###### 7.2.2 二叉树的性质

###### 7.2.3 二叉树的实现

###### 7.2.4 二叉树的遍历算法

###### 7.2.5 二叉树线索化算法

##### 7.3 合抱之木，生于毫末--从树到森林

###### 7.3.1 树的存储表示

###### 7.3.2 树的实现

###### 7.3.3 树与森林的遍历算法

###### 7.3.4 森林与二叉树的转换

##### 7.4 哈夫曼树--***优二叉树编码算法

###### 7.4.1 哈夫曼编码

###### 7.4.2 构造哈夫曼树

###### 7.4.3 哈夫曼编码的实现

##### 7.5 堆

###### 7.5.1 堆的概念

###### 7.5.2 堆的建立

###### 7.5.3 堆的操作

##### 7.6 基于STL 实现树结构

###### 7.6.1 STL 中的vector

###### 7.6.2 STL 中的map

#### 第8章 图--始于哥尼斯堡的七桥问题

##### 8.1 图的基本概念

###### 8.1.1 图的定义

###### 8.1.2 图的术语

###### 8.1.3 图的运算

###### 8.1.4 图的抽象数据类型

##### 8.2 图的存储与表示

###### 8.2.1 图的邻接矩阵表示

###### 8.2.2 图的邻接表表示

###### 8.2.3 两种表示法的比较

##### 8.3 图的遍历

###### 8.3.1 欧拉路径与欧拉回路

###### 8.3.2 哈密尔顿路径与哈密尔顿回路

###### 8.3.3 广度优先遍历算法

###### 8.3.4 深度优先遍历算法

##### 8.4 ***短路径问题

###### 8.4.1 固定起点***短路径问题

###### 8.4.2 非固定起点***短路径问题

###### 8.4.3 ***短路径的动态规划解法

##### 8.5 ***小生成树

###### 8.5.1 ***小生成树的定义

###### 8.5.2 克鲁斯卡尔算法

###### 8.5.3 普里姆算法

#### 第9章 树形搜索结构-

##### 9.1 二叉搜索树

###### 9.1.1 二叉搜索树的概念

###### 9.1.2 二叉搜索树的操作

###### 9.1.3 二叉搜索树的实现

###### 9.1.4 二叉搜索树的分析

##### 9.2 自平衡的二叉搜索树--**L 树

###### 9.2.1 **L 树的概念

###### 9.2.2 **L 树的旋转

###### 9.2.3 **L 树的实现

##### 9.3 树中亦有"红与黑"

###### 9.3.1 红黑树的概念

###### 9.3.2 红黑树的操作

###### 9.3.3 红黑树的实现

##### 9.4 基于Trie 树的单词检索

###### 9.4.1 Trie 树的概念

###### 9.4.2 Trie 树的表示

###### 9.4.3 Trie 树的实现

#### 第10章 集合与字典--再言搜索之话题

##### 10.1 集合论基础

###### 10.1.1 集合的概念

###### 10.1.2 集合的运算

##### 10.2 集合的实现

###### 10.2.1 位向量集合

###### 10.2.2 单链表集合

##### 10.3 字典

###### 10.3.1 字典的概念

###### 10.3.2 搜索运算

##### 10.4 散列

###### 10.4.1 散列的概念

###### 10.4.2 散列函数

###### 10.4.3 字符串散列

###### 10.4.4 处理散列冲突

##### 10.5 拼写检查问题

##### 10.6 不相交集

###### 10.6.1 不相交集的概念

###### 10.6.2 不相交集的实现

###### 10.6.3 犯罪团伙的问题

###### 10.6.4 路径压缩的实现

##### 10.7 STL 中的set

##### 本章参考文献

#### 第11章 排序--有序让世界***美好

##### 11.1 排序问题概述

###### 11.1.1 基本概念和定义

###### 11.1.2 排序算法的分类

###### 11.1.3 排序算法的分析

##### 11.2 插入排序

###### 11.2.1 直接插入排序

###### 11.2.2 二分插入排序

###### 11.2.3 希尔排序

##### 11.3 选择排序

###### 11.3.1 直接选择排序

###### 11.3.2 堆排序

##### 11.4 交换排序

###### 11.4.1 冒泡排序

###### 11.4.2 鸡尾酒排序

###### 11.4.3 快速排序

##### 11.5 归并排序

##### 11.6 计数排序

### 具体算法结构

#### 线性表

##### 顺序表

(增，删，查，改，销毁)

###### 静态顺序表

###### 动态顺序表

##### 链表

(增，删，查，改，销毁)

###### 单链表

####### 无头双链表

####### 有头单链表

###### 双链表

####### 无头双链表

####### 有头双链表

####### 无头循环双链表

####### 有头循环双链表

###### 三链表

##### 链表相关面试题

###### 1.链表的逆序

###### 2.无头链表的删除和插入

###### 3.链表带环问题

##### 顺序表与链表的优缺点

##### 栈和队列

###### 内容

####### 1、栈和队列的创建

####### 2、栈和队列的初始化

####### 3、栈的增容

####### 4、入栈，出栈，入队，出队

####### 5、取得栈顶，队头和队尾元素

####### 6、求栈和队列的大小，判断栈和队列是否为空

###### 栈

####### 一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作

####### 顺序队列

> 顺序栈

> 链式栈

> 栈的应用

###### 队列

####### 循环队列

####### 优先级队列

####### 队列的应用

#### 树形结构

##### 树的基本概念

###### 节点

###### 节点的度

###### 叶节点

###### 分支节点

###### 祖先节点

###### 双亲节点

###### 兄弟节点

###### 孩子节点

###### 树的深度

##### 树的表示方法

###### 双亲表示法

###### 孩子表示法

###### 双亲孩子表示法

###### 孩子兄弟表示法

##### 树的存储形式

##### 树的应用

##### 二叉树

###### 二叉树的概念

###### 二叉树的性质

###### 二叉树的存储

####### 顺序存储结构

####### 链式存储结构

###### 二叉树的基本操作

####### 二叉树的创建

####### 二叉树的遍历

(递归和非递归)

> 前序遍历

> 中序遍历

> 后序遍历

####### 二叉树的增、删、查、改、销毁

###### 二叉树相关面试题练习

####### 后序遍历

###### 线索化二叉树

##### 堆

###### 堆的概念

###### 堆的创建

####### 大堆

####### 小堆

###### 堆的插入和删除

###### 堆的应用

####### 优先级队列

####### 100亿个数中找出最大的前K个数（海量数据top K问题）

####### 堆排序（高校排序算法）

##### huffman树

###### huffman树基本概念

###### huffman树构建算法

###### huffman编码

###### huffman树的应用

(文件压缩与解压缩)

#### 搜索

##### 搜索概念

##### 搜索分类

###### 线性查找

####### 顺序查找：从前往后依次遍历O(n)

####### 顺序有序查找：二分查找O(log(N))

####### 索引顺序表

###### 树形查找

####### 二叉树结构

> 二叉搜索树

> 平衡树

   > AVL树

   > 红黑树

####### 多叉树结构

> B-树

> B+树

> B*树

###### 哈希查找

#### 哈希表

##### 哈希表概念

##### 哈希冲突及解决方法

###### 哈希函数

###### 哈希冲突——开散列

###### 哈希冲突——闭散列

##### 哈希表变形

###### 哈希表变形——位图

###### 哈希表变形——布隆过滤器

#### 排序

##### 插入排序

###### 直接插入排序

###### 希尔排序

##### 选择排序

###### 选择排序

###### 堆排序

##### 交换排序

###### 冒泡排序

###### 快速排序

##### 归并排序

##### 排序算法的优缺点

## 备注

> 最后修改时间：2023-04-23 11:15